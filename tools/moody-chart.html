<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moody Chart Reader | Tools Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/shared.css">

    <style>
        /* ============================================
           CSS Variables & Theme
           ============================================ */
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #12171f;
            --bg-card: #181f2a;
            --bg-input: #1e2734;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #5a6370;
            --border-color: #2d3748;
            --accent-primary: #f59e0b;
            --accent-primary-dim: rgba(245, 158, 11, 0.15);
            --accent-success: #22c55e;
            --accent-success-dim: rgba(34, 197, 94, 0.15);
            --accent-warning: #eab308;
            --accent-warning-dim: rgba(234, 179, 8, 0.15);
            --accent-error: #ef4444;
            --accent-error-dim: rgba(239, 68, 68, 0.15);
            --accent-info: #06b6d4;
            --accent-info-dim: rgba(6, 182, 212, 0.15);
            --accent-secondary: #6366f1;
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.4);
            
            /* Chart-specific colors */
            --chart-laminar: #06b6d4;
            --chart-smooth: #22c55e;
            --chart-transition: rgba(234, 179, 8, 0.2);
            --chart-point: #f59e0b;
            --chart-guides: rgba(245, 158, 11, 0.5);
        }

        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #f1f5f9;
            --bg-card: #ffffff;
            --bg-input: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #cbd5e1;
            --accent-primary-dim: rgba(245, 158, 11, 0.1);
            --accent-success-dim: rgba(34, 197, 94, 0.1);
            --accent-warning-dim: rgba(234, 179, 8, 0.1);
            --accent-error-dim: rgba(239, 68, 68, 0.1);
            --accent-info-dim: rgba(6, 182, 212, 0.1);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
        }

        /* ============================================
           Header
           ============================================ */
        header {
            padding: 24px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 24px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 24px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.15s ease;
        }

        .back-link svg {
            width: 18px;
            height: 18px;
        }

        .back-link:hover {
            color: var(--text-primary);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .tool-icon-header {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: var(--accent-engineering-dim, var(--accent-primary-dim));
            border: 1px solid rgba(245, 158, 11, 0.35);
            color: var(--accent-engineering, var(--accent-primary));
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-icon-header svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .tagline {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 4px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .status-badges {
            display: flex;
            gap: 8px;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .status-badge.ok {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
            color: var(--accent-success);
        }

        /* Theme Toggle (wrapper + two icon buttons, like ohms-law.html) */
        .theme-toggle {
            display: flex;
            gap: 6px;
            padding: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            border-radius: 10px;
        }

        .theme-toggle button {
            width: 36px;
            height: 36px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .theme-toggle button svg {
            width: 18px;
            height: 18px;
        }

        .theme-toggle button:hover {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-hover, rgba(245, 158, 11, 0.35));
        }

        /* “active” highlight based on html[data-theme] */
        html[data-theme="light"] .theme-toggle button[data-theme-toggle="light" aria-pressed="false"] {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-hover, rgba(245, 158, 11, 0.35));
        }

        html[data-theme="dark"] .theme-toggle button[data-theme-toggle="dark" aria-pressed="false"] {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-hover, rgba(245, 158, 11, 0.35));
        }

        /* fallback if your “dark” mode is the default (no attribute) */
        html:not([data-theme="light"]) .theme-toggle button[data-theme-toggle="dark" aria-pressed="false"] {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-hover, rgba(245, 158, 11, 0.35));
        }


        /* ============================================
           Main Layout
           ============================================ */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 360px;
            gap: 24px;
        }

        @media (max-width: 1200px) {
            .main-layout { 
                grid-template-columns: 1fr; 
            }
        }

        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .panel-title {
            font-size: 0.9375rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title svg {
            width: 18px;
            height: 18px;
            stroke: var(--accent-primary);
        }

        .panel-body {
            padding: 20px;
        }

        /* ============================================
           Toolbar
           ============================================ */
        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            align-items: center;
        }

        .tool-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tool-btn:hover:not(:disabled) {
            border-color: var(--accent-primary);
            background: var(--bg-card);
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tool-btn.primary {
            background: var(--accent-primary);
            color: #000;
            border-color: transparent;
            font-weight: 600;
        }

        .tool-btn.primary:hover:not(:disabled) {
            opacity: 0.9;
        }

        .tool-btn svg {
            width: 14px;
            height: 14px;
        }

        .tool-sep {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        /* Mode Toggle (Segmented Control) */
        .mode-toggle {
            display: flex;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-toggle button {
            padding: 10px 14px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .mode-toggle button:hover {
            color: var(--text-primary);
            background: var(--bg-input);
        }

        .mode-toggle button.active {
            background: var(--accent-primary);
            color: #000;
            font-weight: 600;
        }

        /* ============================================
           Section Headers
           ============================================ */
        .section-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .section {
            margin-bottom: 20px;
        }

        .section:last-child {
            margin-bottom: 0;
        }

        /* ============================================
           Parameters Grid (Inputs)
           ============================================ */
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .field label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .field input,
        .field select {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .field input:focus,
        .field select:focus {
            border-color: var(--accent-primary);
        }

        .field input::placeholder {
            color: var(--text-muted);
        }

        /* ============================================
           Toggle Checkboxes
           ============================================ */
        .toggle-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .toggle-item:hover {
            border-color: var(--accent-primary);
        }

        .toggle-item input[type="checkbox"] {
            display: none;
        }

        .toggle-box {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            flex-shrink: 0;
        }

        .toggle-item:hover .toggle-box {
            border-color: var(--accent-primary);
        }

        .toggle-item input:checked + .toggle-box {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .toggle-box svg {
            width: 10px;
            height: 10px;
            stroke: #000;
            stroke-width: 3;
            opacity: 0;
        }

        .toggle-item input:checked + .toggle-box svg {
            opacity: 1;
        }

        .toggle-label {
            font-size: 0.75rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        /* ============================================
           Values Panel
           ============================================ */
        .values-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .values-header {
            padding: 12px 16px;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-success);
        }

        .status-dot.warn {
            background: var(--accent-warning);
        }

        .status-dot.error {
            background: var(--accent-error);
        }

        .values-body {
            padding: 12px 16px;
        }

        .value-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .value-row:last-child {
            border-bottom: none;
        }

        .value-name {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .value-number {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .value-number.muted {
            color: var(--text-muted);
            font-weight: 400;
            font-size: 0.75rem;
        }

        /* ============================================
           Info Buttons
           ============================================ */
        .info-buttons {
            display: flex;           /* Changed from grid to flex */
            flex-wrap: wrap;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .info-btn {
            flex: 1 1 auto;          
            min-width: fit-content;  
            padding: 10px 12px;      
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .info-btn:hover {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        /* ============================================
           Chart Panel
           ============================================ */
        .chart-area {
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 600px;
        }

        .chart-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .chart-legend {
            display: flex;
            gap: 16px;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-secondary);
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-line.laminar { background: var(--chart-laminar); }
        .legend-line.smooth { background: var(--chart-smooth); }
        .legend-line.rough { 
            background: var(--accent-secondary); 
            height: 2px;
        }

        .chart-container {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            min-height: 500px;
        }

        #moodyCanvas {
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        /* ============================================
           Modal
           ============================================ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 20, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 24px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            max-width: 640px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-secondary);
        }

        .modal-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            font-size: 0.9375rem;
            line-height: 1.7;
        }

        .modal-body h3 {
            font-size: 0.9375rem;
            font-weight: 700;
            margin: 24px 0 12px;
            color: var(--accent-primary);
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        .modal-body ul, .modal-body ol {
            margin: 12px 0;
            padding-left: 24px;
            color: var(--text-secondary);
        }

        .modal-body li {
            margin-bottom: 6px;
        }

        .modal-body code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8125rem;
            background: var(--bg-input);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--accent-info);
        }

        .modal-body .equation {
            display: block;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-primary);
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-align: center;
            color: var(--text-primary);
        }

        .modal-body .warning-box {
            background: var(--accent-warning-dim);
            border: 1px solid rgba(234, 179, 8, 0.3);
            border-radius: 8px;
            padding: 14px 18px;
            margin: 16px 0;
            font-size: 0.875rem;
        }

        .modal-body .warning-box strong {
            color: var(--accent-warning);
        }

        .modal-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.8125rem;
        }

        .modal-body th, .modal-body td {
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .modal-body th {
            background: var(--bg-secondary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .modal-body td {
            color: var(--text-primary);
        }

        /* ============================================
           Foldable Calculations Section
           ============================================ */
        .foldable-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .foldable-header:hover {
            border-color: var(--accent-primary);
            background: var(--bg-input);
        }

        .foldable-header.active {
            border-radius: 8px 8px 0 0;
            border-bottom-color: transparent;
        }

        .foldable-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .foldable-title svg {
            width: 16px;
            height: 16px;
            stroke: var(--accent-primary);
        }

        .foldable-chevron {
            width: 16px;
            height: 16px;
            stroke: var(--text-muted);
            transition: transform 0.2s;
        }

        .foldable-header.active .foldable-chevron {
            transform: rotate(180deg);
        }

        .foldable-content {
            display: none;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .foldable-content.active {
            display: block;
        }

        .calc-section {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .calc-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .calc-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            font-weight: 600;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
        }

        .calc-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 0.75rem;
        }

        .calc-label {
            color: var(--text-secondary);
        }

        .calc-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            font-weight: 500;
        }

        .calc-value.calc-small {
            font-size: 0.6875rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .calc-value.calc-result {
            color: var(--accent-primary);
            font-size: 0.875rem;
            font-weight: 600;
        }

        .calc-value.calc-success {
            color: var(--accent-success);
        }

        .calc-value.calc-warning {
            color: var(--accent-warning);
        }

        .calc-equation {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-primary);
            border-radius: 6px;
            padding: 12px 14px;
        }

        .eq-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .eq-formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8125rem;
            color: var(--text-primary);
        }

        .calc-iterations {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            background: var(--bg-input);
            border-radius: 6px;
            padding: 10px 12px;
            max-height: 120px;
            overflow-y: auto;
        }

        .calc-iter-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .calc-iter-row:last-child {
            border-bottom: none;
            color: var(--accent-success);
            font-weight: 500;
        }

        .calc-iter-num {
            color: var(--text-muted);
            min-width: 24px;
        }

        .calc-iter-f {
            color: var(--text-primary);
        }

        .calc-iter-delta {
            color: var(--text-muted);
            font-size: 0.625rem;
        }

        .calc-warning {
            background: var(--accent-warning-dim);
            border: 1px solid rgba(234, 179, 8, 0.3);
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 0.75rem;
            color: var(--accent-warning);
        }

        /* Nested Foldable (Step-by-Step) */
        .nested-foldable-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            margin-top: 10px;
            background: var(--bg-input);
            border: 1px dashed var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            color: var(--text-secondary);
        }

        .nested-foldable-header:hover {
            border-color: var(--accent-info);
            color: var(--accent-info);
            background: var(--accent-info-dim);
        }

        .nested-foldable-header.active {
            border-style: solid;
            border-color: var(--accent-info);
            border-radius: 6px 6px 0 0;
            border-bottom: none;
            color: var(--accent-info);
        }

        .nested-chevron {
            width: 14px;
            height: 14px;
            transition: transform 0.2s;
        }

        .nested-foldable-header.active .nested-chevron {
            transform: rotate(180deg);
        }

        .nested-foldable-content {
            display: none;
            background: var(--bg-input);
            border: 1px solid var(--accent-info);
            border-top: none;
            border-radius: 0 0 6px 6px;
            padding: 14px;
        }

        .nested-foldable-content.active {
            display: block;
        }

        /* Step-by-Step Styles */
        .steps-container {
            font-size: 0.75rem;
        }

        .step-group {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px dashed var(--border-color);
        }

        .step-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .step-group-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            font-weight: 600;
            color: var(--accent-info);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 8px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 4px;
            border-left: 2px solid var(--border-color);
        }

        .step-item.highlight {
            border-left-color: var(--accent-primary);
            background: var(--accent-primary-dim);
        }

        .step-item.result {
            border-left-color: var(--accent-success);
            background: var(--accent-success-dim);
        }

        .step-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            font-weight: 700;
            color: var(--text-muted);
            min-width: 20px;
        }

        .step-content {
            flex: 1;
        }

        .step-desc {
            color: var(--text-secondary);
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .step-math {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-primary);
            background: var(--bg-primary);
            padding: 6px 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: nowrap;
        }

        .step-note {
            font-size: 0.6875rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 4px;
        }

        .step-arrow {
            color: var(--accent-primary);
            font-weight: bold;
        }

        /* ============================================
           Responsive
           ============================================ */
        @media (max-width: 768px) {
            .toggle-grid {
                grid-template-columns: 1fr;
            }
            
            .info-buttons {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        .disclaimer-container,
        .footer-content {
            max-width: 1600px;       
            margin: 0 auto;          
            padding: 0 24px;         
        }

        .disclaimer-content {
            padding: 24px 0;         
            border-top: 1px solid var(--border-color);
            color: var(--text-muted);
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            text-align: center;
            opacity: 0.8;
        }

        /* Ensure footer text aligns nicely too */
        footer {
            border-top: 1px solid var(--border-color);
            background: var(--bg-primary); /* Ensure it blends */
            margin-top: 0;
        }

        .disclaimer-content strong {
            color: var(--text-secondary);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="header-content">
                <div class="header-left">
                    <a href="../tools.html" class="back-link">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="19" y1="12" x2="5" y2="12"/>
                            <polyline points="12 19 5 12 12 5"/>
                        </svg>
                        Back to Tools
                    </a>
                </div>

                <div class="header-right">
                    <div class="theme-toggle">
                        <button data-theme-toggle="light" aria-pressed="false" title="Light mode">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="5"/>
                                <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                            </svg>
                        </button>
                        <button data-theme-toggle="dark" aria-pressed="false" title="Dark mode">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>

            <div style="margin-top: 24px; display: flex; align-items: center; justify-content: space-between; gap: 16px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 16px;">
                    <div class="tool-icon-header engineering">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 3v18h18"/>
                            <path d="M7 16l4-8 4 4 5-9"/>
                        </svg>
                    </div>
                    <div>
                        <h1>Moody Chart Reader</h1>
                        <p class="tagline">// FRICTION FACTOR • REYNOLDS • ROUGHNESS</p>
                    </div>
                </div>

                <div class="status-badges">
                    <span class="status-badge ok" id="statusBadge">● Turbulent</span>
                    <span class="status-badge">Darcy f<sub>D</sub></span>
                </div>
            </div>
        </header>


        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Chart Panel (Left) -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <path d="M3 9h18M9 21V9"/>
                        </svg>
                        Moody Diagram
                    </div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <span class="legend-line laminar"></span>
                            <span>Laminar (f=64/Re)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-line smooth"></span>
                            <span>Smooth (Prandtl)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-line rough"></span>
                            <span>Constant ε/D (Colebrook)</span>
                        </div>
                    </div>
                </div>
                <div class="chart-area">
                    <div class="chart-toolbar">
                        <div class="mode-toggle">
                            <button class="active" data-mode="drag">Drag to Read</button>
                            <button data-mode="compute">Compute f</button>
                            <button data-mode="infer">Infer ε/D</button>
                        </div>
                        <div class="toolbar">
                            <button class="tool-btn" onclick="resetView()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                                Reset
                            </button>
                            <button class="tool-btn" onclick="exportPng()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                                Export PNG
                            </button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="moodyCanvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- Controls Panel (Right) -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                        </svg>
                        Controls
                    </div>
                </div>
                <div class="panel-body">
                    <!-- Input Parameters Section -->
                    <div class="section" id="inputSection" style="display: none;">
                        <div class="section-header">Input Parameters</div>
                        <div class="params-grid">
                            <div class="field">
                                <label>Reynolds Number (Re) <span style="font-size: 0.7em; color: var(--text-muted);">= ρVD/μ</span></label>
                                <input type="text" id="inputRe" value="100000" placeholder="e.g., 100000">
                            </div>
                            <div class="field" id="inputRelRoughRow">
                                <label>Relative Roughness (ε/D) <span style="font-size: 0.7em; color: var(--text-muted);">= roughness/diameter</span></label>
                                <input type="text" id="inputRelRough" value="0.001" placeholder="e.g., 0.001">
                            </div>
                            <div class="field" id="inputFrictionRow" style="display: none;">
                                <label>Darcy Friction Factor (f<sub>D</sub>) <span style="font-size: 0.7em; color: var(--text-muted);">for Darcy-Weisbach eq.</span></label>
                                <input type="text" id="inputFriction" value="0.02" placeholder="e.g., 0.02">
                            </div>
                        </div>
                        <div class="toolbar" style="margin-top: 12px;">
                            <button class="tool-btn primary" id="computeBtn">Calculate</button>
                            <button class="tool-btn" id="resetInputBtn">Reset</button>
                        </div>
                    </div>

                    <!-- Display Toggles -->
                    <div class="section">
                        <div class="section-header">Chart Overlays</div>
                        <div class="toggle-grid">
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleRoughCurves" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">ε/D curves</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleCurveLabels" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Labels</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleLaminar" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Laminar</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleSmooth" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Smooth</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleTransition" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Transition</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleGrid" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Grid</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleGuides" checked>
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Guides</span>
                            </label>
                            <label class="toggle-item">
                                <input type="checkbox" id="toggleFullRough">
                                <span class="toggle-box"><svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg></span>
                                <span class="toggle-label">Full rough</span>
                            </label>
                        </div>
                    </div>

                    <!-- Current Values -->
                    <div class="section">
                        <div class="section-header">Current Values</div>
                        <div class="values-card">
                            <div class="values-header">
                                <span class="status-dot" id="statusDot"></span>
                                <span id="regimeLabel">Turbulent Flow</span>
                            </div>
                            <div class="values-body">
                                <div class="value-row">
                                    <span class="value-name">Re <span style="font-weight:400;color:var(--text-muted);font-size:0.8em;">(inertia/viscosity)</span></span>
                                    <span class="value-number" id="valRe">1.00×10⁵</span>
                                </div>
                                <div class="value-row">
                                    <span class="value-name">f<sub>D</sub> <span style="font-weight:400;color:var(--text-muted);font-size:0.8em;">(Darcy friction)</span></span>
                                    <span class="value-number" id="valFd">0.0198</span>
                                </div>
                                <div class="value-row">
                                    <span class="value-name">f<sub>F</sub> <span style="font-weight:400;color:var(--text-muted);font-size:0.8em;">(Fanning = f<sub>D</sub>/4)</span></span>
                                    <span class="value-number muted" id="valFf">0.00495</span>
                                </div>
                                <div class="value-row">
                                    <span class="value-name">ε/D <span style="font-weight:400;color:var(--text-muted);font-size:0.8em;">(rel. roughness)</span></span>
                                    <span class="value-number" id="valRelRough">0.001</span>
                                </div>
                                <div class="value-row">
                                    <span class="value-name">Equation</span>
                                    <span class="value-number muted" id="valMethod">Colebrook</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Calculations Foldable -->
                    <div class="section">
                        <button class="foldable-header" id="calcFoldableBtn">
                            <div class="foldable-title">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                                </svg>
                                <span>Calculation Details</span>
                            </div>
                            <svg class="foldable-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <div class="foldable-content" id="calcFoldableContent">
                            <div class="calc-section">
                                <div class="calc-header">Input Parameters</div>
                                <div class="calc-row">
                                    <span class="calc-label">Reynolds Number (Re)</span>
                                    <span class="calc-value" id="calcRe">100,000</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Relative Roughness (ε/D)</span>
                                    <span class="calc-value" id="calcRelRough">0.001</span>
                                </div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Flow Regime Classification</div>
                                <div class="calc-row">
                                    <span class="calc-label">Regime</span>
                                    <span class="calc-value" id="calcRegime">Turbulent</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Classification Logic</span>
                                    <span class="calc-value calc-small" id="calcRegimeLogic">Re > 4000 → Turbulent</span>
                                </div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Equation Used</div>
                                <div class="calc-equation" id="calcEquation">
                                    <div class="eq-name">Colebrook-White Equation</div>
                                    <div class="eq-formula">1/√f = -2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))</div>
                                </div>
                                
                                <!-- Nested foldable for step-by-step -->
                                <button class="nested-foldable-header" id="stepsBtn">
                                    <span>📐 Show Step-by-Step Derivation</span>
                                    <svg class="nested-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="6 9 12 15 18 9"></polyline>
                                    </svg>
                                </button>
                                <div class="nested-foldable-content" id="stepsContent">
                                    <div class="steps-container" id="equationSteps">
                                        <!-- Populated dynamically based on equation type -->
                                    </div>
                                </div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Solution Method</div>
                                <div class="calc-row">
                                    <span class="calc-label">Algorithm</span>
                                    <span class="calc-value" id="calcAlgorithm">Fixed-point iteration</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Initial Guess (Swamee-Jain)</span>
                                    <span class="calc-value" id="calcInitialGuess">0.01985</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Convergence Tolerance</span>
                                    <span class="calc-value">1×10⁻¹⁰ (relative)</span>
                                </div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Iteration Log</div>
                                <div class="calc-iterations" id="calcIterations">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Final Result</div>
                                <div class="calc-row">
                                    <span class="calc-label">Darcy Friction Factor (f<sub>D</sub>)</span>
                                    <span class="calc-value calc-result" id="calcFinalF">0.019829</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Fanning Friction Factor (f<sub>F</sub>)</span>
                                    <span class="calc-value" id="calcFinalFanning">0.004957</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Iterations Required</span>
                                    <span class="calc-value" id="calcIterCount">6</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Converged</span>
                                    <span class="calc-value calc-success" id="calcConverged">✓ Yes</span>
                                </div>
                            </div>
                            
                            <div class="calc-section" id="calcWarningSection" style="display: none;">
                                <div class="calc-header">⚠️ Warnings</div>
                                <div class="calc-warning" id="calcWarning"></div>
                            </div>
                            
                            <div class="calc-section">
                                <div class="calc-header">Verification</div>
                                <div class="calc-row">
                                    <span class="calc-label">Back-substitution check</span>
                                    <span class="calc-value calc-small" id="calcVerify">LHS = RHS ✓</span>
                                </div>
                                <div class="calc-row">
                                    <span class="calc-label">Residual</span>
                                    <span class="calc-value" id="calcResidual">2.3×10⁻¹²</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Info Buttons -->
                    <div class="info-buttons">
                        <button class="info-btn" data-modal="directions">Directions</button>
                        <button class="info-btn" data-modal="details">Details</button>
                        <button class="info-btn" data-modal="assumptions">Assumptions</button>
                        <button class="info-btn" data-modal="techref">Tech Ref</button>
                        <button class="info-btn" data-modal="about">About</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="disclaimer-container">
        <div class="disclaimer-content">
            <strong>Engineering Disclaimer:</strong> This tool is provided for educational and informational purposes only. While algorithms are based on standard fluid mechanics correlations (Colebrook-White, Prandtl-von Kármán), the software is provided "as is" without warranty of any kind, express or implied. The authors assume no liability for errors, omissions, or damages resulting from the use of this tool. Users must verify all critical calculations against standard engineering references.
        </div>
    </div>

    <footer data-footer></footer>

    <!-- Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Title</h2>
                <button class="modal-close" id="modalClose">×</button>
            </div>
            <div class="modal-body" id="modalBody"></div>
        </div>
    </div>

    <script src="../js/shared.js"></script>
    <script src="../js/footer.js"></script>
    <script>
    /* ========================================
       MOODY CHART READER
       ======================================== */

    // ========================================
    // CONFIGURATION
    // ========================================
    // TECHNICAL REFERENCE: All constants documented here with sources
    // For verification, see Tech Ref modal or run TEST.run() in console
    const CONFIG = {
        Re: { min: 500, max: 1e8 },           // Reynolds number range for chart display
        fD: { min: 0.006, max: 0.1 },         // Darcy friction factor range (NOT Fanning!)
        margin: { top: 50, right: 90, bottom: 70, left: 90 },
        
        // Standard relative roughness values for Moody chart curves
        // Source: Moody, L.F. (1944), Trans. ASME 66(8), 671-684
        relRoughnessValues: [
            0.00001, 0.00005, 0.0001, 0.0002, 0.0004, 
            0.0006, 0.001, 0.002, 0.004, 0.006, 
            0.01, 0.015, 0.02, 0.03, 0.04, 0.05
        ],
        
        // Numerical solver parameters
        // Tolerance: 1e-10 relative error (far exceeds physical accuracy of ±5-10%)
        // Max iterations: 100 (safety limit; typical convergence in 3-8 iterations)
        solver: { tolerance: 1e-10, maxIterations: 100 },
        
        // Transition region boundaries
        // Source: Classical fluid mechanics; Re_crit ≈ 2300 (Reynolds, 1883)
        // Upper bound 4000 is conventional; some sources use 2300-10000
        transition: { ReMin: 2300, ReMax: 4000 },
        
        colors: {
            get laminar() { return getComputedStyle(document.documentElement).getPropertyValue('--chart-laminar').trim() || '#06b6d4'; },
            get smooth() { return getComputedStyle(document.documentElement).getPropertyValue('--chart-smooth').trim() || '#22c55e'; },
            get point() { return getComputedStyle(document.documentElement).getPropertyValue('--chart-point').trim() || '#f59e0b'; },
            get guides() { return getComputedStyle(document.documentElement).getPropertyValue('--chart-guides').trim() || 'rgba(245, 158, 11, 0.5)'; },
            roughCurves: [
                '#6366f1', '#7c3aed', '#8b5cf6', '#a855f7', '#c026d3',
                '#db2777', '#e11d48', '#ef4444', '#f97316', '#fb923c',
                '#fbbf24', '#facc15', '#a3e635', '#4ade80', '#2dd4bf', '#22d3ee'
            ]
        }
    };

    // ========================================
    // NUMERICAL SOLVERS (with detailed iteration logging)
    // ========================================
    // EQUATION CONSTANTS REFERENCE:
    // ─────────────────────────────────────────────────────────────────────
    // Laminar:        f = 64/Re
    //                 Exact analytical (Hagen-Poiseuille), not empirical
    //
    // Colebrook:      1/√f = -2.0·log₁₀(ε/(3.7D) + 2.51/(Re·√f))
    //                 Constants: 2.0, 3.7, 2.51
    //                 Source: Colebrook, C.F. (1939), J. Inst. Civil Eng. 11(4), 133-156
    //
    // Prandtl:        1/√f = 2.0·log₁₀(Re·√f) - 0.8
    //                 Constants: 2.0, 0.8 (classical PNK values)
    //                 Source: Prandtl-Nikuradse-Kármán, widely cited in textbooks
    //                 Note: Zagarola & Smits (1998) propose 1.930 and 0.537;
    //                       this implementation uses classical values for
    //                       consistency with Colebrook and standard Moody chart.
    //
    // von Kármán:     1/√f = -2.0·log₁₀(ε/(3.7D)) = 1.14 - 2.0·log₁₀(ε/D)
    //                 Fully rough limit (Re → ∞)
    //
    // Swamee-Jain:    f ≈ 0.25/[log₁₀(ε/(3.7D) + 5.74/Re^0.9)]²
    //                 Source: Swamee & Jain (1976), J. Hydraulics Div. ASCE 102(5)
    //                 Used as initial guess for Colebrook iteration
    //
    // Blasius:        f ≈ 0.316/Re^0.25
    //                 Valid for smooth pipes, 4000 < Re < 10^5
    //                 Used as initial guess for smooth pipe solver
    // ─────────────────────────────────────────────────────────────────────
    const SOLVER = {
        // Laminar flow: exact analytical solution (Hagen-Poiseuille)
        // Coefficient 64 is derived from Navier-Stokes, not empirical
        laminar(Re) {
            if (Re <= 0) return { f: NaN, error: 'Re must be positive' };
            const f = 64 / Re;
            return { 
                f, 
                method: 'Laminar (64/Re)', 
                converged: true, 
                iterations: 1,
                iterationLog: [{ i: 1, f, delta: 0 }],
                equation: 'f = 64/Re',
                equationName: 'Hagen-Poiseuille (Laminar)',
                initialGuess: null,
                algorithm: 'Direct calculation'
            };
        },

        // Smooth pipe: Prandtl-von Kármán equation
        // 1/√f = 2.0·log₁₀(Re·√f) - 0.8
        // Constants 2.0 and 0.8 are classical PNK values (see header comments)
        // Solved via Newton-Raphson: G(f) = 1/√f - 2·log₁₀(Re·√f) + 0.8 = 0
        smoothPipe(Re, tol = CONFIG.solver.tolerance, maxIter = CONFIG.solver.maxIterations) {
            if (Re <= 0) return { f: NaN, error: 'Re must be positive' };
            
            // Initial guess: Blasius (valid for Re < 10^5)
            // f ≈ 0.316/Re^0.25 — Source: Blasius (1913)
            let f = Re < 1e5 ? 0.316 / Math.pow(Re, 0.25) : 0.01;
            const initialGuess = f;
            const iterationLog = [];
            
            for (let i = 0; i < maxIter; i++) {
                const sqrtF = Math.sqrt(f);
                // G(f) = 1/√f - 2·log₁₀(Re·√f) + 0.8
                // Note: +0.8 because equation is 1/√f = 2·log₁₀(Re·√f) - 0.8
                const G = 1/sqrtF - 2 * Math.log10(Re * sqrtF) + 0.8;
                // G'(f) = d/df[f^(-1/2)] - 2·d/df[log₁₀(Re·f^(1/2))]
                //       = -0.5·f^(-3/2) - 2/(ln(10))·(1/2)·f^(-1/2)·(1/f^(1/2))
                //       = -0.5·f^(-3/2) - 1/(ln(10)·f)
                const dG = -0.5 / Math.pow(f, 1.5) - 1 / (Math.LN10 * f);
                const fNew = f - G / dG;
                
                if (fNew <= 0) { 
                    f = f / 2; 
                    iterationLog.push({ i: i + 1, f, delta: null, note: 'Negative correction, halved' });
                    continue; 
                }
                
                const delta = Math.abs(fNew - f) / f;
                iterationLog.push({ i: i + 1, f: fNew, delta });
                
                if (delta < tol) {
                    return { 
                        f: fNew, 
                        method: 'Prandtl (smooth)', 
                        converged: true, 
                        iterations: i + 1,
                        iterationLog,
                        equation: '1/√f = 2·log₁₀(Re·√f) - 0.8',
                        equationName: 'Prandtl-von Kármán (Smooth Pipe)',
                        initialGuess,
                        algorithm: 'Newton-Raphson iteration',
                        residual: delta
                    };
                }
                f = fNew;
            }
            return { 
                f, 
                method: 'Prandtl (smooth)', 
                converged: false, 
                iterations: maxIter,
                iterationLog,
                equation: '1/√f = 2·log₁₀(Re·√f) - 0.8',
                equationName: 'Prandtl-von Kármán (Smooth Pipe)',
                initialGuess,
                algorithm: 'Newton-Raphson iteration',
                warning: 'Did not converge within max iterations'
            };
        },

        // Colebrook-White equation (1939)
        // 1/√f = -2.0·log₁₀(ε/(3.7D) + 2.51/(Re·√f))
        // Constants: -2.0, 3.7, 2.51 — Source: Colebrook (1939), Eq. 4
        // Solved via fixed-point iteration (successive substitution)
        colebrook(Re, relRoughness, tol = CONFIG.solver.tolerance, maxIter = CONFIG.solver.maxIterations) {
            if (Re <= 0) return { f: NaN, error: 'Re must be positive' };
            if (relRoughness < 0) return { f: NaN, error: 'ε/D must be non-negative' };
            // For very smooth pipes, delegate to Prandtl solver
            if (relRoughness < 1e-7) return this.smoothPipe(Re, tol, maxIter);
            
            // Initial guess: Swamee-Jain explicit approximation (1976)
            // f ≈ 0.25/[log₁₀(ε/(3.7D) + 5.74/Re^0.9)]²
            // Accurate to ±1% for 10⁻⁶ < ε/D < 10⁻² and 5×10³ < Re < 10⁸
            const term = relRoughness / 3.7 + 5.74 / Math.pow(Re, 0.9);
            let f = 0.25 / Math.pow(Math.log10(term), 2);
            const initialGuess = f;
            const iterationLog = [];
            
            for (let i = 0; i < maxIter; i++) {
                const sqrtF = Math.sqrt(f);
                // Colebrook equation rearranged for fixed-point iteration:
                // RHS = -2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))
                // f_new = 1/RHS²
                const rhs = -2 * Math.log10(relRoughness / 3.7 + 2.51 / (Re * sqrtF));
                const fNew = 1 / (rhs * rhs);
                
                const delta = Math.abs(fNew - f) / f;
                iterationLog.push({ i: i + 1, f: fNew, delta });
                
                if (delta < tol) {
                    // Calculate residual for verification
                    const sqrtFinal = Math.sqrt(fNew);
                    const lhs = 1 / sqrtFinal;
                    const rhsFinal = -2 * Math.log10(relRoughness / 3.7 + 2.51 / (Re * sqrtFinal));
                    const residual = Math.abs(lhs - rhsFinal);
                    
                    return { 
                        f: fNew, 
                        method: 'Colebrook', 
                        converged: true, 
                        iterations: i + 1, 
                        relRoughness,
                        iterationLog,
                        equation: '1/√f = -2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))',
                        equationName: 'Colebrook-White Equation',
                        initialGuess,
                        algorithm: 'Fixed-point iteration',
                        residual,
                        verification: { lhs, rhs: rhsFinal }
                    };
                }
                f = fNew;
            }
            return { 
                f, 
                method: 'Colebrook', 
                converged: false, 
                iterations: maxIter, 
                relRoughness,
                iterationLog,
                equation: '1/√f = -2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))',
                equationName: 'Colebrook-White Equation',
                initialGuess,
                algorithm: 'Fixed-point iteration',
                warning: 'Did not converge within max iterations'
            };
        },

        // Fully rough limit: von Kármán equation
        // 1/√f = -2.0·log₁₀(ε/(3.7D))
        // Equivalent to: 1/√f = 1.14 - 2.0·log₁₀(ε/D)
        // Valid when Re → ∞ (viscous sublayer negligible compared to roughness)
        fullyRough(relRoughness) {
            if (relRoughness <= 0) return { f: NaN, error: 'ε/D must be positive' };
            const term = relRoughness / 3.7;
            const f = 1 / Math.pow(-2 * Math.log10(term), 2);
            return { 
                f, 
                method: 'von Kármán (fully rough)',
                equation: '1/√f = -2·log₁₀(ε/(3.7D))',
                equationName: 'von Kármán (Fully Rough Limit)',
                algorithm: 'Direct calculation',
                converged: true,
                iterations: 1
            };
        },

        // Inverse Colebrook: infer ε/D from measured (Re, f)
        // Rearranging Colebrook: ε/D = 3.7·(10^(-1/(2√f)) - 2.51/(Re·√f))
        // Valid only for turbulent flow (Re > 4000); roughness is meaningless in laminar
        inferRelRoughness(Re, f) {
            if (Re <= 0 || f <= 0) return { relRoughness: NaN, error: 'Invalid inputs' };
            
            // Regime guard: roughness inference is only meaningful for fully turbulent flow
            if (Re < CONFIG.transition.ReMax) {
                return {
                    relRoughness: 0,
                    method: 'Colebrook (inverse)',
                    equation: 'ε/D = 3.7·(10^(-1/(2√f)) - 2.51/(Re·√f))',
                    equationName: 'Rearranged Colebrook',
                    algorithm: 'N/A (invalid regime)',
                    warning: Re < CONFIG.transition.ReMin 
                        ? 'Roughness inference not valid in laminar regime (Re < 2300). Friction factor is independent of roughness.'
                        : 'Roughness inference not valid in transition regime (2300 ≤ Re ≤ 4000). Flow behavior is unpredictable.',
                    regimeWarning: true
                };
            }
            
            const sqrtF = Math.sqrt(f);
            const term1 = Math.pow(10, -1 / (2 * sqrtF));
            const term2 = 2.51 / (Re * sqrtF);
            const relRoughness = 3.7 * (term1 - term2);
            
            const result = {
                relRoughness: Math.max(0, relRoughness),
                method: 'Colebrook (inverse)',
                equation: 'ε/D = 3.7·(10^(-1/(2√f)) - 2.51/(Re·√f))',
                equationName: 'Rearranged Colebrook',
                algorithm: 'Direct calculation'
            };
            
            if (relRoughness < 0) {
                result.relRoughness = 0;
                result.warning = 'Computed ε/D < 0; point is below smooth pipe curve';
            } else if (relRoughness > 0.05) {
                result.warning = 'Computed ε/D > 0.05; outside typical Moody chart range';
            }
            
            return result;
        },

        getFrictionFactor(Re, relRoughness) {
            if (Re < CONFIG.transition.ReMin) {
                const result = this.laminar(Re);
                result.regime = 'Laminar';
                result.regimeLogic = `Re (${Re.toFixed(0)}) < 2300 → Laminar`;
                return result;
            } else if (Re <= CONFIG.transition.ReMax) {
                // TRANSITION REGION (2300 ≤ Re ≤ 4000)
                // ─────────────────────────────────────────────────────────────
                // WARNING: This region is inherently unstable. No universally
                // accepted equation exists. The interpolation below is for
                // visual continuity only; values should not be used for design.
                //
                // Method: Log-linear interpolation at current Re
                // f = 10^[(1-t)·log₁₀(f_lam(Re)) + t·log₁₀(f_turb(Re))]
                // where t = [log₁₀(Re) - log₁₀(2300)] / [log₁₀(4000) - log₁₀(2300)]
                //
                // This ensures:
                //   - At Re=2300: t=0, f = 64/Re (matches laminar boundary)
                //   - At Re=4000: t=1, f = Colebrook (matches turbulent boundary)
                //   - Smooth visual transition on log-log chart
                // ─────────────────────────────────────────────────────────────
                const fLamCurrent = 64 / Re;  // Laminar f at current Re
                const turbResultCurrent = this.colebrook(Re, relRoughness);
                const fTurbCurrent = turbResultCurrent.f;
                
                // Boundary values for continuity check
                const fLamBoundary = 64 / CONFIG.transition.ReMin;  // f at Re=2300
                const turbResultBoundary = this.colebrook(CONFIG.transition.ReMax, relRoughness);
                const fTurbBoundary = turbResultBoundary.f;
                
                // Interpolation parameter (0 at Re=2300, 1 at Re=4000)
                const t = (Math.log10(Re) - Math.log10(CONFIG.transition.ReMin)) / 
                          (Math.log10(CONFIG.transition.ReMax) - Math.log10(CONFIG.transition.ReMin));
                
                // Blend laminar and turbulent contributions at current Re
                // At t=0: f = fLamCurrent (which equals fLamBoundary at Re=2300)
                // At t=1: f = fTurbCurrent (which equals fTurbBoundary at Re=4000)
                const f = Math.pow(10, Math.log10(fLamCurrent) * (1 - t) + Math.log10(fTurbCurrent) * t);
                
                return { 
                    f, 
                    regime: 'Transitional', 
                    regimeLogic: `2300 ≤ Re (${Re.toFixed(0)}) ≤ 4000 → Transitional`,
                    method: 'Interpolated', 
                    warning: 'Transition region: flow is unstable. Friction factor may increase as turbulence develops. Values are approximate.',
                    converged: true, 
                    relRoughness,
                    equation: `f = 10^((1-t)·log(f_lam(Re)) + t·log(f_turb(Re))), t=${t.toFixed(3)}`,
                    equationName: 'Log-linear Interpolation (at current Re)',
                    algorithm: 'Blending laminar and turbulent at current Re',
                    iterationLog: [{ i: 1, f, delta: 0, note: 'Interpolated' }],
                    details: { 
                        fLamCurrent, 
                        fTurbCurrent, 
                        fLamBoundary,
                        fTurbBoundary,
                        t 
                    }
                };
            } else {
                const result = this.colebrook(Re, relRoughness);
                result.regime = 'Turbulent';
                result.regimeLogic = `Re (${Re.toExponential(2)}) > 4000 → Turbulent`;
                return result;
            }
        }
    };

    // ========================================
    // COORDINATE SYSTEM
    // ========================================
    const COORDS = {
        canvas: null,
        chartArea: null,

        init(canvas) {
            this.canvas = canvas;
            // Use CSS pixel dimensions (getBoundingClientRect), not device pixels (canvas.width)
            // This is critical for correct coordinate mapping on high-DPI displays
            const rect = canvas.getBoundingClientRect();
            this.chartArea = {
                x: CONFIG.margin.left,
                y: CONFIG.margin.top,
                width: rect.width - CONFIG.margin.left - CONFIG.margin.right,
                height: rect.height - CONFIG.margin.top - CONFIG.margin.bottom
            };
        },

        reToX(Re) {
            const logRe = Math.log10(Re);
            const logMin = Math.log10(CONFIG.Re.min);
            const logMax = Math.log10(CONFIG.Re.max);
            return this.chartArea.x + ((logRe - logMin) / (logMax - logMin)) * this.chartArea.width;
        },

        fToY(f) {
            const logF = Math.log10(f);
            const logMin = Math.log10(CONFIG.fD.min);
            const logMax = Math.log10(CONFIG.fD.max);
            return this.chartArea.y + this.chartArea.height - ((logF - logMin) / (logMax - logMin)) * this.chartArea.height;
        },

        xToRe(x) {
            const t = (x - this.chartArea.x) / this.chartArea.width;
            const logMin = Math.log10(CONFIG.Re.min);
            const logMax = Math.log10(CONFIG.Re.max);
            return Math.pow(10, logMin + t * (logMax - logMin));
        },

        yToF(y) {
            const t = (this.chartArea.y + this.chartArea.height - y) / this.chartArea.height;
            const logMin = Math.log10(CONFIG.fD.min);
            const logMax = Math.log10(CONFIG.fD.max);
            return Math.pow(10, logMin + t * (logMax - logMin));
        },

        inChartArea(x, y) {
            return x >= this.chartArea.x && x <= this.chartArea.x + this.chartArea.width &&
                   y >= this.chartArea.y && y <= this.chartArea.y + this.chartArea.height;
        },

        clamp(x, y) {
            return {
                x: Math.max(this.chartArea.x, Math.min(this.chartArea.x + this.chartArea.width, x)),
                y: Math.max(this.chartArea.y, Math.min(this.chartArea.y + this.chartArea.height, y))
            };
        }
    };

    // ========================================
    // APPLICATION STATE
    // ========================================
    const STATE = {
        mode: 'drag',
        // Default point: Re=1e5, ε/D=0.001 → f≈0.0222 (from Colebrook-White equation)
        point: { Re: 1e5, f: 0.0222 },
        relRoughness: 0.001,
        toggles: {
            roughCurves: true, curveLabels: true, laminar: true, smooth: true,
            transition: true, grid: true, guides: true, fullRough: false
        },
        isDragging: false,
        curveCache: null
    };

    // ========================================
    // RENDERER
    // ========================================
    const RENDERER = {
        ctx: null,
        canvas: null,
        dpr: 1,

        init(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            
            this.dpr = window.devicePixelRatio || 1;
            
            // Get size from parent container, not the canvas itself
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas dimensions based on container
            canvas.width = rect.width * this.dpr;
            canvas.height = rect.height * this.dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            this.ctx.scale(this.dpr, this.dpr);
            
            COORDS.init(canvas);
            this.generateCurveCache();
        },

        generateCurveCache() {
            STATE.curveCache = {
                laminar: this.computeLaminarCurve(),
                smooth: this.computeSmoothCurve(),
                rough: CONFIG.relRoughnessValues.map(rr => this.computeRoughCurve(rr)),
                fullRough: CONFIG.relRoughnessValues.map(rr => this.computeFullRoughLine(rr))
            };
        },

        computeLaminarCurve() {
            const points = [];
            const ReMax = Math.min(CONFIG.transition.ReMin, CONFIG.Re.max);
            for (let logRe = Math.log10(CONFIG.Re.min); logRe <= Math.log10(ReMax); logRe += 0.05) {
                const Re = Math.pow(10, logRe);
                const f = 64 / Re;
                if (f >= CONFIG.fD.min && f <= CONFIG.fD.max) points.push({ Re, f });
            }
            return points;
        },

        computeSmoothCurve() {
            const points = [];
            for (let logRe = Math.log10(CONFIG.transition.ReMax); logRe <= Math.log10(CONFIG.Re.max); logRe += 0.02) {
                const Re = Math.pow(10, logRe);
                const result = SOLVER.smoothPipe(Re);
                if (result.converged && result.f >= CONFIG.fD.min && result.f <= CONFIG.fD.max) {
                    points.push({ Re, f: result.f });
                }
            }
            return points;
        },

        computeRoughCurve(relRoughness) {
            const points = [];
            for (let logRe = Math.log10(CONFIG.transition.ReMax); logRe <= Math.log10(CONFIG.Re.max); logRe += 0.02) {
                const Re = Math.pow(10, logRe);
                const result = SOLVER.colebrook(Re, relRoughness);
                if (result.converged && result.f >= CONFIG.fD.min && result.f <= CONFIG.fD.max) {
                    points.push({ Re, f: result.f });
                }
            }
            return { relRoughness, points };
        },

        computeFullRoughLine(relRoughness) {
            const result = SOLVER.fullyRough(relRoughness);
            if (result.f && result.f >= CONFIG.fD.min && result.f <= CONFIG.fD.max) {
                return { relRoughness, f: result.f };
            }
            return null;
        },

        draw() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const w = this.canvas.width / this.dpr;
            const h = this.canvas.height / this.dpr;
            
            // Get computed colors
            const bgPrimary = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim();
            const bgCard = getComputedStyle(document.documentElement).getPropertyValue('--bg-card').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            
            ctx.fillStyle = bgCard;
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = bgPrimary;
            ctx.fillRect(ca.x, ca.y, ca.width, ca.height);
            
            if (STATE.toggles.transition) this.drawTransitionBand();
            if (STATE.toggles.grid) this.drawGrid();
            if (STATE.toggles.fullRough) this.drawFullRoughLines();
            if (STATE.toggles.laminar) this.drawLaminarLine();
            if (STATE.toggles.roughCurves) this.drawRoughCurves();
            if (STATE.toggles.smooth) this.drawSmoothCurve();
            
            this.drawAxes();
            
            if (STATE.toggles.guides) this.drawGuides();
            this.drawPoint();
            if (STATE.toggles.curveLabels && STATE.toggles.roughCurves) this.drawCurveLabels();
        },

        drawGrid() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            
            // Vertical (Re) gridlines
            for (let logRe = Math.ceil(Math.log10(CONFIG.Re.min)); logRe <= Math.floor(Math.log10(CONFIG.Re.max)); logRe++) {
                const x = COORDS.reToX(Math.pow(10, logRe));
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.moveTo(x, ca.y);
                ctx.lineTo(x, ca.y + ca.height);
                ctx.stroke();
                
                for (let i = 2; i <= 9; i++) {
                    const xMinor = COORDS.reToX(i * Math.pow(10, logRe));
                    if (xMinor > ca.x && xMinor < ca.x + ca.width) {
                        ctx.globalAlpha = 0.15;
                        ctx.beginPath();
                        ctx.moveTo(xMinor, ca.y);
                        ctx.lineTo(xMinor, ca.y + ca.height);
                        ctx.stroke();
                    }
                }
            }
            
            // Horizontal (f) gridlines
            const fTicks = [0.006, 0.007, 0.008, 0.009, 0.01, 0.015, 0.02, 0.025, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1];
            fTicks.forEach(f => {
                if (f >= CONFIG.fD.min && f <= CONFIG.fD.max) {
                    const y = COORDS.fToY(f);
                    const isMajor = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1].includes(f);
                    ctx.globalAlpha = isMajor ? 0.4 : 0.15;
                    ctx.beginPath();
                    ctx.moveTo(ca.x, y);
                    ctx.lineTo(ca.x + ca.width, y);
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1;
        },

        drawTransitionBand() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const x1 = COORDS.reToX(CONFIG.transition.ReMin);
            const x2 = COORDS.reToX(CONFIG.transition.ReMax);
            
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-transition').trim() || 'rgba(234, 179, 8, 0.15)';
            ctx.fillRect(x1, ca.y, x2 - x1, ca.height);
            
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-warning').trim();
            ctx.globalAlpha = 0.4;
            ctx.setLineDash([6, 4]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x1, ca.y);
            ctx.lineTo(x1, ca.y + ca.height);
            ctx.moveTo(x2, ca.y);
            ctx.lineTo(x2, ca.y + ca.height);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        },

        drawLaminarLine() {
            const ctx = this.ctx;
            const points = STATE.curveCache.laminar;
            if (points.length < 2) return;
            
            ctx.strokeStyle = CONFIG.colors.laminar;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(COORDS.reToX(points[0].Re), COORDS.fToY(points[0].f));
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(COORDS.reToX(points[i].Re), COORDS.fToY(points[i].f));
            }
            ctx.stroke();
        },

        drawSmoothCurve() {
            const ctx = this.ctx;
            const points = STATE.curveCache.smooth;
            if (points.length < 2) return;
            
            ctx.strokeStyle = CONFIG.colors.smooth;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(COORDS.reToX(points[0].Re), COORDS.fToY(points[0].f));
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(COORDS.reToX(points[i].Re), COORDS.fToY(points[i].f));
            }
            ctx.stroke();
        },

        drawRoughCurves() {
            const ctx = this.ctx;
            
            STATE.curveCache.rough.forEach((curve, idx) => {
                if (curve.points.length < 2) return;
                
                ctx.strokeStyle = CONFIG.colors.roughCurves[idx % CONFIG.colors.roughCurves.length];
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(COORDS.reToX(curve.points[0].Re), COORDS.fToY(curve.points[0].f));
                for (let i = 1; i < curve.points.length; i++) {
                    ctx.lineTo(COORDS.reToX(curve.points[i].Re), COORDS.fToY(curve.points[i].f));
                }
                ctx.stroke();
            });
        },

        drawFullRoughLines() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            
            ctx.setLineDash([4, 4]);
            ctx.globalAlpha = 0.5;
            
            STATE.curveCache.fullRough.forEach((line, idx) => {
                if (!line) return;
                const y = COORDS.fToY(line.f);
                ctx.strokeStyle = CONFIG.colors.roughCurves[idx % CONFIG.colors.roughCurves.length];
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ca.x + ca.width * 0.6, y);
                ctx.lineTo(ca.x + ca.width, y);
                ctx.stroke();
            });
            
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        },

        drawCurveLabels() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
            const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim();
            
            // Draw region labels on the chart
            this.drawRegionLabels();
            
            // Small labels at curve endpoints (now handled by right axis)
            // Keep only the smooth pipe label inline
            ctx.font = '10px JetBrains Mono, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
        },
        
        drawRegionLabels() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
            const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim();
            
            // Laminar flow label (on the laminar line)
            if (STATE.toggles.laminar) {
                ctx.save();
                const laminarX = COORDS.reToX(1100);
                const laminarY = COORDS.fToY(64 / 1300);
                ctx.translate(laminarX, laminarY +75);
                // ctx.rotate(-0.45);  // Angle to follow line
                ctx.font = 'bold 11px Space Grotesk, sans-serif';
                ctx.fillStyle = CONFIG.colors.laminar;
                ctx.textAlign = 'center';
                ctx.fillText('Laminar Flow', 0, 0);
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.fillStyle = mutedColor;
                ctx.fillText('f = 64/Re', 0, 15);
                ctx.restore();
            }
            
            // Transition region label
            if (STATE.toggles.transition) {
                const transX = (COORDS.reToX(CONFIG.transition.ReMin) + COORDS.reToX(CONFIG.transition.ReMax)) / 2;
                ctx.font = 'bold 10px Space Grotesk, sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-warning').trim();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('Transition', transX, ca.y + 10);
                ctx.font = '10px JetBrains Mono, monospace';
                ctx.fillStyle = mutedColor;
                ctx.fillText('(Critical Zone)', transX, ca.y + 24);
            }
            
            // Smooth turbulent curve label
            if (STATE.toggles.smooth && STATE.curveCache.smooth.length > 10) {
                ctx.save();
                const smoothIdx = Math.floor(STATE.curveCache.smooth.length * 0.4);
                const pt = STATE.curveCache.smooth[smoothIdx];
                const nextPt = STATE.curveCache.smooth[smoothIdx + 1];
                const angle = Math.atan2(
                    COORDS.fToY(nextPt.f) - COORDS.fToY(pt.f),
                    COORDS.reToX(nextPt.Re) - COORDS.reToX(pt.Re)
                );
                ctx.translate(COORDS.reToX(pt.Re), COORDS.fToY(pt.f) - 0);
                ctx.rotate(angle);
                ctx.font = 'bold 11px Space Grotesk, sans-serif';
                ctx.fillStyle = CONFIG.colors.smooth;
                ctx.textAlign = 'center';
                ctx.fillText('Smooth Turbulent', 0, 3);
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.fillStyle = mutedColor;
                ctx.fillText('(Prandtl-von Kármán)', 0, 14);
                ctx.restore();
            }
            
            // Wholly turbulent / Complete turbulence label (upper right area)
            if (STATE.toggles.roughCurves) {
                const labelX = COORDS.reToX(2e6);
                const labelY = COORDS.fToY(0.0675);
                ctx.font = 'bold 11px Space Grotesk, sans-serif';
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Complete Turbulence', labelX, labelY);
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.fillStyle = mutedColor;
                ctx.fillText('(Rough Pipe Zone)', labelX, labelY + 13);
                
                // Draw a small dashed line indicating the fully rough limit region
                if (STATE.toggles.fullRough) {
                    ctx.font = '8px JetBrains Mono, monospace';
                    ctx.fillStyle = mutedColor;
                    ctx.fillText('← f depends only on ε/D', labelX + 80, labelY + 26);
                }
            }
            
            // Colebrook-White equation annotation (in turbulent region)
            const eqX = COORDS.reToX(4e5);
            const eqY = COORDS.fToY(0.026);
            ctx.font = '8px JetBrains Mono, monospace';
            ctx.fillStyle = mutedColor;
            ctx.textAlign = 'center';
            ctx.fillText('Colebrook-White Equation', eqX, eqY);
        },

        drawAxes() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
            const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
            
            // Draw axis lines (left, bottom, and right)
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(ca.x, ca.y);
            ctx.lineTo(ca.x, ca.y + ca.height);
            ctx.lineTo(ca.x + ca.width, ca.y + ca.height);
            ctx.lineTo(ca.x + ca.width, ca.y);
            ctx.stroke();
            
            // X-axis labels (Reynolds Number)
            ctx.fillStyle = textColor;
            ctx.font = '11px JetBrains Mono, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            for (let logRe = Math.ceil(Math.log10(CONFIG.Re.min)); logRe <= Math.floor(Math.log10(CONFIG.Re.max)); logRe++) {
                const x = COORDS.reToX(Math.pow(10, logRe));
                ctx.fillText(`10${this.superscript(logRe)}`, x, ca.y + ca.height + 10);
            }
            
            // X-axis title with equation
            ctx.font = '12px Space Grotesk, sans-serif';
            ctx.fillStyle = primaryColor;
            ctx.fillText('Reynolds Number, Re = ρVD/μ', ca.x + ca.width / 2, ca.y + ca.height + 40);
            
            // Left Y-axis labels (Friction Factor)
            ctx.fillStyle = textColor;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '11px JetBrains Mono, monospace';
            
            [0.006, 0.008, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1].forEach(f => {
                if (f >= CONFIG.fD.min && f <= CONFIG.fD.max) {
                    const y = COORDS.fToY(f);
                    ctx.fillText(f.toFixed(3), ca.x - 12, y);
                }
            });
            
            // Left Y-axis title
            ctx.save();
            ctx.translate(20, ca.y + ca.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.font = '12px Space Grotesk, sans-serif';
            ctx.fillStyle = primaryColor;
            ctx.fillText('Darcy Friction Factor, f', 0, 0);
            ctx.restore();
            
            // Right Y-axis labels (Relative Roughness ε/D)
            this.drawRightAxisLabels();
        },
        
        drawRightAxisLabels() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
            const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
            
            // Only draw if roughness curves are shown
            if (!STATE.toggles.roughCurves) return;
            
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.font = '9px JetBrains Mono, monospace';
            ctx.fillStyle = textColor;
            
            // Draw ε/D labels on the right side, corresponding to the curve endpoints
            STATE.curveCache.rough.forEach((curve, idx) => {
                if (curve.points.length < 2) return;
                
                // Get the f value at the right edge of the chart
                const lastPt = curve.points[curve.points.length - 1];
                const y = COORDS.fToY(lastPt.f);
                
                // Format the label
                let label;
                if (curve.relRoughness >= 0.01) {
                    label = curve.relRoughness.toFixed(2);
                } else if (curve.relRoughness >= 0.001) {
                    label = curve.relRoughness.toFixed(3);
                } else if (curve.relRoughness >= 0.0001) {
                    label = curve.relRoughness.toFixed(4);
                } else {
                    label = curve.relRoughness.toExponential(0);
                }
                
                ctx.fillStyle = CONFIG.colors.roughCurves[idx % CONFIG.colors.roughCurves.length];
                ctx.fillText(label, ca.x + ca.width + 6, y);
            });
            
            // Smooth pipe label
            if (STATE.toggles.smooth && STATE.curveCache.smooth.length > 0) {
                const pt = STATE.curveCache.smooth[STATE.curveCache.smooth.length - 1];
                ctx.fillStyle = CONFIG.colors.smooth;
                ctx.fillText('0 (smooth)', ca.x + ca.width + 6, COORDS.fToY(pt.f));
            }
            
            // Right Y-axis title - position in the right margin
            ctx.save();
            const w = this.canvas.width / this.dpr;
            ctx.translate(w - 12, ca.y + ca.height / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.font = '11px Space Grotesk, sans-serif';
            ctx.fillStyle = primaryColor;
            ctx.fillText('Relative Roughness, ε/D', 0, 0);
            ctx.restore();
        },

        superscript(n) {
            const supers = '⁰¹²³⁴⁵⁶⁷⁸⁹';
            return String(n).split('').map(c => c === '-' ? '⁻' : supers[parseInt(c)]).join('');
        },

        drawGuides() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            
            // Clamp to chart bounds for display
            const clampedRe = Math.max(CONFIG.Re.min, Math.min(CONFIG.Re.max, STATE.point.Re));
            const clampedF = Math.max(CONFIG.fD.min, Math.min(CONFIG.fD.max, STATE.point.f));
            
            const px = COORDS.reToX(clampedRe);
            const py = COORDS.fToY(clampedF);
            
            // Check if out of range
            const outOfRange = STATE.point.Re < CONFIG.Re.min || STATE.point.Re > CONFIG.Re.max ||
                               STATE.point.f < CONFIG.fD.min || STATE.point.f > CONFIG.fD.max;
            
            ctx.strokeStyle = outOfRange ? 'rgba(239, 68, 68, 0.5)' : CONFIG.colors.guides;
            ctx.setLineDash([6, 4]);
            ctx.lineWidth = 1.5;
            
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px, ca.y + ca.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(ca.x, py);
            ctx.lineTo(px, py);
            ctx.stroke();
            
            ctx.setLineDash([]);
        },

        drawPoint() {
            const ctx = this.ctx;
            const ca = COORDS.chartArea;
            
            // Check if point is out of chart bounds
            const reOutOfRange = STATE.point.Re < CONFIG.Re.min || STATE.point.Re > CONFIG.Re.max;
            const fOutOfRange = STATE.point.f < CONFIG.fD.min || STATE.point.f > CONFIG.fD.max;
            const outOfRange = reOutOfRange || fOutOfRange;
            
            // Clamp the drawing position to chart area
            const clampedRe = Math.max(CONFIG.Re.min, Math.min(CONFIG.Re.max, STATE.point.Re));
            const clampedF = Math.max(CONFIG.fD.min, Math.min(CONFIG.fD.max, STATE.point.f));
            
            const px = COORDS.reToX(clampedRe);
            const py = COORDS.fToY(clampedF);
            
            // Draw outer glow
            ctx.beginPath();
            ctx.arc(px, py, 14, 0, Math.PI * 2);
            ctx.fillStyle = outOfRange ? 'rgba(239, 68, 68, 0.3)' : 'rgba(245, 158, 11, 0.2)';
            ctx.fill();
            
            // Draw main point
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, Math.PI * 2);
            ctx.fillStyle = outOfRange ? '#ef4444' : CONFIG.colors.point;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // If out of range, draw arrow indicating direction
            if (outOfRange) {
                ctx.save();
                ctx.strokeStyle = '#ef4444';
                ctx.fillStyle = '#ef4444';
                ctx.lineWidth = 2;
                
                // Draw warning indicator
                ctx.font = 'bold 10px JetBrains Mono, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('⚠', px, py - 14);
                
                // Draw arrows if clamped to edge
                if (STATE.point.Re > CONFIG.Re.max) {
                    // Arrow pointing right
                    ctx.beginPath();
                    ctx.moveTo(ca.x + ca.width - 5, py);
                    ctx.lineTo(ca.x + ca.width + 8, py);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ca.x + ca.width + 8, py);
                    ctx.lineTo(ca.x + ca.width + 2, py - 4);
                    ctx.lineTo(ca.x + ca.width + 2, py + 4);
                    ctx.fill();
                } else if (STATE.point.Re < CONFIG.Re.min) {
                    // Arrow pointing left
                    ctx.beginPath();
                    ctx.moveTo(ca.x + 5, py);
                    ctx.lineTo(ca.x - 8, py);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ca.x - 8, py);
                    ctx.lineTo(ca.x - 2, py - 4);
                    ctx.lineTo(ca.x - 2, py + 4);
                    ctx.fill();
                }
                
                if (STATE.point.f > CONFIG.fD.max) {
                    // Arrow pointing up
                    ctx.beginPath();
                    ctx.moveTo(px, ca.y + 5);
                    ctx.lineTo(px, ca.y - 8);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(px, ca.y - 8);
                    ctx.lineTo(px - 4, ca.y - 2);
                    ctx.lineTo(px + 4, ca.y - 2);
                    ctx.fill();
                } else if (STATE.point.f < CONFIG.fD.min) {
                    // Arrow pointing down
                    ctx.beginPath();
                    ctx.moveTo(px, ca.y + ca.height - 5);
                    ctx.lineTo(px, ca.y + ca.height + 8);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(px, ca.y + ca.height + 8);
                    ctx.lineTo(px - 4, ca.y + ca.height + 2);
                    ctx.lineTo(px + 4, ca.y + ca.height + 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
    };

    // ========================================
    // UI CONTROLLER
    // ========================================
    const UI = {
        lastCalcResult: null,
        
        init() {
            this.bindModeButtons();
            this.bindToggles();
            this.bindInputs();
            this.bindCanvas();
            this.bindModals();
            this.bindFoldable();
            this.updateDisplay();
        },

        bindFoldable() {
            const btn = document.getElementById('calcFoldableBtn');
            const content = document.getElementById('calcFoldableContent');
            
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                content.classList.toggle('active');
            });
            
            // Nested foldable for step-by-step
            const stepsBtn = document.getElementById('stepsBtn');
            const stepsContent = document.getElementById('stepsContent');
            
            stepsBtn.addEventListener('click', () => {
                stepsBtn.classList.toggle('active');
                stepsContent.classList.toggle('active');
            });
        },

        bindModeButtons() {
            document.querySelectorAll('.mode-toggle button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-toggle button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    STATE.mode = btn.dataset.mode;
                    this.updateModeUI();
                });
            });
        },

        updateModeUI() {
            const inputSection = document.getElementById('inputSection');
            const relRoughRow = document.getElementById('inputRelRoughRow');
            const frictionRow = document.getElementById('inputFrictionRow');
            
            if (STATE.mode === 'drag') {
                inputSection.style.display = 'none';
            } else {
                inputSection.style.display = 'block';
                if (STATE.mode === 'compute') {
                    relRoughRow.style.display = 'block';
                    frictionRow.style.display = 'none';
                } else {
                    relRoughRow.style.display = 'none';
                    frictionRow.style.display = 'block';
                }
            }
        },

        bindToggles() {
            const toggleMap = {
                'toggleRoughCurves': 'roughCurves',
                'toggleCurveLabels': 'curveLabels',
                'toggleLaminar': 'laminar',
                'toggleSmooth': 'smooth',
                'toggleTransition': 'transition',
                'toggleGrid': 'grid',
                'toggleGuides': 'guides',
                'toggleFullRough': 'fullRough'
            };
            
            Object.entries(toggleMap).forEach(([id, key]) => {
                const el = document.getElementById(id);
                el.checked = STATE.toggles[key];
                el.addEventListener('change', () => {
                    STATE.toggles[key] = el.checked;
                    RENDERER.draw();
                });
            });
        },

        bindInputs() {
            document.getElementById('computeBtn').addEventListener('click', () => this.handleCompute());
            document.getElementById('resetInputBtn').addEventListener('click', () => {
                document.getElementById('inputRe').value = '100000';
                document.getElementById('inputRelRough').value = '0.001';
                document.getElementById('inputFriction').value = '0.02';
            });
            
            ['inputRe', 'inputRelRough', 'inputFriction'].forEach(id => {
                document.getElementById(id).addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleCompute();
                });
            });
        },

        handleCompute() {
            const Re = parseFloat(document.getElementById('inputRe').value);
            
            // Validation helper
            const validateInputs = () => {
                const warnings = [];
                const errors = [];
                
                // Basic validation
                if (isNaN(Re) || Re <= 0) {
                    errors.push('Reynolds number must be a positive number.');
                    return { valid: false, errors, warnings };
                }
                
                // Range checks for Re
                if (Re < CONFIG.Re.min) {
                    warnings.push(`Re = ${Re.toExponential(2)} is below chart minimum (${CONFIG.Re.min}). Results extrapolated.`);
                }
                if (Re > CONFIG.Re.max) {
                    warnings.push(`Re = ${Re.toExponential(2)} exceeds chart maximum (${CONFIG.Re.max.toExponential(0)}). Results extrapolated.`);
                }
                
                return { valid: true, errors, warnings };
            };
            
            if (STATE.mode === 'compute') {
                const relRoughness = parseFloat(document.getElementById('inputRelRough').value);
                
                // Basic validation
                if (isNaN(relRoughness)) {
                    this.showValidationError('Relative roughness must be a number.');
                    return;
                }
                if (relRoughness < 0) {
                    this.showValidationError('Relative roughness (ε/D) cannot be negative.');
                    return;
                }
                
                const validation = validateInputs();
                if (!validation.valid) {
                    this.showValidationError(validation.errors.join('\n'));
                    return;
                }
                
                // Additional range checks for roughness
                if (relRoughness > 0.05) {
                    validation.warnings.push(`ε/D = ${relRoughness} exceeds typical maximum (0.05). Results may be unreliable.`);
                }
                
                // Compute the result
                const result = SOLVER.getFrictionFactor(Re, relRoughness);
                
                // Add range warnings to result
                if (validation.warnings.length > 0) {
                    result.warning = result.warning 
                        ? result.warning + ' ' + validation.warnings.join(' ')
                        : validation.warnings.join(' ');
                    result.outOfRange = true;
                }
                
                // Check if result f is outside chart bounds
                if (result.f < CONFIG.fD.min || result.f > CONFIG.fD.max) {
                    result.warning = (result.warning || '') + ` Computed f = ${result.f.toFixed(4)} is outside chart bounds (${CONFIG.fD.min}-${CONFIG.fD.max}).`;
                    result.outOfRange = true;
                }
                
                STATE.point.Re = Re;
                STATE.point.f = result.f;
                STATE.relRoughness = relRoughness;
                this.lastCalcResult = result;
                
            } else {
                // Infer mode
                const f = parseFloat(document.getElementById('inputFriction').value);
                
                // Basic validation
                if (isNaN(f)) {
                    this.showValidationError('Friction factor must be a number.');
                    return;
                }
                if (f <= 0) {
                    this.showValidationError('Friction factor must be positive.');
                    return;
                }
                
                const validation = validateInputs();
                if (!validation.valid) {
                    this.showValidationError(validation.errors.join('\n'));
                    return;
                }
                
                // Range checks for f
                if (f < CONFIG.fD.min) {
                    validation.warnings.push(`f = ${f.toFixed(4)} is below chart minimum (${CONFIG.fD.min}). Results may be unreliable.`);
                }
                if (f > CONFIG.fD.max) {
                    validation.warnings.push(`f = ${f.toFixed(4)} exceeds chart maximum (${CONFIG.fD.max}). Results may be unreliable.`);
                }
                
                // Physical sanity check: laminar f at given Re
                const laminarF = 64 / Re;
                if (Re < CONFIG.transition.ReMin && Math.abs(f - laminarF) / laminarF > 0.1) {
                    validation.warnings.push(`For laminar flow (Re < 2300), f should be ${laminarF.toFixed(4)} (= 64/Re). Your input differs significantly.`);
                }
                
                const result = SOLVER.inferRelRoughness(Re, f);
                
                // Add range warnings to result
                if (validation.warnings.length > 0) {
                    result.warning = result.warning 
                        ? result.warning + ' ' + validation.warnings.join(' ')
                        : validation.warnings.join(' ');
                    result.outOfRange = true;
                }
                
                STATE.point.Re = Re;
                STATE.point.f = f;
                STATE.relRoughness = result.relRoughness || 0;
                this.lastCalcResult = result;
            }
            
            RENDERER.draw();
            this.updateDisplay();
        },
        
        showValidationError(message) {
            // Create a styled alert instead of browser alert
            const existing = document.getElementById('validationAlert');
            if (existing) existing.remove();
            
            const alert = document.createElement('div');
            alert.id = 'validationAlert';
            alert.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--accent-error-dim, rgba(239, 68, 68, 0.15));
                border: 1px solid var(--accent-error, #ef4444);
                color: var(--accent-error, #ef4444);
                padding: 12px 20px;
                border-radius: 8px;
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.875rem;
                z-index: 10000;
                max-width: 400px;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            alert.textContent = message;
            document.body.appendChild(alert);
            
            setTimeout(() => alert.remove(), 4000);
        },

        bindCanvas() {
            const canvas = RENDERER.canvas;
            
            const handleStart = (e) => {
                if (STATE.mode !== 'drag') return;
                STATE.isDragging = true;
                this.handleCanvasMove(e.touches ? e.touches[0] : e);
            };
            
            const handleMove = (e) => {
                if (STATE.isDragging) {
                    this.handleCanvasMove(e.touches ? e.touches[0] : e);
                    e.preventDefault();
                }
            };
            
            const handleEnd = () => { STATE.isDragging = false; };
            
            // Mouse events
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', handleEnd);
            
            // Touch events with proper passive handling to allow preventDefault
            canvas.addEventListener('touchstart', handleStart, { passive: true });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd, { passive: true });
            canvas.addEventListener('touchcancel', handleEnd, { passive: true });
        },

        handleCanvasMove(e) {
            const rect = RENDERER.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (!COORDS.inChartArea(x, y)) return;
            
            const Re = COORDS.xToRe(x);
            const f = COORDS.yToF(y);
            
            // Clamp to chart bounds
            STATE.point.Re = Math.max(CONFIG.Re.min, Math.min(CONFIG.Re.max, Re));
            STATE.point.f = Math.max(CONFIG.fD.min, Math.min(CONFIG.fD.max, f));
            
            // Infer roughness from the dragged point
            const inference = SOLVER.inferRelRoughness(STATE.point.Re, STATE.point.f);
            STATE.relRoughness = Math.max(0, inference.relRoughness || 0);
            
            // Determine regime based on Re
            let regime, regimeLogic;
            if (STATE.point.Re < CONFIG.transition.ReMin) {
                regime = 'Laminar';
                regimeLogic = `Re (${STATE.point.Re.toFixed(0)}) < 2300 → Laminar`;
            } else if (STATE.point.Re <= CONFIG.transition.ReMax) {
                regime = 'Transitional';
                regimeLogic = `2300 ≤ Re (${STATE.point.Re.toFixed(0)}) ≤ 4000 → Transitional`;
            } else {
                regime = 'Turbulent';
                regimeLogic = `Re (${STATE.point.Re.toExponential(2)}) > 4000 → Turbulent`;
            }
            
            // Store result with the DRAGGED f value as authoritative
            // This fixes the inconsistency where displayed point didn't match calculation panel
            this.lastCalcResult = {
                f: STATE.point.f,  // Use dragged f, not recomputed
                regime,
                regimeLogic,
                method: 'Chart reading',
                equationName: 'Direct chart read',
                algorithm: 'User-selected point on Moody chart',
                converged: true,
                relRoughness: STATE.relRoughness,
                inferenceResult: inference,  // Include inference details
                warning: inference.warning || (inference.regimeWarning ? inference.warning : undefined)
            };
            
            // If in turbulent regime and inference was valid, also compute forward check
            if (regime === 'Turbulent' && !inference.regimeWarning && STATE.relRoughness > 0) {
                const forwardCheck = SOLVER.colebrook(STATE.point.Re, STATE.relRoughness);
                this.lastCalcResult.forwardCheck = forwardCheck;
                this.lastCalcResult.residual = Math.abs(forwardCheck.f - STATE.point.f);
            }
            
            RENDERER.draw();
            this.updateDisplay();
        },

        updateDisplay() {
            const Re = STATE.point.Re;
            const f = STATE.point.f;
            const result = this.lastCalcResult;
            
            // Check for out-of-range values
            const reOutOfRange = Re < CONFIG.Re.min || Re > CONFIG.Re.max;
            const fOutOfRange = f < CONFIG.fD.min || f > CONFIG.fD.max;
            const anyOutOfRange = reOutOfRange || fOutOfRange || (result && result.outOfRange);
            
            // Format Re display
            const reEl = document.getElementById('valRe');
            reEl.textContent = this.formatScientific(Re);
            reEl.style.color = reOutOfRange ? 'var(--accent-warning)' : '';
            
            // Format f display
            const fdEl = document.getElementById('valFd');
            fdEl.textContent = f.toFixed(4);
            fdEl.style.color = fOutOfRange ? 'var(--accent-warning)' : '';
            
            document.getElementById('valFf').textContent = (f / 4).toFixed(5);
            
            const rrText = STATE.relRoughness < 1e-6 ? '≈ 0 (smooth)' : STATE.relRoughness.toExponential(2);
            const rrEl = document.getElementById('valRelRough');
            rrEl.textContent = rrText;
            rrEl.style.color = STATE.relRoughness > 0.05 ? 'var(--accent-warning)' : '';
            
            let regime, method, statusClass = '', badgeClass = 'ok';
            
            if (Re < CONFIG.transition.ReMin) {
                regime = 'Laminar Flow';
                method = '64/Re';
            } else if (Re <= CONFIG.transition.ReMax) {
                regime = 'Transitional Flow';
                method = 'Interpolated';
                statusClass = 'warn';
                badgeClass = 'warn';
            } else {
                regime = 'Turbulent Flow';
                method = STATE.relRoughness < 1e-6 ? 'Prandtl' : 'Colebrook';
            }
            
            // Override status for out-of-range
            if (anyOutOfRange) {
                statusClass = 'warn';
                badgeClass = 'warn';
            }
            
            document.getElementById('regimeLabel').textContent = regime;
            document.getElementById('valMethod').textContent = method;
            document.getElementById('statusDot').className = 'status-dot ' + statusClass;
            
            const statusBadge = document.getElementById('statusBadge');
            statusBadge.className = 'status-badge ' + badgeClass;
            
            if (anyOutOfRange) {
                statusBadge.innerHTML = '⚠ Out of Range';
            } else {
                statusBadge.innerHTML = '● ' + regime.split(' ')[0];
            }
            
            // Update calculation details
            this.updateCalculationDetails();
        },

        updateCalculationDetails() {
            const Re = STATE.point.Re;
            const relRoughness = STATE.relRoughness;
            const result = this.lastCalcResult || SOLVER.getFrictionFactor(Re, relRoughness);
            
            // Input parameters
            document.getElementById('calcRe').textContent = Re >= 1e6 ? Re.toExponential(3) : Re.toLocaleString();
            document.getElementById('calcRelRough').textContent = relRoughness < 1e-6 ? '≈ 0 (smooth)' : relRoughness.toExponential(4);
            
            // Regime
            document.getElementById('calcRegime').textContent = result.regime || 'Unknown';
            document.getElementById('calcRegimeLogic').textContent = result.regimeLogic || `Re = ${Re.toExponential(2)}`;
            
            // Equation
            const eqContainer = document.getElementById('calcEquation');
            eqContainer.innerHTML = `
                <div class="eq-name">${result.equationName || result.method}</div>
                <div class="eq-formula">${result.equation || 'N/A'}</div>
            `;
            
            // Algorithm
            document.getElementById('calcAlgorithm').textContent = result.algorithm || 'N/A';
            document.getElementById('calcInitialGuess').textContent = result.initialGuess ? result.initialGuess.toFixed(6) : 'N/A';
            
            // Iteration log
            const iterContainer = document.getElementById('calcIterations');
            if (result.iterationLog && result.iterationLog.length > 0) {
                iterContainer.innerHTML = result.iterationLog.map((iter, idx) => {
                    const isLast = idx === result.iterationLog.length - 1;
                    const deltaStr = iter.delta !== null && iter.delta !== undefined ? 
                        `Δ = ${iter.delta.toExponential(2)}` : (iter.note || '');
                    return `
                        <div class="calc-iter-row${isLast ? ' last' : ''}">
                            <span class="calc-iter-num">${iter.i}.</span>
                            <span class="calc-iter-f">f = ${iter.f.toFixed(8)}</span>
                            <span class="calc-iter-delta">${deltaStr}</span>
                        </div>
                    `;
                }).join('');
            } else {
                iterContainer.innerHTML = '<div class="calc-iter-row">Direct calculation (no iteration)</div>';
            }
            
            // Final result
            document.getElementById('calcFinalF').textContent = result.f ? result.f.toFixed(6) : 'N/A';
            document.getElementById('calcFinalFanning').textContent = result.f ? (result.f / 4).toFixed(6) : 'N/A';
            document.getElementById('calcIterCount').textContent = result.iterations || 1;
            
            const convergedEl = document.getElementById('calcConverged');
            if (result.converged) {
                convergedEl.textContent = '✓ Yes';
                convergedEl.className = 'calc-value calc-success';
            } else {
                convergedEl.textContent = '✗ No';
                convergedEl.className = 'calc-value calc-warning';
            }
            
            // Warning
            const warningSection = document.getElementById('calcWarningSection');
            const warningEl = document.getElementById('calcWarning');
            if (result.warning) {
                warningSection.style.display = 'block';
                warningEl.textContent = result.warning;
            } else {
                warningSection.style.display = 'none';
            }
            
            // Verification
            if (result.verification) {
                document.getElementById('calcVerify').textContent = 
                    `LHS = ${result.verification.lhs.toFixed(6)}, RHS = ${result.verification.rhs.toFixed(6)} ✓`;
            } else {
                document.getElementById('calcVerify').textContent = 'N/A (direct calculation)';
            }
            document.getElementById('calcResidual').textContent = 
                result.residual !== undefined ? result.residual.toExponential(2) : 'N/A';
            
            // Generate step-by-step derivation
            this.generateStepByStep(Re, relRoughness, result);
        },

        generateStepByStep(Re, relRoughness, result) {
            const container = document.getElementById('equationSteps');
            let html = '';
            
            if (result.regime === 'Laminar' || result.method === 'Laminar (64/Re)') {
                html = this.generateLaminarSteps(Re, result);
            } else if (result.regime === 'Transitional') {
                html = this.generateTransitionSteps(Re, relRoughness, result);
            } else if (result.method === 'Prandtl (smooth)' || relRoughness < 1e-7) {
                html = this.generatePrandtlSteps(Re, result);
            } else if (result.method === 'Colebrook') {
                html = this.generateColebrookSteps(Re, relRoughness, result);
            } else {
                html = '<div class="step-note">No step-by-step available for this calculation method.</div>';
            }
            
            container.innerHTML = html;
        },

        generateLaminarSteps(Re, result) {
            const f = result.f;
            return `
                <div class="step-group">
                    <div class="step-group-title">1. Identify Flow Regime</div>
                    <div class="step-item">
                        <span class="step-num">1.1</span>
                        <div class="step-content">
                            <div class="step-desc">Check Reynolds number against critical value:</div>
                            <div class="step-math">Re = ${Re.toLocaleString()} < 2300 (critical)</div>
                            <div class="step-note">Flow is laminar when Re < 2300</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">2. Apply Hagen-Poiseuille Law</div>
                    <div class="step-item">
                        <span class="step-num">2.1</span>
                        <div class="step-content">
                            <div class="step-desc">For laminar flow in a circular pipe, the Darcy friction factor is:</div>
                            <div class="step-math">f = 64 / Re</div>
                            <div class="step-note">This is an exact analytical solution derived from the Navier-Stokes equations</div>
                        </div>
                    </div>
                    <div class="step-item highlight">
                        <span class="step-num">2.2</span>
                        <div class="step-content">
                            <div class="step-desc">Substitute the Reynolds number:</div>
                            <div class="step-math">f = 64 / ${Re.toLocaleString()}</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">3. Final Result</div>
                    <div class="step-item result">
                        <span class="step-num">3.1</span>
                        <div class="step-content">
                            <div class="step-desc">Calculate the friction factor:</div>
                            <div class="step-math">f = ${f.toFixed(6)}</div>
                            <div class="step-note">Note: In laminar flow, f is independent of surface roughness (ε/D)</div>
                        </div>
                    </div>
                </div>
            `;
        },

        generatePrandtlSteps(Re, result) {
            const f = result.f;
            const initialGuess = result.initialGuess;
            const iterations = result.iterationLog || [];
            
            let iterHtml = '';
            iterations.slice(0, 5).forEach((iter, idx) => {
                const isLast = idx === Math.min(iterations.length - 1, 4);
                iterHtml += `
                    <div class="step-item ${isLast ? 'result' : ''}">
                        <span class="step-num">${idx + 1}</span>
                        <div class="step-content">
                            <div class="step-math">f${idx > 0 ? '′' : '₀'} = ${iter.f.toFixed(8)}${iter.delta ? ` (Δ = ${iter.delta.toExponential(2)})` : ''}</div>
                        </div>
                    </div>
                `;
            });
            if (iterations.length > 5) {
                iterHtml += `<div class="step-note">... ${iterations.length - 5} more iterations</div>`;
            }
            
            return `
                <div class="step-group">
                    <div class="step-group-title">1. Identify Flow Regime & Equation</div>
                    <div class="step-item">
                        <span class="step-num">1.1</span>
                        <div class="step-content">
                            <div class="step-desc">For turbulent flow in hydraulically smooth pipes (ε/D ≈ 0), use Prandtl's equation:</div>
                            <div class="step-math">1/√f = 2·log₁₀(Re·√f) − 0.8</div>
                            <div class="step-note">Also known as the Prandtl-von Kármán equation for smooth pipes</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">2. Initial Guess (Blasius Approximation)</div>
                    <div class="step-item">
                        <span class="step-num">2.1</span>
                        <div class="step-content">
                            <div class="step-desc">For Re < 10⁵, use Blasius formula as initial guess:</div>
                            <div class="step-math">f₀ = 0.316 / Re^0.25 = 0.316 / ${Re.toExponential(2)}^0.25</div>
                        </div>
                    </div>
                    <div class="step-item highlight">
                        <span class="step-num">2.2</span>
                        <div class="step-content">
                            <div class="step-desc">Initial guess value:</div>
                            <div class="step-math">f₀ = ${initialGuess ? initialGuess.toFixed(6) : 'N/A'}</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">3. Newton-Raphson Iteration</div>
                    <div class="step-item">
                        <span class="step-num">3.1</span>
                        <div class="step-content">
                            <div class="step-desc">Define residual function G(f) and iterate until |G| < tolerance:</div>
                            <div class="step-math">G(f) = 1/√f − 2·log₁₀(Re·√f) + 0.8</div>
                            <div class="step-math">f_new = f − G(f) / G'(f)</div>
                        </div>
                    </div>
                    ${iterHtml}
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">4. Verification</div>
                    <div class="step-item result">
                        <span class="step-num">4.1</span>
                        <div class="step-content">
                            <div class="step-desc">Check that the equation is satisfied:</div>
                            <div class="step-math">LHS: 1/√${f.toFixed(6)} = ${(1/Math.sqrt(f)).toFixed(6)}</div>
                            <div class="step-math">RHS: 2·log₁₀(${Re}·√${f.toFixed(6)}) − 0.8 = ${(2*Math.log10(Re*Math.sqrt(f)) - 0.8).toFixed(6)}</div>
                            <div class="step-note">LHS ≈ RHS ✓ (converged to tolerance 10⁻¹⁰)</div>
                        </div>
                    </div>
                </div>
            `;
        },

        generateColebrookSteps(Re, relRoughness, result) {
            const f = result.f;
            const initialGuess = result.initialGuess;
            const iterations = result.iterationLog || [];
            
            // Calculate intermediate values for display
            const roughTerm = relRoughness / 3.7;
            const swameeJainTerm = relRoughness / 3.7 + 5.74 / Math.pow(Re, 0.9);
            
            let iterHtml = '';
            iterations.slice(0, 6).forEach((iter, idx) => {
                const sqrtF = Math.sqrt(iter.f);
                const viscousTerm = 2.51 / (Re * sqrtF);
                const isLast = idx === Math.min(iterations.length - 1, 5);
                iterHtml += `
                    <div class="step-item ${isLast ? 'result' : ''}">
                        <span class="step-num">${idx + 1}</span>
                        <div class="step-content">
                            <div class="step-math">√f = ${sqrtF.toFixed(6)} → ε/(3.7D) + 2.51/(Re·√f) = ${(roughTerm + viscousTerm).toExponential(4)}</div>
                            <div class="step-math"><span class="step-arrow">→</span> f = ${iter.f.toFixed(8)}${iter.delta ? ` (Δ = ${iter.delta.toExponential(2)})` : ''}</div>
                        </div>
                    </div>
                `;
            });
            if (iterations.length > 6) {
                iterHtml += `<div class="step-note">... ${iterations.length - 6} more iterations until convergence</div>`;
            }
            
            return `
                <div class="step-group">
                    <div class="step-group-title">1. Problem Setup</div>
                    <div class="step-item">
                        <span class="step-num">1.1</span>
                        <div class="step-content">
                            <div class="step-desc">Given parameters:</div>
                            <div class="step-math">Re = ${Re.toLocaleString()}</div>
                            <div class="step-math">ε/D = ${relRoughness.toExponential(4)}</div>
                        </div>
                    </div>
                    <div class="step-item">
                        <span class="step-num">1.2</span>
                        <div class="step-content">
                            <div class="step-desc">The Colebrook-White equation (implicit in f):</div>
                            <div class="step-math">1/√f = −2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))</div>
                            <div class="step-note">This equation bridges smooth and rough pipe behavior</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">2. Decompose the Equation Terms</div>
                    <div class="step-item">
                        <span class="step-num">2.1</span>
                        <div class="step-content">
                            <div class="step-desc">Roughness term (surface effect):</div>
                            <div class="step-math">ε/(3.7D) = ${relRoughness}/(3.7) = ${roughTerm.toExponential(4)}</div>
                            <div class="step-note">Dominates at high Re (fully rough turbulent flow)</div>
                        </div>
                    </div>
                    <div class="step-item">
                        <span class="step-num">2.2</span>
                        <div class="step-content">
                            <div class="step-desc">Viscous term (Reynolds number effect):</div>
                            <div class="step-math">2.51/(Re·√f) = 2.51/(${Re.toExponential(2)}·√f)</div>
                            <div class="step-note">Dominates at low Re (hydraulically smooth behavior)</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">3. Initial Guess (Swamee-Jain Explicit Approximation)</div>
                    <div class="step-item">
                        <span class="step-num">3.1</span>
                        <div class="step-content">
                            <div class="step-desc">Use Swamee-Jain formula for initial estimate:</div>
                            <div class="step-math">f₀ = 0.25 / [log₁₀(ε/(3.7D) + 5.74/Re^0.9)]²</div>
                        </div>
                    </div>
                    <div class="step-item highlight">
                        <span class="step-num">3.2</span>
                        <div class="step-content">
                            <div class="step-desc">Calculate the argument:</div>
                            <div class="step-math">${roughTerm.toExponential(4)} + 5.74/${Re.toExponential(2)}^0.9 = ${swameeJainTerm.toExponential(4)}</div>
                            <div class="step-math">f₀ = 0.25 / [log₁₀(${swameeJainTerm.toExponential(4)})]² = ${initialGuess ? initialGuess.toFixed(6) : 'N/A'}</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">4. Fixed-Point Iteration</div>
                    <div class="step-item">
                        <span class="step-num">4.1</span>
                        <div class="step-content">
                            <div class="step-desc">Rearrange Colebrook equation for iteration:</div>
                            <div class="step-math">f_{n+1} = 1 / [−2·log₁₀(ε/(3.7D) + 2.51/(Re·√f_n))]²</div>
                            <div class="step-note">Iterate until |f_{n+1} − f_n|/f_n < 10⁻¹⁰</div>
                        </div>
                    </div>
                    ${iterHtml}
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">5. Verification (Back-Substitution)</div>
                    <div class="step-item result">
                        <span class="step-num">5.1</span>
                        <div class="step-content">
                            <div class="step-desc">Verify the final answer satisfies the Colebrook equation:</div>
                            <div class="step-math">LHS: 1/√f = 1/√${f.toFixed(6)} = ${(1/Math.sqrt(f)).toFixed(6)}</div>
                            <div class="step-math">RHS: −2·log₁₀(${roughTerm.toExponential(4)} + ${(2.51/(Re*Math.sqrt(f))).toExponential(4)}) = ${(-2*Math.log10(roughTerm + 2.51/(Re*Math.sqrt(f)))).toFixed(6)}</div>
                            <div class="step-note">|LHS − RHS| = ${result.residual ? result.residual.toExponential(2) : '< 10⁻¹⁰'} ✓</div>
                        </div>
                    </div>
                </div>
            `;
        },

        generateTransitionSteps(Re, relRoughness, result) {
            const f = result.f;
            const details = result.details || {};
            // Use new property names from updated getFrictionFactor
            const fLamCurrent = details.fLamCurrent || 64 / Re;
            const fTurbCurrent = details.fTurbCurrent || SOLVER.colebrook(Re, relRoughness).f;
            const fLamBoundary = details.fLamBoundary || 64 / 2300;
            const fTurbBoundary = details.fTurbBoundary || SOLVER.colebrook(4000, relRoughness).f;
            const t = details.t || (Math.log10(Re) - Math.log10(2300)) / (Math.log10(4000) - Math.log10(2300));
            
            return `
                <div class="step-group">
                    <div class="step-group-title">⚠️ Transition Region Warning</div>
                    <div class="step-item" style="border-left-color: var(--accent-warning);">
                        <span class="step-num">!</span>
                        <div class="step-content">
                            <div class="step-desc">The transition region (2300 < Re < 4000) is inherently unstable:</div>
                            <div class="step-note">• Flow alternates unpredictably between laminar and turbulent</div>
                            <div class="step-note">• Neither Hagen-Poiseuille nor Colebrook equations are valid here</div>
                            <div class="step-note">• Friction factor typically <strong>increases</strong> as turbulence develops</div>
                            <div class="step-note">• Values shown are <strong>approximate interpolations only</strong></div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">1. Boundary Continuity Check</div>
                    <div class="step-item">
                        <span class="step-num">1.1</span>
                        <div class="step-content">
                            <div class="step-desc">At Re = 2300 (laminar boundary):</div>
                            <div class="step-math">f_laminar(2300) = 64/2300 = ${fLamBoundary.toFixed(6)}</div>
                        </div>
                    </div>
                    <div class="step-item">
                        <span class="step-num">1.2</span>
                        <div class="step-content">
                            <div class="step-desc">At Re = 4000 (turbulent boundary, using Colebrook):</div>
                            <div class="step-math">f_turbulent(4000) = ${fTurbBoundary.toFixed(6)}</div>
                            <div class="step-note">Note: f_turb > f_lam — this is why f increases through transition</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">2. Values at Current Re = ${Re}</div>
                    <div class="step-item">
                        <span class="step-num">2.1</span>
                        <div class="step-content">
                            <div class="step-desc">Hypothetical laminar friction factor:</div>
                            <div class="step-math">f_laminar(${Re}) = 64/${Re} = ${fLamCurrent.toFixed(6)}</div>
                        </div>
                    </div>
                    <div class="step-item">
                        <span class="step-num">2.2</span>
                        <div class="step-content">
                            <div class="step-desc">Hypothetical turbulent friction factor (Colebrook):</div>
                            <div class="step-math">f_turbulent(${Re}) = ${fTurbCurrent.toFixed(6)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">3. Log-Linear Interpolation</div>
                    <div class="step-item">
                        <span class="step-num">3.1</span>
                        <div class="step-content">
                            <div class="step-desc">Calculate interpolation parameter t:</div>
                            <div class="step-math">t = (log₁₀(Re) − log₁₀(2300)) / (log₁₀(4000) − log₁₀(2300))</div>
                            <div class="step-math">t = (${Math.log10(Re).toFixed(4)} − ${Math.log10(2300).toFixed(4)}) / (${Math.log10(4000).toFixed(4)} − ${Math.log10(2300).toFixed(4)})</div>
                            <div class="step-math">t = ${t.toFixed(4)}</div>
                            <div class="step-note">t=0 at Re=2300 (fully laminar), t=1 at Re=4000 (fully turbulent)</div>
                        </div>
                    </div>
                    <div class="step-item highlight">
                        <span class="step-num">3.2</span>
                        <div class="step-content">
                            <div class="step-desc">Blend laminar and turbulent values at current Re:</div>
                            <div class="step-math">log₁₀(f) = log₁₀(f_lam(Re))·(1−t) + log₁₀(f_turb(Re))·t</div>
                            <div class="step-math">log₁₀(f) = ${Math.log10(fLamCurrent).toFixed(4)}·${(1-t).toFixed(4)} + ${Math.log10(fTurbCurrent).toFixed(4)}·${t.toFixed(4)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="step-group">
                    <div class="step-group-title">4. Result (Approximate)</div>
                    <div class="step-item result">
                        <span class="step-num">4.1</span>
                        <div class="step-content">
                            <div class="step-desc">Convert back from log space:</div>
                            <div class="step-math">f ≈ ${f.toFixed(6)}</div>
                            <div class="step-note">⚠️ This is an approximation — actual values may vary significantly due to flow instability</div>
                        </div>
                    </div>
                </div>
            `;
        },

        formatScientific(n) {
            if (n >= 1e6) {
                const exp = Math.floor(Math.log10(n));
                const mantissa = n / Math.pow(10, exp);
                return mantissa.toFixed(2) + '×10' + RENDERER.superscript(exp);
            } else if (n >= 1000) {
                return n.toLocaleString('en-US', { maximumFractionDigits: 0 });
            }
            return n.toFixed(1);
        },

        bindModals() {
            const overlay = document.getElementById('modalOverlay');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            const content = {
                directions: {
                    title: 'How to Use This Tool',
                    html: `
                        <h3>Getting Started</h3>
                        <p>The Moody Chart is used in fluid mechanics to find the <strong>friction factor</strong> for pipe flow, which is essential for calculating pressure drops in piping systems using the Darcy-Weisbach equation.</p>
                        
                        <h3>Three Interaction Modes</h3>
                        <table>
                            <tr><th>Mode</th><th>What You Have</th><th>What You Find</th></tr>
                            <tr><td><strong>Drag to Read</strong></td><td>Visual inspection</td><td>Read f directly from chart position</td></tr>
                            <tr><td><strong>Compute f</strong></td><td>Re and ε/D</td><td>Calculate friction factor f</td></tr>
                            <tr><td><strong>Infer ε/D</strong></td><td>Re and f</td><td>Back-calculate relative roughness</td></tr>
                        </table>
                        
                        <h3>Reading the Chart</h3>
                        <ol>
                            <li><strong>Calculate Reynolds number</strong> from your flow conditions: Re = ρVD/μ</li>
                            <li><strong>Find ε/D</strong> from pipe material tables and your pipe diameter</li>
                            <li><strong>Locate the intersection</strong> of your Re (x-axis) with your ε/D curve</li>
                            <li><strong>Read f</strong> from the left y-axis at that intersection</li>
                        </ol>
                        
                        <h3>Chart Overlays Explained</h3>
                        <ul>
                            <li><strong>ε/D curves:</strong> Lines of constant relative roughness — each curve represents a specific pipe surface condition</li>
                            <li><strong>Laminar:</strong> The straight diagonal line where f = 64/Re (valid only for Re < 2300)</li>
                            <li><strong>Smooth:</strong> The lower bound of turbulent flow — theoretical limit for perfectly smooth pipes</li>
                            <li><strong>Transition:</strong> Yellow shaded unstable region where flow alternates between laminar and turbulent</li>
                            <li><strong>Full rough:</strong> Horizontal asymptotes where f becomes independent of Re (very high turbulence)</li>
                        </ul>
                        
                        <h3>Tips for Accurate Readings</h3>
                        <ul>
                            <li>Use <strong>Compute f</strong> mode for precise numerical answers</li>
                            <li>The <strong>Calculation Details</strong> panel shows exactly which equation was used and how</li>
                            <li>Always verify you're in the correct flow regime (laminar, transition, or turbulent)</li>
                        </ul>
                    `
                },
                details: {
                    title: 'Equations & Technical Details',
                    html: `
                        <h3>Variable Definitions</h3>
                        <table>
                            <tr><th>Symbol</th><th>Name</th><th>Physical Meaning</th><th>Units</th></tr>
                            <tr><td><strong>f</strong> or <strong>f<sub>D</sub></strong></td><td>Darcy friction factor</td><td>Dimensionless measure of flow resistance due to pipe friction</td><td>—</td></tr>
                            <tr><td><strong>Re</strong></td><td>Reynolds number</td><td>Ratio of inertial to viscous forces; determines flow regime</td><td>—</td></tr>
                            <tr><td><strong>ε</strong> (epsilon)</td><td>Absolute roughness</td><td>Average height of surface irregularities on pipe wall</td><td>mm, m</td></tr>
                            <tr><td><strong>D</strong></td><td>Pipe diameter</td><td>Internal diameter of the circular pipe</td><td>mm, m</td></tr>
                            <tr><td><strong>ε/D</strong></td><td>Relative roughness</td><td>Roughness height compared to pipe size; determines which curve to use</td><td>—</td></tr>
                            <tr><td><strong>ρ</strong> (rho)</td><td>Fluid density</td><td>Mass per unit volume of the flowing fluid</td><td>kg/m³</td></tr>
                            <tr><td><strong>V</strong></td><td>Average velocity</td><td>Mean flow velocity across the pipe cross-section</td><td>m/s</td></tr>
                            <tr><td><strong>μ</strong> (mu)</td><td>Dynamic viscosity</td><td>Fluid's resistance to shearing motion</td><td>Pa·s</td></tr>
                        </table>
                        
                        <h3>Reynolds Number</h3>
                        <div class="equation">Re = ρVD/μ = VD/ν</div>
                        <p>The Reynolds number determines the flow regime:</p>
                        <ul>
                            <li><strong>Re < 2300:</strong> Laminar flow — smooth, orderly layers</li>
                            <li><strong>2300 < Re < 4000:</strong> Transition — unstable, intermittent</li>
                            <li><strong>Re > 4000:</strong> Turbulent — chaotic, mixing motion</li>
                        </ul>
                        
                        <h3>Governing Equations by Region</h3>
                        
                        <p><strong>Laminar Flow (Re < 2300) — Hagen-Poiseuille:</strong></p>
                        <div class="equation">f = 64 / Re</div>
                        <p>Exact analytical solution. Roughness has no effect in laminar flow.</p>
                        
                        <p><strong>Turbulent Flow — Colebrook-White (1939):</strong></p>
                        <div class="equation">1/√f = −2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))</div>
                        <p>Implicit equation requiring iteration. Valid for all turbulent conditions.</p>
                        
                        <p><strong>Smooth Pipe Limit — Prandtl-von Kármán:</strong></p>
                        <div class="equation">1/√f = 2·log₁₀(Re·√f) − 0.8</div>
                        <p>As ε/D → 0, Colebrook reduces to this form.</p>
                        
                        <p><strong>Fully Rough Limit — von Kármán:</strong></p>
                        <div class="equation">1/√f = −2·log₁₀(ε/(3.7D)) = 1.14 − 2·log₁₀(ε/D)</div>
                        <p>At very high Re, f becomes independent of Re (horizontal asymptotes).</p>
                        
                        <h3>Using f: The Darcy-Weisbach Equation</h3>
                        <div class="equation">ΔP = f · (L/D) · (ρV²/2)  or  h<sub>f</sub> = f · (L/D) · (V²/2g)</div>
                        <p>Where ΔP is pressure drop, h<sub>f</sub> is head loss, L is pipe length, and g is gravity.</p>
                        
                        <h3>Darcy vs Fanning Friction Factor</h3>
                        <div class="warning-box">
                            <strong>⚠️ Critical Warning:</strong> This tool uses the <strong>Darcy-Weisbach</strong> friction factor (f<sub>D</sub>). Chemical engineering texts often use the <strong>Fanning</strong> friction factor: <strong>f<sub>F</sub> = f<sub>D</sub>/4</strong>. Always check which convention your reference uses!
                        </div>
                        
                        <h3>Accuracy</h3>
                        <p>Moody (1944) stated typical accuracy: <strong>±5%</strong> for smooth pipes, <strong>±10%</strong> for rough pipes. Real pipes may deviate due to aging, deposits, or non-uniform roughness.</p>
                        
                        <p style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 0.85rem; color: var(--text-secondary);">
                            <strong>For verification:</strong> See <strong>Tech Ref</strong> for exact constants, numerical tolerances, and source citations suitable for independent validation.
                        </p>
                    `
                },
                assumptions: {
                    title: 'Assumptions & Limitations',
                    html: `
                        <h3>When Is This Chart Valid?</h3>
                        <p>The Moody Chart and Colebrook-White equation are based on specific assumptions. Understanding these helps you know when the results are reliable.</p>
                        
                        <h3>Physical Assumptions</h3>
                        <table>
                            <tr><th>Assumption</th><th>What It Means Physically</th><th>What Happens If Violated</th></tr>
                            <tr>
                                <td><strong>Fully developed flow</strong></td>
                                <td>Velocity profile is stable, not changing along pipe length. Requires 10-50 diameters of straight pipe after any disturbance.</td>
                                <td>Entrance effects increase friction; use entrance loss coefficients</td>
                            </tr>
                            <tr>
                                <td><strong>Incompressible flow</strong></td>
                                <td>Fluid density is constant (Mach < 0.3 for gases). Valid for all liquids and low-speed gases.</td>
                                <td>Compressible flow equations needed for high-speed gas flow</td>
                            </tr>
                            <tr>
                                <td><strong>Steady-state flow</strong></td>
                                <td>Flow rate is constant in time; no starting/stopping transients.</td>
                                <td>Unsteady friction factors are different; water hammer effects</td>
                            </tr>
                            <tr>
                                <td><strong>Newtonian fluid</strong></td>
                                <td>Viscosity is constant regardless of shear rate. Water, air, oils are Newtonian.</td>
                                <td>Non-Newtonian fluids (polymers, blood, slurries) need modified correlations</td>
                            </tr>
                            <tr>
                                <td><strong>Circular cross-section</strong></td>
                                <td>Pipe is round. For non-circular ducts, use hydraulic diameter: D<sub>h</sub> = 4A/P</td>
                                <td>Results are approximate for non-circular sections</td>
                            </tr>
                            <tr>
                                <td><strong>Uniform sand-grain roughness</strong></td>
                                <td>Surface roughness is modeled as equivalent sand grains (Nikuradse's experiments).</td>
                                <td>Real roughness (riveted steel, corrugated pipe) may behave differently</td>
                            </tr>
                            <tr>
                                <td><strong>Isothermal flow</strong></td>
                                <td>Temperature is uniform; no significant heating/cooling of fluid.</td>
                                <td>Large temperature gradients change viscosity and affect Re</td>
                            </tr>
                            <tr>
                                <td><strong>No suspended particles</strong></td>
                                <td>Clean fluid with no significant solids content.</td>
                                <td>Slurry flows have different friction characteristics</td>
                            </tr>
                        </table>
                        
                        <h3>The Transition Region Problem</h3>
                        <div class="warning-box">
                            <strong>⚠️ Transition Region (2300 < Re < 4000):</strong>
                            <ul>
                                <li>Flow is <strong>inherently unstable</strong> — alternates unpredictably between laminar and turbulent</li>
                                <li>Neither the laminar equation (f = 64/Re) nor Colebrook equation is valid here</li>
                                <li>Small disturbances (vibration, surface imperfections) can trigger transition at different Re values</li>
                                <li>Values shown in this tool are <strong>interpolated approximations only</strong></li>
                                <li><strong>Design practice:</strong> Avoid operating in transition; design for clearly laminar or clearly turbulent flow</li>
                            </ul>
                        </div>
                        
                        <h3>What ε (Roughness) Actually Represents</h3>
                        <p>The roughness value ε is an <strong>equivalent sand-grain roughness</strong> — the size of uniform sand grains that would produce the same friction factor. Real pipe surfaces have irregular roughness, so ε is determined experimentally, not by direct measurement.</p>
                        
                        <h3>Roughness Changes Over Time</h3>
                        <p>Pipe roughness can change significantly:</p>
                        <ul>
                            <li><strong>Corrosion</strong> increases roughness in steel pipes</li>
                            <li><strong>Biological growth</strong> (biofilm) increases roughness in water systems</li>
                            <li><strong>Scale deposits</strong> from hard water increase roughness</li>
                            <li><strong>Erosion</strong> can smooth or roughen depending on conditions</li>
                        </ul>
                        <p>Engineering practice often applies safety factors of 1.5-2× to account for aging.</p>
                    `
                },
                about: {
                    title: 'About This Tool',
                    html: `
                        <h3>Purpose</h3>
                        <p>This interactive Moody Chart is an educational tool for understanding friction factor relationships in internal pipe flow. It is designed for engineering students, educators, and practitioners who need to:</p>
                        <ul>
                            <li>Visualize how friction factor depends on Reynolds number and roughness</li>
                            <li>Understand the different flow regimes and their governing equations</li>
                            <li>Calculate accurate friction factors without interpolating paper charts</li>
                            <li>Learn the iterative solution process for the Colebrook equation</li>
                        </ul>
                        
                        <h3>Historical Context</h3>
                        <p>The Moody diagram was published by <strong>Lewis Ferry Moody</strong> in 1944, synthesizing decades of pipe flow research:</p>
                        <ul>
                            <li><strong>1883:</strong> Osborne Reynolds discovers the transition from laminar to turbulent flow</li>
                            <li><strong>1904:</strong> Ludwig Prandtl develops boundary layer theory</li>
                            <li><strong>1933:</strong> Johann Nikuradse performs sand-roughened pipe experiments</li>
                            <li><strong>1937-39:</strong> Cyril Colebrook develops his universal friction equation</li>
                            <li><strong>1944:</strong> Lewis Moody creates the standard graphical chart</li>
                        </ul>
                        
                        <h3>Primary References</h3>
                        <ol>
                            <li><strong>Moody, L.F.</strong> (1944). "Friction Factors for Pipe Flow." <em>Transactions of the ASME</em>, 66(8), 671-684. — The original Moody diagram paper</li>
                            <li><strong>Colebrook, C.F.</strong> (1939). "Turbulent Flow in Pipes, with Particular Reference to the Transition Region between the Smooth and Rough Pipe Laws." <em>Journal of the Institution of Civil Engineers</em>, 11(4), 133-156.</li>
                            <li><strong>Colebrook, C.F. & White, C.M.</strong> (1937). "Experiments with Fluid Friction in Roughened Pipes." <em>Proceedings of the Royal Society A</em>, 161(906), 367-381.</li>
                        </ol>
                        
                        <h3>Recommended Textbooks</h3>
                        <ul>
                            <li><strong>White, F.M.</strong> <em>Fluid Mechanics</em>, 8th ed., McGraw-Hill, 2016. — Chapter 6</li>
                            <li><strong>Munson, Young, Okiishi & Huebsch.</strong> <em>Fundamentals of Fluid Mechanics</em>, 7th ed., Wiley, 2013. — Chapter 8</li>
                            <li><strong>Fox, McDonald & Pritchard.</strong> <em>Introduction to Fluid Mechanics</em>, 9th ed., Wiley, 2015. — Chapter 8</li>
                        </ul>
                        
                        <h3>Typical Roughness Values (ε)</h3>
                        <table>
                            <tr><th>Pipe Material</th><th>ε (mm)</th><th>ε (ft)</th><th>Condition</th></tr>
                            <tr><td>Drawn tubing (brass, copper, glass)</td><td>0.0015</td><td>5×10⁻⁶</td><td>Very smooth</td></tr>
                            <tr><td>PVC, plastic pipe</td><td>0.0015-0.007</td><td>5-23×10⁻⁶</td><td>Smooth</td></tr>
                            <tr><td>Commercial steel, wrought iron</td><td>0.046</td><td>1.5×10⁻⁴</td><td>New</td></tr>
                            <tr><td>Asphalted cast iron</td><td>0.12</td><td>4×10⁻⁴</td><td>Coated</td></tr>
                            <tr><td>Galvanized iron</td><td>0.15</td><td>5×10⁻⁴</td><td>Standard</td></tr>
                            <tr><td>Cast iron</td><td>0.26</td><td>8.5×10⁻⁴</td><td>New</td></tr>
                            <tr><td>Concrete</td><td>0.3-3.0</td><td>1-10×10⁻³</td><td>Varies with finish</td></tr>
                            <tr><td>Riveted steel</td><td>0.9-9.0</td><td>3-30×10⁻³</td><td>Varies with rivet pattern</td></tr>
                            <tr><td>Corrugated metal</td><td>45</td><td>0.15</td><td>Standard corrugations</td></tr>
                        </table>
                        
                        <h3>Example: Calculating ε/D</h3>
                        <p>For a 100mm (0.1m) commercial steel pipe:</p>
                        <div class="equation">ε/D = 0.046 mm / 100 mm = 0.00046</div>
                        <p>Use the ε/D = 0.0004 or ε/D = 0.0006 curve on the chart.</p>
                        
                        <h3>Technical Implementation</h3>
                        <ul>
                            <li>100% client-side JavaScript — no server, no dependencies</li>
                            <li>Curves computed from governing equations (not digitized from image)</li>
                            <li>Colebrook equation solved by fixed-point iteration (tolerance: 10⁻¹⁰)</li>
                            <li>Swamee-Jain explicit approximation used for initial guess</li>
                            <li>Full calculation traceability shown in Calculation Details panel</li>
                        </ul>
                        <p style="font-size: 0.85rem; color: var(--text-secondary);">
                            See <strong>Tech Ref</strong> for complete equation specifications, constant sources, numerical method details, and verification procedures.
                        </p>
                        
                        <h3>Version & License</h3>
                        <p>Version 2.0 • MIT License • Educational use encouraged</p>
                    `
                },
                techref: {
                    title: 'Technical Reference — Implementation Specification',
                    html: `
                        <p style="background: var(--accent-info-dim); padding: 12px; border-radius: 8px; border-left: 3px solid var(--accent-info);">
                            <strong>Purpose:</strong> This section documents the exact equations, constants, numerical methods, and sources used in this implementation. It is intended for verification by engineers and researchers who need to validate outputs against their own references.
                        </p>
                        
                        <h3>1. Equation Formulations & Constants</h3>
                        
                        <h4>1.1 Laminar Flow — Hagen-Poiseuille Equation</h4>
                        <div class="equation">f = 64 / Re</div>
                        <table>
                            <tr><th>Constant</th><th>Value</th><th>Source</th><th>Notes</th></tr>
                            <tr><td>Coefficient</td><td>64</td><td>Exact analytical derivation</td><td>Derived from Navier-Stokes for fully-developed laminar pipe flow. Exact, not empirical.</td></tr>
                        </table>
                        <p><strong>Valid range:</strong> Re < 2300 (critical Reynolds number)</p>
                        <p><strong>Implementation:</strong> Direct calculation, no iteration required.</p>
                        
                        <h4>1.2 Turbulent Flow — Colebrook-White Equation (1939)</h4>
                        <div class="equation">1/√f = −2.0 · log₁₀( ε/(3.7·D) + 2.51/(Re·√f) )</div>
                        <table>
                            <tr><th>Constant</th><th>Value Used</th><th>Source</th><th>Alternative Values</th></tr>
                            <tr><td>Leading coefficient</td><td>−2.0</td><td>Colebrook (1939), Eq. 4</td><td>Some sources use −2.0 exactly; others −1.99 to −2.03</td></tr>
                            <tr><td>Roughness divisor</td><td>3.7</td><td>Colebrook (1939)</td><td>Equivalent to 1/(2.718...) in some formulations using ln</td></tr>
                            <tr><td>Reynolds term coefficient</td><td>2.51</td><td>Colebrook (1939)</td><td>Some references use 2.51 or 2.52; derived from smooth-pipe limit</td></tr>
                        </table>
                        <p><strong>Valid range:</strong> Re > 4000, 0 ≤ ε/D ≤ 0.05</p>
                        <p><strong>Implementation:</strong> Fixed-point iteration (successive substitution). See Section 2 for numerical method details.</p>
                        <p><strong>Primary reference:</strong> Colebrook, C.F. (1939). "Turbulent Flow in Pipes, with Particular Reference to the Transition Region Between the Smooth and Rough Pipe Laws." <em>J. Inst. Civil Engineers</em>, 11(4), 133–156.</p>
                        
                        <h4>1.3 Smooth Pipe Limit — Prandtl-von Kármán Equation</h4>
                        <div class="equation">1/√f = 2.0 · log₁₀(Re·√f) − 0.8</div>
                        <table>
                            <tr><th>Constant</th><th>Value Used</th><th>Source</th><th>Alternative Values</th></tr>
                            <tr><td>Leading coefficient</td><td>2.0</td><td>Classical Prandtl-Nikuradse</td><td>Zagarola & Smits (1998) propose 1.930; Wikipedia cites 1.930</td></tr>
                            <tr><td>Subtracted constant</td><td>0.8</td><td>Classical Prandtl-Nikuradse</td><td>Zagarola & Smits propose 0.537; these are phenomenological fits</td></tr>
                        </table>
                        <p><strong>Note on alternative constants:</strong> The values 2.0 and 0.8 are the classical Prandtl-Nikuradse-Kármán (PNK) values widely used in textbooks and consistent with Colebrook's formulation. More recent high-Reynolds-number experiments (Zagarola & Smits, 1998) suggest 1.930 and 0.537 provide a marginally better fit, especially for Re > 10⁶. This implementation uses the classical values for consistency with the Colebrook equation and standard Moody chart.</p>
                        <p><strong>Implementation:</strong> Newton-Raphson iteration. This equation is the limit of Colebrook as ε/D → 0.</p>
                        
                        <h4>1.4 Fully Rough Limit — von Kármán Equation</h4>
                        <div class="equation">1/√f = −2.0 · log₁₀( ε/(3.7·D) )  =  1.14 − 2.0 · log₁₀(ε/D)</div>
                        <table>
                            <tr><th>Constant</th><th>Value</th><th>Derivation</th></tr>
                            <tr><td>1.14</td><td>= −2·log₁₀(1/3.7) = 2·log₁₀(3.7)</td><td>Algebraic rearrangement</td></tr>
                        </table>
                        <p><strong>Physical meaning:</strong> At very high Re, the viscous sublayer becomes negligible compared to roughness elements, and f becomes independent of Re.</p>
                        <p><strong>Implementation:</strong> Direct calculation (explicit formula).</p>
                        
                        <h4>1.5 Initial Guess — Swamee-Jain Approximation (1976)</h4>
                        <div class="equation">f ≈ 0.25 / [ log₁₀( ε/(3.7·D) + 5.74/Re⁰·⁹ ) ]²</div>
                        <p><strong>Purpose:</strong> Provides explicit initial estimate for Colebrook iteration. Accurate to ±1% for 10⁻⁶ < ε/D < 10⁻² and 5×10³ < Re < 10⁸.</p>
                        <p><strong>Reference:</strong> Swamee, P.K. & Jain, A.K. (1976). "Explicit Equations for Pipe-Flow Problems." <em>J. Hydraulics Division, ASCE</em>, 102(5), 657–664.</p>
                        
                        <h4>1.6 Blasius Initial Guess (Smooth Pipes)</h4>
                        <div class="equation">f ≈ 0.316 / Re⁰·²⁵</div>
                        <p><strong>Valid range:</strong> 4000 < Re < 10⁵ (used as initial guess for smooth pipe solver when Re < 10⁵)</p>
                        
                        <h3>2. Numerical Methods</h3>
                        
                        <h4>2.1 Colebrook Solver — Fixed-Point Iteration</h4>
                        <p>The implicit Colebrook equation is solved by rearranging to:</p>
                        <div class="equation">f<sub>n+1</sub> = 1 / [ −2·log₁₀( ε/(3.7D) + 2.51/(Re·√f<sub>n</sub>) ) ]²</div>
                        <table>
                            <tr><th>Parameter</th><th>Value</th><th>Rationale</th></tr>
                            <tr><td>Convergence tolerance</td><td>10⁻¹⁰ (relative)</td><td>Ensures precision far exceeds physical uncertainty (±5-10%)</td></tr>
                            <tr><td>Maximum iterations</td><td>100</td><td>Safety limit; typical convergence in 3-8 iterations</td></tr>
                            <tr><td>Convergence criterion</td><td>|f<sub>n+1</sub> − f<sub>n</sub>| / f<sub>n</sub> < tolerance</td><td>Relative error ensures consistent precision across f range</td></tr>
                            <tr><td>Initial guess</td><td>Swamee-Jain approximation</td><td>Provides O(1%) starting point, ensures rapid convergence</td></tr>
                        </table>
                        <p><strong>Residual verification:</strong> After convergence, the implementation computes |LHS − RHS| of the Colebrook equation as a sanity check (typically < 10⁻⁸).</p>
                        
                        <h4>2.2 Smooth Pipe Solver — Newton-Raphson</h4>
                        <p>For the Prandtl equation G(f) = 1/√f − 2·log₁₀(Re·√f) + 0.8 = 0:</p>
                        <div class="equation">f<sub>n+1</sub> = f<sub>n</sub> − G(f<sub>n</sub>) / G'(f<sub>n</sub>)</div>
                        <p>where:</p>
                        <div class="equation">G'(f) = −0.5·f⁻¹·⁵ − 1/(f·ln(10))</div>
                        <p><strong>Safeguard:</strong> If Newton step produces f ≤ 0, the step is rejected and f is halved instead.</p>
                        
                        <h4>2.3 Transition Region Interpolation (2300 < Re < 4000)</h4>
                        <div class="warning-box">
                            <strong>⚠️ Non-physical region:</strong> The transition regime is inherently unstable. No universally accepted equation exists. This tool uses log-linear interpolation for visual continuity only.
                        </div>
                        <div class="equation">f = 10^[ (1−t)·log₁₀(f<sub>lam</sub>(Re)) + t·log₁₀(f<sub>turb</sub>(Re)) ]</div>
                        <p>where:</p>
                        <div class="equation">t = [ log₁₀(Re) − log₁₀(2300) ] / [ log₁₀(4000) − log₁₀(2300) ]</div>
                        <table>
                            <tr><th>At Re =</th><th>t =</th><th>Result</th></tr>
                            <tr><td>2300</td><td>0</td><td>f = 64/Re (matches laminar boundary)</td></tr>
                            <tr><td>4000</td><td>1</td><td>f = Colebrook (matches turbulent boundary)</td></tr>
                        </table>
                        <p><strong>Rationale:</strong> Logarithmic interpolation is chosen because both axes are logarithmic, ensuring smooth visual blending. The interpolation is performed at each Re value (not linearly between boundary f values), which produces physically reasonable behavior where f may increase through transition (turbulent friction > laminar friction at these Re).</p>
                        
                        <h3>3. Validation & Verification</h3>
                        
                        <h4>3.1 Test Cases Against Published Values</h4>
                        <table>
                            <tr><th>Re</th><th>ε/D</th><th>f (computed)</th><th>f (reference)</th><th>Source</th></tr>
                            <tr><td>1,000</td><td>—</td><td>0.0640</td><td>0.0640</td><td>Exact: 64/Re</td></tr>
                            <tr><td>100,000</td><td>0 (smooth)</td><td>0.0180</td><td>0.0180</td><td>Prandtl equation</td></tr>
                            <tr><td>1,000,000</td><td>0 (smooth)</td><td>0.0116</td><td>0.0116</td><td>Prandtl equation</td></tr>
                            <tr><td>100,000</td><td>0.001</td><td>0.0222</td><td>0.0222</td><td>Colebrook iteration</td></tr>
                            <tr><td>100,000</td><td>0.01</td><td>0.0385</td><td>0.0385</td><td>Moody (1944) chart</td></tr>
                            <tr><td>10⁸</td><td>0.01</td><td>0.0379</td><td>0.0379</td><td>von Kármán fully rough</td></tr>
                        </table>
                        
                        <h4>3.2 Built-in Test Suite</h4>
                        <p>Run <code>TEST.run()</code> in browser console to execute comprehensive verification covering:</p>
                        <ul>
                            <li>Laminar flow (exact 64/Re verification)</li>
                            <li>Smooth pipe (Prandtl equation, multiple Re values)</li>
                            <li>Colebrook solver (convergence, accuracy)</li>
                            <li>Fully rough limit (von Kármán)</li>
                            <li>Transition region continuity</li>
                            <li>Edge cases and error handling</li>
                            <li>Round-trip roughness inference</li>
                        </ul>
                        
                        <h3>4. Precision vs. Accuracy</h3>
                        <div class="warning-box">
                            <strong>Important distinction:</strong><br>
                            • <strong>Numerical precision:</strong> 10⁻¹⁰ relative tolerance (this tool's internal calculations)<br>
                            • <strong>Physical accuracy:</strong> ±5-10% (inherent uncertainty per Moody, 1944)<br><br>
                            The solver precision far exceeds physical accuracy. Real-world deviations arise from: roughness estimation, non-uniform roughness, pipe aging, entrance effects, temperature gradients, and non-Newtonian behavior.
                        </div>
                        
                        <h3>5. Alternative Formulations Not Used</h3>
                        <table>
                            <tr><th>Equation</th><th>Type</th><th>Why Not Used</th></tr>
                            <tr><td>Haaland (1983)</td><td>Explicit</td><td>±1.5% error vs Colebrook; used only when iteration impossible</td></tr>
                            <tr><td>Churchill (1977)</td><td>Explicit, unified</td><td>Covers all regimes but less standard; different transition behavior</td></tr>
                            <tr><td>Serghides (1984)</td><td>Explicit, 3-step</td><td>High accuracy but more complex; iteration preferred for traceability</td></tr>
                            <tr><td>Fanning friction factor</td><td>Different convention</td><td>f<sub>Fanning</sub> = f<sub>Darcy</sub>/4; this tool uses Darcy (Moody chart standard)</td></tr>
                        </table>
                        
                        <h3>6. Source Code Access</h3>
                        <p>All solver functions are exposed globally for verification:</p>
                        <ul>
                            <li><code>SOLVER.laminar(Re)</code> — Returns {f, method, equation, ...}</li>
                            <li><code>SOLVER.smoothPipe(Re)</code> — Returns {f, iterations, residual, ...}</li>
                            <li><code>SOLVER.colebrook(Re, εD)</code> — Returns {f, iterations, residual, verification, ...}</li>
                            <li><code>SOLVER.fullyRough(εD)</code> — Returns {f, equation, ...}</li>
                            <li><code>SOLVER.getFrictionFactor(Re, εD)</code> — Unified solver with regime detection</li>
                            <li><code>CONFIG</code> — All configuration constants</li>
                        </ul>
                        <p>Example console verification:</p>
                        <pre style="background: var(--bg-input); padding: 12px; border-radius: 6px; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;">
const result = SOLVER.colebrook(100000, 0.001);
console.log('f =', result.f);           // 0.02219...
console.log('Iterations:', result.iterations);  // typically 4-6
console.log('Residual:', result.residual);      // < 1e-8
console.log('LHS:', result.verification.lhs);   // 1/√f
console.log('RHS:', result.verification.rhs);   // Should equal LHS
                        </pre>
                    `
                }
            };
            
            document.querySelectorAll('.info-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.dataset.modal;
                    if (content[key]) {
                        title.textContent = content[key].title;
                        body.innerHTML = content[key].html;
                        overlay.classList.add('active');
                    }
                });
            });
            
            document.getElementById('modalClose').addEventListener('click', () => overlay.classList.remove('active'));
            overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.classList.remove('active'); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') overlay.classList.remove('active'); });
        }
    };

    // ========================================
    // GLOBAL FUNCTIONS
    // ========================================
    // Theme redraw hook:
    // shared.js handles the actual theme state + persistence.
    // We just redraw the canvas when html[data-theme] changes.
    function bindThemeRedraw() {
        const root = document.documentElement;
        if (root.__moodyThemeObserver) return;

        const obs = new MutationObserver((mutations) => {
            for (const m of mutations) {
                if (m.type === 'attributes' && m.attributeName === 'data-theme') {
                    // Ensure CSS variables have applied before drawing
                    requestAnimationFrame(() => {
                        try {
                            RENDERER.draw();
                        } catch (e) {
                            // no-op: renderer may not be ready yet
                        }
                    });
                }
            }
        });

        obs.observe(root, { attributes: true, attributeFilter: ['data-theme'] });
        root.__moodyThemeObserver = obs;
    }


    function resetView() {
        // Reset to default values (Re=1e5, ε/D=0.001 → f≈0.0222 from Colebrook)
        STATE.point = { Re: 1e5, f: 0.0222 };
        STATE.relRoughness = 0.001;
        // Clear cached calculation result to avoid showing stale data
        UI.lastCalcResult = SOLVER.getFrictionFactor(STATE.point.Re, STATE.relRoughness);
        RENDERER.draw();
        UI.updateDisplay();
    }

    function exportPng() {
        // Use toBlob instead of toDataURL for better memory efficiency and browser compatibility
        RENDERER.canvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'moody-chart.png';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }

    // ========================================
    // COMPREHENSIVE TEST SUITE
    // ========================================
    const TEST = {
        passed: 0,
        failed: 0,
        results: [],

        run() {
            console.clear();
            this.passed = 0;
            this.failed = 0;
            this.results = [];
            
            console.log('%c╔══════════════════════════════════════════════════════════════╗', 'color: #f59e0b');
            console.log('%c║         MOODY CHART READER - VERIFICATION TEST SUITE         ║', 'color: #f59e0b; font-weight: bold');
            console.log('%c╚══════════════════════════════════════════════════════════════╝', 'color: #f59e0b');
            console.log('');
            
            this.testLaminarFlow();
            this.testSmoothPipe();
            this.testColebrookSolver();
            this.testFullyRough();
            this.testInverseRoughness();
            this.testTransitionRegion();
            this.testEdgeCases();
            this.testConvergence();
            this.testReferenceValues();
            
            this.printSummary();
            return { passed: this.passed, failed: this.failed, results: this.results };
        },

        assert(name, condition, actual, expected, tolerance = null) {
            const pass = condition;
            if (pass) {
                this.passed++;
                this.results.push({ name, pass: true, actual, expected });
                console.log(`  %c✓ ${name}`, 'color: #22c55e');
                if (tolerance !== null) {
                    console.log(`    %cActual: ${actual}, Expected: ${expected} (±${tolerance})`, 'color: #8b949e');
                }
            } else {
                this.failed++;
                this.results.push({ name, pass: false, actual, expected });
                console.log(`  %c✗ ${name}`, 'color: #ef4444');
                console.log(`    %cActual: ${actual}, Expected: ${expected}`, 'color: #ef4444');
            }
        },

        assertApprox(name, actual, expected, tolerancePercent = 1) {
            const error = Math.abs(actual - expected) / expected * 100;
            const pass = error <= tolerancePercent;
            this.assert(name, pass, actual.toFixed(6), expected.toFixed(6), `${tolerancePercent}%`);
            return { pass, error };
        },

        testLaminarFlow() {
            console.log('%c\n═══ LAMINAR FLOW TESTS ═══', 'color: #06b6d4; font-weight: bold');
            console.log('Testing f = 64/Re for Re < 2300\n');
            
            // Exact analytical tests
            const laminarCases = [
                { Re: 100, expected: 0.64, desc: 'Very low Re' },
                { Re: 500, expected: 0.128, desc: 'Low Re' },
                { Re: 1000, expected: 0.064, desc: 'Standard test case' },
                { Re: 1500, expected: 0.042667, desc: 'Mid laminar' },
                { Re: 2000, expected: 0.032, desc: 'Upper laminar' },
                { Re: 2299, expected: 0.02784, desc: 'Just below transition' },
            ];
            
            laminarCases.forEach(({ Re, expected, desc }) => {
                const result = SOLVER.laminar(Re);
                const actual = result.f;
                const exactExpected = 64 / Re;
                this.assert(
                    `Laminar Re=${Re} (${desc})`,
                    Math.abs(actual - exactExpected) < 1e-10,
                    actual,
                    exactExpected
                );
            });
            
            // Test that laminar returns correct metadata
            const lamResult = SOLVER.laminar(1000);
            this.assert('Laminar returns converged=true', lamResult.converged === true, lamResult.converged, true);
            this.assert('Laminar returns iterations=1', lamResult.iterations === 1, lamResult.iterations, 1);
            this.assert('Laminar returns correct method', lamResult.method === 'Laminar (64/Re)', lamResult.method, 'Laminar (64/Re)');
        },

        testSmoothPipe() {
            console.log('%c\n═══ SMOOTH PIPE (PRANDTL) TESTS ═══', 'color: #22c55e; font-weight: bold');
            console.log('Testing 1/√f = 2·log₁₀(Re·√f) - 0.8\n');
            
            // Reference values computed from Prandtl equation
            const smoothCases = [
                { Re: 4000, expected: 0.0399, tol: 2, desc: 'Low turbulent' },
                { Re: 10000, expected: 0.0309, tol: 1, desc: 'Standard' },
                { Re: 50000, expected: 0.0209, tol: 1, desc: 'Mid turbulent' },
                { Re: 100000, expected: 0.0180, tol: 1, desc: 'High turbulent' },
                { Re: 500000, expected: 0.0132, tol: 1, desc: 'Very high Re' },
                { Re: 1000000, expected: 0.0116, tol: 1, desc: 'Re = 10^6' },
                { Re: 10000000, expected: 0.0081, tol: 2, desc: 'Re = 10^7' },
                { Re: 100000000, expected: 0.0059, tol: 2, desc: 'Re = 10^8' },
            ];
            
            smoothCases.forEach(({ Re, expected, tol, desc }) => {
                const result = SOLVER.smoothPipe(Re);
                this.assertApprox(`Smooth Re=${Re.toExponential(0)} (${desc})`, result.f, expected, tol);
                
                // Verify convergence
                if (!result.converged) {
                    console.log(`    %c⚠ Did not converge in ${result.iterations} iterations`, 'color: #eab308');
                }
            });
            
            // Test convergence behavior
            const convTest = SOLVER.smoothPipe(100000);
            this.assert('Smooth pipe converges', convTest.converged === true, convTest.converged, true);
            this.assert('Smooth pipe iterations < 20', convTest.iterations < 20, convTest.iterations, '< 20');
        },

        testColebrookSolver() {
            console.log('%c\n═══ COLEBROOK-WHITE SOLVER TESTS ═══', 'color: #a855f7; font-weight: bold');
            console.log('Testing 1/√f = -2·log₁₀(ε/(3.7D) + 2.51/(Re·√f))\n');
            
            // Reference values computed from Colebrook-White equation
            // Values verified against numerical solution with tolerance 1e-10
            const colebrookCases = [
                { Re: 10000, rr: 0.001, expected: 0.0324, tol: 2 },
                { Re: 10000, rr: 0.01, expected: 0.0431, tol: 2 },
                { Re: 100000, rr: 0.0001, expected: 0.0185, tol: 2 },
                { Re: 100000, rr: 0.001, expected: 0.0222, tol: 2 },
                { Re: 100000, rr: 0.01, expected: 0.0385, tol: 2 },
                { Re: 100000, rr: 0.05, expected: 0.0718, tol: 2 },
                { Re: 1000000, rr: 0.0001, expected: 0.0134, tol: 2 },
                { Re: 1000000, rr: 0.001, expected: 0.0199, tol: 2 },
                { Re: 1000000, rr: 0.01, expected: 0.0380, tol: 2 },
                { Re: 10000000, rr: 0.001, expected: 0.0197, tol: 2 },
                { Re: 10000000, rr: 0.0001, expected: 0.0122, tol: 2 },
            ];
            
            colebrookCases.forEach(({ Re, rr, expected, tol }) => {
                const result = SOLVER.colebrook(Re, rr);
                this.assertApprox(`Colebrook Re=${Re.toExponential(0)}, ε/D=${rr}`, result.f, expected, tol);
            });
            
            // Test that Colebrook properly delegates to smooth pipe for tiny roughness
            const smoothDelegation = SOLVER.colebrook(100000, 1e-10);
            const directSmooth = SOLVER.smoothPipe(100000);
            this.assert(
                'Colebrook delegates to smooth for ε/D < 10⁻⁷',
                Math.abs(smoothDelegation.f - directSmooth.f) < 1e-10,
                smoothDelegation.f,
                directSmooth.f
            );
        },

        testFullyRough() {
            console.log('%c\n═══ FULLY ROUGH (VON KÁRMÁN) TESTS ═══', 'color: #f97316; font-weight: bold');
            console.log('Testing 1/√f = -2·log₁₀(ε/(3.7D)) - limiting friction factor\n');
            
            const roughCases = [
                { rr: 0.0001, expected: 0.0120 },
                { rr: 0.001, expected: 0.0196 },
                { rr: 0.01, expected: 0.0379 },
                { rr: 0.02, expected: 0.0486 },
                { rr: 0.05, expected: 0.0716 },
            ];
            
            roughCases.forEach(({ rr, expected }) => {
                const result = SOLVER.fullyRough(rr);
                this.assertApprox(`Fully rough ε/D=${rr}`, result.f, expected, 1);
            });
            
            // Verify that Colebrook approaches fully rough limit at high Re
            const highRe = SOLVER.colebrook(1e8, 0.01);
            const fullyRoughLimit = SOLVER.fullyRough(0.01);
            const diff = Math.abs(highRe.f - fullyRoughLimit.f) / fullyRoughLimit.f * 100;
            this.assert(
                'Colebrook approaches fully rough at high Re',
                diff < 1,
                `${diff.toFixed(2)}% difference`,
                '< 1%'
            );
        },

        testInverseRoughness() {
            console.log('%c\n═══ INVERSE ROUGHNESS INFERENCE TESTS ═══', 'color: #ec4899; font-weight: bold');
            console.log('Testing ε/D = 3.7·(10^(-1/(2√f)) - 2.51/(Re·√f))\n');
            
            // Round-trip tests: compute f from Re and ε/D, then recover ε/D
            const roundTripCases = [
                { Re: 100000, rr: 0.001 },
                { Re: 100000, rr: 0.01 },
                { Re: 1000000, rr: 0.0001 },
                { Re: 1000000, rr: 0.01 },
            ];
            
            roundTripCases.forEach(({ Re, rr }) => {
                const forward = SOLVER.colebrook(Re, rr);
                const inverse = SOLVER.inferRelRoughness(Re, forward.f);
                const error = Math.abs(inverse.relRoughness - rr) / rr * 100;
                this.assert(
                    `Round-trip Re=${Re.toExponential(0)}, ε/D=${rr}`,
                    error < 1,
                    inverse.relRoughness.toExponential(3),
                    rr.toExponential(3)
                );
            });
            
            // Test below smooth pipe detection
            const belowSmooth = SOLVER.inferRelRoughness(100000, 0.010); // f too low for any roughness
            this.assert(
                'Detects below smooth pipe curve',
                belowSmooth.warning !== undefined || belowSmooth.relRoughness === 0,
                belowSmooth.relRoughness,
                '0 or warning'
            );
        },

        testTransitionRegion() {
            console.log('%c\n═══ TRANSITION REGION TESTS ═══', 'color: #eab308; font-weight: bold');
            console.log('Testing interpolation in 2300 < Re < 4000\n');
            
            // Test that transition returns interpolated values
            const transCases = [
                { Re: 2500, rr: 0.001 },
                { Re: 3000, rr: 0.001 },
                { Re: 3500, rr: 0.001 },
            ];
            
            transCases.forEach(({ Re, rr }) => {
                const result = SOLVER.getFrictionFactor(Re, rr);
                this.assert(
                    `Transition Re=${Re} returns regime='Transitional'`,
                    result.regime === 'Transitional',
                    result.regime,
                    'Transitional'
                );
                this.assert(
                    `Transition Re=${Re} has warning`,
                    result.warning !== undefined,
                    result.warning ? 'Has warning' : 'No warning',
                    'Has warning'
                );
            });
            
            // Test boundary continuity - this is the critical physical requirement
            const f2300 = SOLVER.getFrictionFactor(2300, 0.001).f;
            const f2300Laminar = SOLVER.laminar(2300).f;
            const f4000 = SOLVER.getFrictionFactor(4000, 0.001).f;
            const f4000Turb = SOLVER.colebrook(4000, 0.001).f;
            
            this.assert(
                'Continuity at Re=2300: transition f matches laminar f',
                Math.abs(f2300 - f2300Laminar) < 0.0001,
                `${f2300.toFixed(4)} ≈ ${f2300Laminar.toFixed(4)}`,
                'Equal within tolerance'
            );
            
            this.assert(
                'Continuity at Re=4000: transition f matches turbulent f',
                Math.abs(f4000 - f4000Turb) < 0.0001,
                `${f4000.toFixed(4)} ≈ ${f4000Turb.toFixed(4)}`,
                'Equal within tolerance'
            );
            
            // Test that f values in transition are between the bounds at each Re
            // Note: Due to Moody chart physics, f may INCREASE through transition
            // because turbulent friction > laminar friction at these Re values
            const f3000 = SOLVER.getFrictionFactor(3000, 0.001).f;
            const fLam3000 = 64 / 3000;
            const fTurb3000 = SOLVER.colebrook(3000, 0.001).f;
            const minF = Math.min(fLam3000, fTurb3000);
            const maxF = Math.max(fLam3000, fTurb3000);
            
            this.assert(
                'f at Re=3000 is between laminar and turbulent bounds',
                f3000 >= minF && f3000 <= maxF,
                `${minF.toFixed(4)} ≤ ${f3000.toFixed(4)} ≤ ${maxF.toFixed(4)}`,
                'Within bounds'
            );
            
            // Document the expected behavior: f increases through transition
            // This is physically correct - turbulent friction > laminar friction at these Re
            console.log('%c  Note: f increases through transition (laminar→turbulent) for ε/D=0.001:', 'color: #8b949e');
            console.log(`%c    Re=2300: f=${f2300.toFixed(4)} (laminar boundary)`, 'color: #8b949e');
            console.log(`%c    Re=3000: f=${f3000.toFixed(4)} (interpolated)`, 'color: #8b949e');
            console.log(`%c    Re=4000: f=${f4000.toFixed(4)} (turbulent boundary)`, 'color: #8b949e');
            console.log('%c  This is physically correct: turbulent friction > laminar friction.', 'color: #8b949e');
        },

        testEdgeCases() {
            console.log('%c\n═══ EDGE CASE TESTS ═══', 'color: #6366f1; font-weight: bold');
            console.log('Testing boundary conditions and error handling\n');
            
            // Invalid inputs
            const negRe = SOLVER.laminar(-100);
            this.assert('Laminar handles Re < 0', isNaN(negRe.f) || negRe.error, negRe.f || negRe.error, 'NaN or error');
            
            const zeroRe = SOLVER.colebrook(0, 0.001);
            this.assert('Colebrook handles Re = 0', isNaN(zeroRe.f) || zeroRe.error, zeroRe.f || zeroRe.error, 'NaN or error');
            
            const negRr = SOLVER.colebrook(100000, -0.001);
            this.assert('Colebrook handles ε/D < 0', isNaN(negRr.f) || negRr.error, negRr.f || negRr.error, 'NaN or error');
            
            // Boundary values
            const minRe = SOLVER.getFrictionFactor(CONFIG.Re.min, 0.001);
            this.assert('Handles minimum Re', !isNaN(minRe.f) && minRe.f > 0, minRe.f, '> 0');
            
            const maxRe = SOLVER.getFrictionFactor(CONFIG.Re.max, 0.001);
            this.assert('Handles maximum Re', !isNaN(maxRe.f) && maxRe.f > 0, maxRe.f, '> 0');
            
            const maxRr = SOLVER.colebrook(100000, 0.05);
            this.assert('Handles maximum ε/D', !isNaN(maxRr.f) && maxRr.converged, maxRr.f, 'converged');
        },

        testConvergence() {
            console.log('%c\n═══ CONVERGENCE TESTS ═══', 'color: #14b8a6; font-weight: bold');
            console.log('Testing solver stability and iteration counts\n');
            
            const convergenceCases = [
                { Re: 4000, rr: 0.001, maxIter: 20 },
                { Re: 100000, rr: 0.001, maxIter: 15 },
                { Re: 1000000, rr: 0.01, maxIter: 15 },
                { Re: 10000000, rr: 0.05, maxIter: 15 },
                { Re: 100000000, rr: 0.001, maxIter: 15 },
            ];
            
            convergenceCases.forEach(({ Re, rr, maxIter }) => {
                const result = SOLVER.colebrook(Re, rr);
                this.assert(
                    `Colebrook Re=${Re.toExponential(0)}, ε/D=${rr} converges in < ${maxIter} iters`,
                    result.converged && result.iterations < maxIter,
                    `${result.iterations} iterations`,
                    `< ${maxIter}`
                );
            });
            
            // Test that residual is small
            const residualTest = SOLVER.colebrook(100000, 0.001);
            this.assert(
                'Residual < 10⁻⁸',
                residualTest.residual < 1e-8,
                residualTest.residual?.toExponential(2),
                '< 1e-8'
            );
        },

        testReferenceValues() {
            console.log('%c\n═══ REFERENCE VALUE TESTS ═══', 'color: #f59e0b; font-weight: bold');
            console.log('Testing against published Moody chart values\n');
            
            // Classic reference values from textbooks
            const refValues = [
                { Re: 4000, rr: 0, f: 0.0399, src: 'Blasius (smooth)', tol: 3 },
                { Re: 100000, rr: 0, f: 0.0180, src: 'Prandtl (smooth)', tol: 2 },
                { Re: 1000000, rr: 0, f: 0.0116, src: 'Prandtl (smooth)', tol: 2 },
                { Re: 100000, rr: 0.001, f: 0.0222, src: 'Colebrook', tol: 2 },
                { Re: 100000, rr: 0.01, f: 0.0385, src: 'Moody chart', tol: 2 },
                { Re: 1000000, rr: 0.001, f: 0.0199, src: 'Near fully rough limit', tol: 2 },
            ];
            
            refValues.forEach(({ Re, rr, f, src, tol }) => {
                const result = rr === 0 ? SOLVER.smoothPipe(Re) : SOLVER.colebrook(Re, rr);
                this.assertApprox(`${src}: Re=${Re.toExponential(0)}, ε/D=${rr}`, result.f, f, tol);
            });
        },

        printSummary() {
            console.log('');
            console.log('%c╔══════════════════════════════════════════════════════════════╗', 'color: #f59e0b');
            console.log('%c║                        TEST SUMMARY                          ║', 'color: #f59e0b; font-weight: bold');
            console.log('%c╚══════════════════════════════════════════════════════════════╝', 'color: #f59e0b');
            console.log('');
            
            const total = this.passed + this.failed;
            const passRate = (this.passed / total * 100).toFixed(1);
            
            if (this.failed === 0) {
                console.log(`%c  ✓ ALL ${total} TESTS PASSED (${passRate}%)`, 'color: #22c55e; font-weight: bold; font-size: 14px');
            } else {
                console.log(`%c  ✓ Passed: ${this.passed}`, 'color: #22c55e');
                console.log(`%c  ✗ Failed: ${this.failed}`, 'color: #ef4444');
                console.log(`%c  Pass rate: ${passRate}%`, this.failed > 0 ? 'color: #eab308' : 'color: #22c55e');
            }
            
            console.log('');
            console.log('%c  Run TEST.run() to re-execute all tests', 'color: #8b949e');
            console.log('%c  Access TEST.results for detailed results', 'color: #8b949e');
            console.log('');
        }
    };

    // Make TEST globally accessible
    window.TEST = TEST;

    // ========================================
    // INITIALIZATION
    // ========================================
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('moodyCanvas');
        RENDERER.init(canvas);
        RENDERER.draw();
        
        // Initialize lastCalcResult for correct initial calculation details
        UI.lastCalcResult = SOLVER.getFrictionFactor(STATE.point.Re, STATE.relRoughness);
        UI.init();
        // redraw canvas when theme changes via shared.js
        bindThemeRedraw();
        // Print test instructions to console
        console.log('%c╔══════════════════════════════════════════════════════════════╗', 'color: #f59e0b');
        console.log('%c║              MOODY CHART READER - INITIALIZED                ║', 'color: #f59e0b; font-weight: bold');
        console.log('%c╚══════════════════════════════════════════════════════════════╝', 'color: #f59e0b');
        console.log('');
        console.log('%c  Run TEST.run() to execute comprehensive verification tests', 'color: #06b6d4; font-weight: bold');
        console.log('%c  Access TEST.results after running for detailed results', 'color: #8b949e');
        console.log('');
        console.log('%c  Available functions:', 'color: #8b949e');
        console.log('%c    • TEST.run()           - Run all verification tests', 'color: #8b949e');
        console.log('%c    • SOLVER.colebrook(Re, ε/D) - Compute friction factor', 'color: #8b949e');
        console.log('%c    • SOLVER.smoothPipe(Re)    - Smooth pipe friction factor', 'color: #8b949e');
        console.log('%c    • SOLVER.laminar(Re)       - Laminar friction factor', 'color: #8b949e');
        console.log('%c    • resetView()              - Reset chart to defaults', 'color: #8b949e');
        console.log('');
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                RENDERER.init(canvas);
                RENDERER.draw();
            }, 200);
        });
    });
    
    // Expose SOLVER globally for console access
    window.SOLVER = SOLVER;
    </script>
</body>
</html>
