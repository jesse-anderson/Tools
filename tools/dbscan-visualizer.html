<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DBSCAN Visualizer | Tools Hub</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../css/shared.css">
  <style>
    /* ============================================
       CSS Variables & Base Styles
       ============================================ */
    :root {
      --bg-primary: #0a0e14;
      --bg-secondary: #12171f;
      --bg-card: #181f2a;
      --bg-input: #1e2734;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #5a6370;
      --border-color: #2d3748;
      --accent-primary: #f59e0b;
      --accent-primary-dim: #d97706;
      --accent-success: #22c55e;
      --accent-warning: #eab308;
      --accent-error: #ef4444;
      --accent-secondary: #6366f1;
      --accent-orange: #f97316;
      --accent-pink: #ec4899;
      --overlay-bg: rgba(10, 14, 20, 0.85);
    }
    [data-theme="light"] {
      --bg-primary: #f8fafc;
      --bg-secondary: #f1f5f9;
      --bg-card: #ffffff;
      --bg-input: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --border-color: #cbd5e1;
      --overlay-bg: rgba(255, 255, 255, 0.9);
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 24px;
    }

    /* ============================================
       Header
       ============================================ */
    header {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 16px;
    }

    .tool-icon-header {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-primary);
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      margin: 0;
      color: var(--accent-primary);
    }

    .tagline {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-top: 4px;
    }

    .status-badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .status-badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
    }

    .status-badge.ok { border-color: rgba(34, 197, 94, 0.5); color: var(--accent-success); }
    .status-badge.warn { border-color: rgba(234, 179, 8, 0.5); color: var(--accent-warning); }
    .status-badge.err { border-color: rgba(239, 68, 68, 0.5); color: var(--accent-error); }

    /* ============================================
       Main Layout
       ============================================ */
    .main-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 24px;
    }

    @media (max-width: 1200px) {
      .main-layout { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 20px;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .panel-title {
      font-size: 1rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-title svg {
      width: 18px;
      height: 18px;
      stroke: var(--accent-primary);
    }

    /* ============================================
       Toolbar
       ============================================ */
    .toolbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .tool-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .tool-btn:hover {
      border-color: var(--accent-primary);
      background: var(--bg-card);
    }

    .tool-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .tool-btn.primary {
      background: var(--accent-primary);
      color: #000;
      border-color: transparent;
      font-weight: 600;
    }

    .tool-btn.primary:hover {
      background: var(--accent-primary-dim);
      opacity: 0.9;
    }


    .tool-btn.danger {
      border-color: rgba(239, 68, 68, 0.4);
      color: var(--accent-error);
    }

    .tool-btn svg {
      width: 16px;
      height: 16px;
    }

    input[type="file"].file-overlay {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    /* ============================================
       Parameters Grid
       ============================================ */
    .params-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .field input,
    .field select {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      outline: none;
    }

    .field input:focus,
    .field select:focus {
      border-color: var(--accent-primary);
    }

    .inline-check {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    .inline-check input {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-primary);

    }

    /* ============================================
       Animation Controls
       ============================================ */
    .anim-controls {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .anim-controls-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .anim-controls-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .speed-control label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
      min-width: 50px;
    }

    .speed-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: var(--bg-input);
      border-radius: 3px;
      outline: none;
    }

    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-primary);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(34, 211, 238, 0.4);
    }

    .speed-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-primary);
      min-width: 50px;
      text-align: right;
    }

    .playback-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .play-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid var(--accent-primary);
      background: transparent;
      color: var(--accent-primary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .play-btn:hover {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    .play-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .play-btn svg {
      width: 20px;
      height: 20px;
    }

    .step-btn {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .step-btn:hover {
      border-color: var(--accent-primary);
    }

    .step-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* ============================================
       Visualization Options
       ============================================ */
    .viz-options {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    /* ============================================
       Canvas Area
       ============================================ */
    .canvas-container {
      position: relative;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
    }

    #plotCanvas {
      display: block;
      width: 100%;
      height: 600px;
      background: var(--bg-card);
    }

    .canvas-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      pointer-events: none;
    }

    /* Left overlay stack: legend + interaction hint */
    .overlay-left {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      pointer-events: none;
    }

    .canvas-hint {
      background: var(--overlay-bg, rgba(10, 14, 20, 0.85));
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 10px 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      line-height: 1.35;
      pointer-events: none;
      max-width: 320px;
    }

    .canvas-hint div {
      margin: 0;
      padding: 0;
    }


    .overlay-stats {
      background: var(--overlay-bg, rgba(10, 14, 20, 0.85));
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 12px 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      padding: 3px 0;
    }

    .stat-label { color: var(--text-muted); }
    .stat-value { color: var(--accent-primary); font-weight: 600; }
    .stat-value.core { color: var(--accent-success); }
    .stat-value.border { color: var(--accent-warning); }
    .stat-value.noise { color: var(--accent-error); }
    .stat-value.unclassified { color: var(--text-muted); }

    .dimension-warning {
      margin-top: 8px;
      padding: 6px 8px;
      background: rgba(234, 179, 8, 0.15);
      border: 1px solid rgba(234, 179, 8, 0.4);
      border-radius: 6px;
      font-size: 0.6rem;
      line-height: 1.3;
      color: var(--accent-warning);
      max-width: 200px;
    }
    
    .dimension-warning-title {
      font-weight: 600;
      font-size: 0.55rem;
      margin-bottom: 2px;
    }
    
    .dimension-warning-text {
      color: var(--text-secondary);
      font-size: 0.55rem;
      word-wrap: break-word;
    }

    .legend-box {
      background: var(--overlay-bg, rgba(10, 14, 20, 0.85));
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 12px 16px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-secondary);
      padding: 3px 0;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-ring {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid;
      background: transparent;
    }

    /* ============================================
       Message Box
       ============================================ */
    .message-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
      white-space: pre-wrap;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 12px;
    }

    .message-box.error {
      border-color: rgba(239, 68, 68, 0.4);
      color: var(--accent-error);
    }

    /* ============================================
       Sidebar Cards
       ============================================ */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .sidebar-card {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
    }

    .sidebar-card h3 {
      font-size: 0.85rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar-card h3 svg {
      width: 16px;
      height: 16px;
      stroke: var(--accent-primary);
    }

    .stats-grid {
      display: grid;
      gap: 8px;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .stats-row:last-child { border-bottom: none; }

    .stats-label { color: var(--text-secondary); }
    .stats-val {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      color: var(--accent-primary);
    }

    /* ============================================
       Feature Picker
       ============================================ */
    .feature-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-secondary);
    }

    .feat-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      transition: background 0.15s;
    }

    .feat-item:last-child { border-bottom: none; }
    .feat-item:hover { background: rgba(255,255,255,0.03); }

    .feat-item input {
      width: 16px;
      height: 16px;
      accent-color: var(--accent-primary);
    }

    .feat-name {
      flex: 1;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .feat-actions {
      display: flex;
      gap: 6px;
      margin-top: 10px;
    }

    .mini-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mini-btn:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    /* ============================================
       K-Distance Chart
       ============================================ */
    .kdist-container {
      margin-top: 12px;
    }

    #kdistCanvas {
      width: 100%;
      height: 120px;
      background: var(--bg-secondary);
      border-radius: 8px;
      display: block;
    }

    .kdist-hint {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 6px;
    }

    /* ============================================
       Progress Bar
       ============================================ */
    .progress-container {
      margin-top: 12px;
    }

    .progress-bar {
      height: 6px;
      background: var(--bg-input);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent-primary);
      border-radius: 3px;
      transition: width 0.1s;
    }

    .progress-text {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 6px;
      text-align: center;
    }

    /* ============================================
       Theme Toggle
       ============================================ */
    .theme-toggle {
      display: flex;
      gap: 4px;
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 4px;
    }

    .theme-toggle button {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .theme-toggle button:hover {
      color: var(--text-primary);
    }

    .theme-toggle button.active {
      background: var(--bg-card);
      color: var(--accent-primary);
    }

    .theme-toggle svg {
      width: 16px;
      height: 16px;
    }

    /* ============================================
       Cluster Quality Metrics Panel
       ============================================ */
    .metrics-card {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin-top: 16px;
    }

    .metrics-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      user-select: none;
    }

    .metrics-header:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .metrics-header h3 {
      margin: 0;
      font-size: 0.85rem;
      font-weight: 600;
      flex: 1;
    }

    .collapse-icon {
      font-size: 0.7rem;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    #metricsContent {
      padding: 16px;
    }

    /* Metric Settings Section */
    .metrics-settings-section {
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .metrics-settings-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px 0;
    }

    .metrics-settings-header:hover {
      color: var(--text-primary);
    }

    .metrics-settings-content {
      margin-top: 12px;
    }

    .metric-toggles-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .metric-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .metric-toggle input {
      width: 14px;
      height: 14px;
      accent-color: var(--accent-primary);
    }

    .metric-toggle-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    /* Metrics Grid */
    .metrics-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .metric-row {
      padding: 8px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .metric-row:last-child {
      border-bottom: none;
    }

    .metric-row.disabled {
      opacity: 0.5;
    }

    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .metric-name {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .metric-timing {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      color: var(--text-muted);
      opacity: 0.7;
    }

    .metric-value-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .metric-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .metric-na {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text-muted);
      font-style: italic;
    }

    .metric-quality {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .metric-quality.strong { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .metric-quality.good { background: rgba(34, 211, 238, 0.2); color: #6f962c; }
    .metric-quality.fair { background: rgba(234, 179, 8, 0.2); color: #eab308; }
    .metric-quality.weak { background: rgba(249, 115, 22, 0.2); color: #f97316; }
    .metric-quality.poor { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

    .metric-value.strong { color: #00ff5e; }
    .metric-value.good { color: #6f962c; }
    .metric-value.fair { color: #eab308; }
    .metric-value.weak { color: #f97316; }
    .metric-value.poor { color: #ef4444; }

    .metric-perfect {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      color: var(--text-muted);
      opacity: 0.5;
    }

    .metric-bar {
      height: 4px;
      background: var(--bg-input);
      border-radius: 2px;
      overflow: hidden;
    }

    .metric-bar-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s ease;
      background: var(--text-muted);
    }

    .metric-bar-fill.disabled {
      background: var(--bg-input);
    }

    .metric-bar-fill.strong { background: linear-gradient(90deg, #22c55e, #16a34a); }
    .metric-bar-fill.good { background: linear-gradient(90deg, #f59e0b, #0891b2); }
    .metric-bar-fill.fair { background: linear-gradient(90deg, #eab308, #ca8a04); }
    .metric-bar-fill.weak { background: linear-gradient(90deg, #f97316, #ea580c); }
    .metric-bar-fill.poor { background: linear-gradient(90deg, #ef4444, #dc2626); }

    .metrics-note {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 8px 0;
      border-top: 1px solid var(--border-color);
      margin-top: 8px;
    }

    /* Timing Breakdown */
    .timing-breakdown {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }

    .timing-header {
      display: flex;
      justify-content: space-between;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .timing-total {
      color: var(--accent-primary);
    }

    .timing-bar {
      display: flex;
      height: 6px;
      background: var(--bg-input);
      border-radius: 3px;
      overflow: hidden;
      gap: 1px;
    }

    .timing-segment {
      opacity: 0.8;
    }

    .timing-0 { background: var(--accent-primary); }
    .timing-1 { background: var(--accent-secondary); }
    .timing-2 { background: var(--accent-success); }
    .timing-3 { background: var(--accent-warning); }
    .timing-4 { background: var(--accent-orange); }

    /* Per-Cluster Section */
    .per-cluster-section {
      margin-top: 16px;
      border-top: 1px solid var(--border-color);
      padding-top: 12px;
    }

    .per-cluster-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px 0;
    }

    .per-cluster-header:hover {
      color: var(--text-primary);
    }

    .per-cluster-content {
      margin-top: 12px;
    }

    .per-cluster-table {
      width: 100%;
      border-collapse: collapse;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
    }

    .per-cluster-table th {
      text-align: left;
      padding: 6px 8px;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      font-size: 0.65rem;
    }

    .per-cluster-table td {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-secondary);
    }

    .per-cluster-table td.num {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .cluster-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      color: #000;
      font-weight: 600;
      font-size: 0.7rem;
    }

    .no-data {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
      font-style: italic;
      padding: 8px 0;
    }

    .metrics-help-btn {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Help Modal */
    #metricsHelpModal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .metrics-help-content {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      padding: 24px;
    }

    .metrics-help-content h2 {
      margin: 0 0 20px 0;
      font-size: 1.25rem;
      color: var(--text-primary);
    }

    .help-metric {
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .help-metric:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
    }

    .help-metric h3 {
      margin: 0 0 8px 0;
      font-size: 0.9rem;
      color: var(--accent-primary);
    }

    .help-metric p {
      margin: 0 0 8px 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .help-metric .help-range {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .help-close-btn {
      margin-top: 16px;
      width: 100%;
    }
  </style>
</head>

<body>
<div class="container">
  <header>
    <div class="header-content">

      <div class="header-left">
                    <a href="../tools.html" class="back-link">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="19" y1="12" x2="5" y2="12"/>
                            <polyline points="12 19 5 12 12 5"/>
                        </svg>
                        Back to Tools
                    </a>
                </div>

      <div style="display: flex; align-items: center; gap: 16px;">
        <div class="tool-icon-header">
          <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="#fff" stroke-width="2">
            <circle cx="7" cy="7" r="2"></circle>
            <circle cx="17" cy="8" r="2"></circle>
            <circle cx="9" cy="16" r="2"></circle>
            <circle cx="18" cy="17" r="2"></circle>
            <path d="M4 20h16M4 4v16" opacity="0.5"></path>
          </svg>
        </div>
        <div>
          <h1>DBSCAN Visualizer</h1>
          <p class="tagline">// DBSCAN ‚Ä¢ 2D/3D Viz ‚Ä¢ Rust WASM ‚Ä¢ Clustering Metrics</p>
        </div>
      </div>
      <div class="status-badges">
        <span id="engineBadge" class="status-badge warn">ENGINE: LOADING</span>
        <span id="uiBadge" class="status-badge">UI: 1.0.0</span>
        <div class="theme-toggle">
          <button id="themeLight" title="Light mode">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="5"/>
              <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
            </svg>
          </button>
          <button id="themeDark" class="active" title="Dark mode">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="main-layout">
      <!-- Main Panel -->
      <div class="main-panel">
        <div class="panel">
          <div class="toolbar">
            <div class="tool-btn" style="position: relative;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Load CSV
              <input type="file" id="fileInput" class="file-overlay" accept=".csv,text/csv" />
            </div>
            <div class="field" style="min-width: 140px;">
              <label>Sample Data</label>
              <select id="sampleDataSelect">
                <option value="">‚Äî Select Sample Data ‚Äî</option>
                <option value="clusters4">4 Clusters</option>
                <option value="moons">Two Moons</option>
                <option value="circles">Concentric Circles</option>
                <option value="spiral">Spiral Arms</option>
                <option value="density">Varied Density</option>
                <option value="smiley3d">3D Smiley Face</option>
                <option value="blobs3d">3D Blobs</option>
                <option value="pressure10k">Pressure Test 30k - Rings</option>
              </select>
            </div>
            <button class="tool-btn primary" id="btnRun" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 5v14l11-7z"/>
              </svg>
              Run DBSCAN
            </button>
            <button class="tool-btn" id="btnPlotData" disabled title="Plot points without clustering">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="6" cy="6" r="2"/>
                <circle cx="18" cy="6" r="2"/>
                <circle cx="12" cy="12" r="2"/>
                <circle cx="6" cy="18" r="2"/>
                <circle cx="18" cy="18" r="2"/>
              </svg>
              Plot Data
            </button>
            <button class="tool-btn" id="btnKDistance" disabled title="Compute k-distance plot only">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3v18h18"/>
                <path d="M7 16l4-8 4 4 5-9"/>
              </svg>
              K-Distance
            </button>
            <button class="tool-btn" id="btnDownloadCsv" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
              </svg>
              Export CSV
            </button>
            <button class="tool-btn" id="btnDownloadPng" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <path d="M21 15l-5-5L5 21"/>
              </svg>
              Export PNG
            </button>
            <button class="tool-btn danger" id="btnClear" style="margin-left: auto;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
              Clear
            </button>
          </div>

          <div class="params-grid">
            <div class="field">
              <label>Epsilon (Œµ)</label>
              <input type="number" id="epsInput" value="0.5" min="0.01" step="0.01" />
            </div>
            <div class="field">
              <label>Min Points</label>
              <input type="number" id="minPtsInput" value="5" min="1" step="1" />
            </div>
            <div class="field">
              <label>Missing Policy</label>
              <select id="missingPolicy">
                <option value="drop">Drop Rows</option>
                <option value="impute">Impute Mean</option>
                <option value="fail">Fail on Missing</option>
              </select>
            </div>
            <div class="field">
              <label>Plot Mode</label>
              <select id="plotMode">
                <option value="2d">2D Scatter</option>
                <option value="3d">3D Scatter</option>
              </select>
            </div>
            <div class="field">
              <label>Plot X</label>
              <select id="plotX"></select>
            </div>
            <div class="field">
              <label>Plot Y</label>
              <select id="plotY"></select>
            </div>
            <div class="field">
              <label>Plot Z (3D)</label>
              <select id="plotZ"></select>
            </div>
            <div class="field">
              <label>Point Size</label>
              <input type="number" id="pointSize" value="4" min="1" max="20" step="1" />
            </div>
            <div class="field">
              <label>View Mode</label>
              <select id="viewMode">
                <option value="clusters">Clusters</option>
                <option value="classification">Core/Border/Noise</option>
              </select>
            </div>
            <div class="field">
              <label>Zoom</label>
              <input type="range" id="zoomSlider" min="0.3" max="10" step="0.1" value="1" />
            </div>
          </div>

          <div style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 16px;">
            <label class="inline-check">
              <input type="checkbox" id="standardize" checked />
              Standardize Features
            </label>
            <label class="inline-check">
              <input type="checkbox" id="animateCheck" checked />
              Animate Clustering
            </label>
            <label class="inline-check">
              <input type="checkbox" id="showRadius" checked />
              Show Œµ Radius
            </label>
            <label class="inline-check">
                <input type="checkbox" id="showNeighborLines" checked />
                Show Neighbor Lines
              </label>
            <label class="inline-check">
              <input type="checkbox" id="showGridlines" />
              Show Gridlines
            </label>
            <label class="inline-check">
              <input type="checkbox" id="showDensityGrid" />
              Show Density Grid
            </label>
          </div>

          <!-- Animation Controls -->
          <div class="anim-controls" id="animControls">
            <div class="anim-controls-header">
              <span class="anim-controls-title">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                  <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
                Animation Controls
              </span>
              <span id="animStatus" style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-muted);">Ready</span>
            </div>
            <div class="speed-control">
              <label>Speed</label>
              <input type="range" id="speedSlider" class="speed-slider" min="-2" max="2" step="0.1" value="0" />
              <span id="speedValue" class="speed-value">1.0x</span>
            </div>
            <div class="playback-controls">
              <button class="play-btn" id="btnPlay" disabled title="Play/Pause">
                <svg id="playIcon" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                  <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
              </button>
              <button class="step-btn" id="btnStepBack" disabled>‚Üê Step Back</button>
              <button class="step-btn" id="btnStep" disabled>Step ‚Üí</button>
              <button class="step-btn" id="btnSkip10" disabled>Skip 10 ‚Üí</button>
              <button class="step-btn" id="btnSkip100" disabled>Skip 100 ‚Üí</button>
              <button class="step-btn" id="btnReset" disabled>Reset</button>
            </div>
            <div class="progress-container">
              <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
              </div>
              <div id="progressText" class="progress-text">0 / 0 events</div>
            </div>
          </div>

          <!-- Canvas -->
          <div class="canvas-container">

            <canvas id="plotCanvas"></canvas>

            <div class="canvas-overlay">
              <div class="overlay-left">
                <div class="legend-box" id="legendBox" style="display: none;">
                  <div id="legendContent">
                    <!-- Dynamic legend content -->
                  </div>
                </div>

                <div class="canvas-hint" id="canvasHint">
                  <div>Drag to pan</div>
                  <div>Scroll to zoom</div>
                  <div>3D: Drag=rotate, Shift+drag=pan</div>
                </div>
              </div>


              <div class="overlay-stats" id="overlayStats" style="display: none;">
                <div class="stat-row">
                  <span class="stat-label">Current Point:</span>
                  <span class="stat-value" id="statCurrent">‚Äî</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Neighbors:</span>
                  <span class="stat-value" id="statNeighbors">‚Äî</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Type:</span>
                  <span class="stat-value" id="statType">‚Äî</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Cluster:</span>
                  <span class="stat-value" id="statCluster">‚Äî</span>
                </div>
                <div class="dimension-warning" id="dimensionWarning" style="display: none;">
                  <div class="dimension-warning-title">
                    <span>!!!! Dimension Mismatch !!!!</span>
                  </div>
                  <div class="dimension-warning-text" id="dimensionWarningText">
                    Œµ-circle computed in higher dimensions
                  </div>
                </div>
              </div>


            </div>


          </div>

          <div id="msgBox" class="message-box">
            Load a CSV file or select sample data to begin.
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <!-- Dataset Info -->
        <div class="sidebar-card">
          <h3>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
              <polyline points="14 2 14 8 20 8"/>
            </svg>
            Dataset
          </h3>
          <div class="stats-grid">
            <div class="stats-row">
              <span class="stats-label">File</span>
              <span class="stats-val" id="statFile">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Rows</span>
              <span class="stats-val" id="statRows">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Columns</span>
              <span class="stats-val" id="statCols">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Numeric</span>
              <span class="stats-val" id="statNumeric">‚Äî</span>
            </div>
          </div>
        </div>

        <!-- Feature Picker -->
        <div class="sidebar-card">
          <h3>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
            </svg>
            Features
          </h3>
          <div id="featureList" class="feature-list">
            <div style="padding: 16px; text-align: center; color: var(--text-muted); font-size: 0.8rem;">
              Load data to select features
            </div>
          </div>
          <div class="feat-actions">
            <button class="mini-btn" id="btnFeatAll">All</button>
            <button class="mini-btn" id="btnFeatFirst3">First 3</button>
            <button class="mini-btn" id="btnFeatClear">Clear</button>
          </div>
        </div>

        <!-- Results -->
        <div class="sidebar-card">
          <h3>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 20V10"/>
              <path d="M18 20V4"/>
              <path d="M6 20v-4"/>
            </svg>
            Results
          </h3>
          <div class="stats-grid">
            <div class="stats-row">
              <span class="stats-label">Clusters</span>
              <span class="stats-val" id="statClusters">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Noise Points</span>
              <span class="stats-val" id="statNoise">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Core Points</span>
              <span class="stats-val" id="statCore">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Border Points</span>
              <span class="stats-val" id="statBorder">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Used Rows</span>
              <span class="stats-val" id="statUsed">‚Äî</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Runtime</span>
              <span class="stats-val" id="statRuntime">‚Äî</span>
            </div>
          </div>

          <!-- K-Distance Plot -->
          <div class="kdist-container">
            <h4 style="font-size: 0.8rem; margin: 12px 0 8px 0; color: var(--text-secondary);">K-Distance Plot</h4>
            <canvas id="kdistCanvas"></canvas>
            <p class="kdist-hint">Elbow point suggests optimal Œµ value</p>
          </div>
        </div>

        <!-- Cluster Quality Metrics Card -->
        <div class="metrics-card" id="metricsCard">
          <div class="metrics-header" onclick="CLUSTER_METRICS.toggleMetrics()">
            <span class="collapse-icon" id="metricsCollapseIcon">‚ñº</span>
            <h3>Cluster Quality Metrics</h3>
            <label class="inline-check" onclick="event.stopPropagation()">
              <input type="checkbox" id="showMetricTiming" onchange="if(CLUSTER_METRICS.lastMetrics) CLUSTER_METRICS.renderMetricsPanel(CLUSTER_METRICS.lastMetrics)">
              <span style="font-size: 0.7rem">Timing</span>
            </label>
          </div>
          <div id="metricsContent" style="display: block;">
            <div class="no-data">Run DBSCAN to see metrics</div>
          </div>
        </div>
      </div>

      <!-- Metrics Help Modal -->
      <div id="metricsHelpModal" onclick="if(event.target === this) CLUSTER_METRICS.hideMetricsHelp()">
        <div class="metrics-help-content">
          <h2>Understanding Cluster Quality Metrics</h2>
          
          <div class="help-metric">
            <h3>Silhouette Score</h3>
            <p>Measures how similar each point is to its own cluster compared to other clusters. A point's silhouette value ranges from -1 to +1, where +1 means it's well-matched to its cluster and far from neighbors.</p>
            <div class="help-range">Range: -1 to +1 ‚Ä¢ Perfect: +1 ‚Ä¢ Higher is better</div>
          </div>
          
          <div class="help-metric">
            <h3>Davies-Bouldin Index</h3>
            <p>Measures the average "similarity" between each cluster and its most similar one. Similarity here is the ratio of within-cluster distances to between-cluster distances. Lower values indicate better separation.</p>
            <div class="help-range">Range: 0 to ‚àû ‚Ä¢ Perfect: 0 ‚Ä¢ Lower is better</div>
          </div>
          
          <div class="help-metric">
            <h3>Calinski-Harabasz Index</h3>
            <p>Also called the Variance Ratio Criterion. Measures the ratio of between-cluster dispersion to within-cluster dispersion. Higher values suggest dense, well-separated clusters. Best used for comparing different parameter choices.</p>
            <div class="help-range">Range: 0 to ‚àû ‚Ä¢ Higher is better ‚Ä¢ Compare relatively</div>
          </div>
          
          <div class="help-metric">
            <h3>DBCV (Density-Based Clustering Validation)</h3>
            <p>Specifically designed for density-based clustering like DBSCAN. Considers the density structure of clusters rather than just distances. Uses mutual reachability distances to assess cluster quality.</p>
            <div class="help-range">Range: -1 to +1 ‚Ä¢ Perfect: +1 ‚Ä¢ Higher is better</div>
          </div>
          
          <div class="help-metric">
            <h3>Noise Ratio</h3>
            <p>The fraction of points classified as noise. Some noise is normal for real-world data (1-10%). Very low noise might mean Œµ is too large; very high noise might mean Œµ is too small or min_pts too high.</p>
            <div class="help-range">Range: 0% to 100% ‚Ä¢ Ideal: 1-10% for most data</div>
          </div>
          
          <div class="help-metric">
            <h3>Size CV (Coefficient of Variation)</h3>
            <p>Measures how balanced your cluster sizes are. Low values mean clusters are similarly sized. High values indicate one dominant cluster or many tiny fragments, which might warrant parameter adjustment.</p>
            <div class="help-range">Range: 0 to ‚àû ‚Ä¢ Perfect: 0 ‚Ä¢ Lower is better</div>
          </div>
          
          <p style="margin-top: 20px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; font-size: 0.8rem; color: var(--text-muted);">
            üí° <strong>Tip:</strong> No single metric tells the whole story. Use these together with visual inspection. Different metrics may disagree! That's normal and reflects different aspects of clustering quality.
          </p>
          
          <button class="tool-btn primary help-close-btn" onclick="CLUSTER_METRICS.hideMetricsHelp()">Got it</button>
        </div>
      </div>
      <!-- =========================================================
     DBSCAN Educational Section (foldable + referenced 12.24.25)
     Self-contained: uses <details> (no JS required).
      //Yes, this code is messy. But it works and works fast at this point and I'm
      not particularly keen on doing housekeeping right now since I finally got it to
      work after some time. I'll keep segmented css for now, no matter how cursed
      it is for someone to read it.
========================================================= -->
<style>
  /* --- DBSCAN info section styling --- */
  .dbscan-info {
    margin-top: 18px;
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 14px;
    overflow: hidden;
    background: rgba(255,255,255,0.03);
  }
  .dbscan-info details {
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  .dbscan-info details:first-child {
    border-top: none;
  }
  .dbscan-info summary {
    list-style: none;
    cursor: pointer;
    padding: 14px 16px;
    font-weight: 650;
    letter-spacing: 0.2px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    user-select: none;
  }
  .dbscan-info summary::-webkit-details-marker { display: none; }
  .dbscan-info .chev {
    width: 18px;
    height: 18px;
    opacity: 0.85;
    flex: 0 0 auto;
    transform: rotate(0deg);
    transition: transform 160ms ease;
  }
  .dbscan-info details[open] .chev { transform: rotate(180deg); }

  .dbscan-info .content {
    padding: 0 16px 16px 16px;
    color: rgba(255,255,255,0.90);
    line-height: 1.55;
    font-size: 0.98rem;
  }
  .dbscan-info .content h3 {
    margin: 14px 0 8px 0;
    font-size: 1.05rem;
  }
  .dbscan-info .content p {
    margin: 8px 0;
  }
  .dbscan-info .content ul,
  .dbscan-info .content ol {
    margin: 8px 0 8px 18px;
  }
  .dbscan-info code,
  .dbscan-info pre {
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
  }
  .dbscan-info code {
    padding: 2px 6px;
  }
  .dbscan-info pre {
    padding: 10px 12px;
    overflow-x: auto;
  }
  .dbscan-info .refs {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px dashed rgba(255,255,255,0.18);
    font-size: 0.92rem;
    opacity: 0.95;
  }
  .dbscan-info .refs ol {
    margin-left: 18px;
  }
  .dbscan-info .refs a {
    color: inherit;
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  .dbscan-info .callout {
    margin: 10px 0;
    padding: 10px 12px;
    border-left: 3px solid rgba(120,200,255,0.8);
    background: rgba(120,200,255,0.08);
    border-radius: 10px;
  }
  .dbscan-info .warn {
    border-left-color: rgba(255,170,80,0.95);
    background: rgba(255,170,80,0.08);
  }
  /* Light theme adjustments */
  [data-theme="light"] .dbscan-info {
    border-color: rgba(0,0,0,0.10);
    background: rgba(0,0,0,0.02);
  }
  [data-theme="light"] .dbscan-info details {
    border-top-color: rgba(0,0,0,0.08);
  }
  [data-theme="light"] .dbscan-info .content {
    color: rgba(0,0,0,0.85);
  }
  [data-theme="light"] .dbscan-info code,
  [data-theme="light"] .dbscan-info pre {
    background: rgba(0,0,0,0.05);
    border-color: rgba(0,0,0,0.10);
  }
  [data-theme="light"] .dbscan-info .callout {
    border-left-color: rgba(0,100,200,0.7);
    background: rgba(0,100,200,0.06);
  }
  [data-theme="light"] .dbscan-info .warn {
    border-left-color: rgba(200,120,0,0.8);
    background: rgba(200,120,0,0.06);
  }
  [data-theme="light"] .dbscan-info .refs {
    border-top-color: rgba(0,0,0,0.15);
  }
</style>

<section class="dbscan-info" aria-label="DBSCAN educational content">
  <!-- ===== Section 1 ===== -->
  <details>
    <summary>
      <span>DBSCAN: what it is, what it's used for, and why it's different</span>
      <svg class="chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
        <path d="M6 9l6 6 6-6"></path>
      </svg>
    </summary>

    <div class="content">
      <h3>What is DBSCAN?</h3>
      <p>
        <strong>DBSCAN</strong> (Density-Based Spatial Clustering of Applications with Noise) is a
        <em>density-based clustering</em> algorithm. Instead of forcing clusters to be ‚Äúround‚Äù (like k-means),
        it builds clusters by finding regions of high point density and expanding outward from them.
        Points that don't belong to any dense region are labeled as <strong>noise / outliers</strong>.
        <sup><a href="#ref-ester1996">[1]</a></sup><sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
      </p>

      <h3>What is it used for?</h3>
      <ul>
        <li>
          <strong>Arbitrary-shape clusters:</strong> long streaks, rings, blobs, multi-lobed shapes
          (not just spherical clusters). <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          <strong>Outlier detection:</strong> ‚Äúnoise points‚Äù are explicitly labeled (often <code>-1</code> in libraries).
          <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
        <li>
          <strong>No need to pre-pick ‚Äúk‚Äù clusters:</strong> you don't specify the number of clusters in advance.
          <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
      </ul>

      <div class="callout warn">
        <strong>Important limitation:</strong> DBSCAN works best when clusters have <em>similar density</em>.
        If one cluster is very dense and another is very sparse, a single global <code>eps</code> can be too small
        for the sparse cluster (it becomes ‚Äúnoise‚Äù), or too large and merges clusters that should be separate.
        <sup><a href="#ref-sklearn-dbscan">[3]</a></sup><sup><a href="#ref-ester1996">[1]</a></sup>
      </div>

      <h3>How many dimensions can DBSCAN handle?</h3>
      <p>
        DBSCAN is not limited to 2D plots. It works on data with <strong>any number of features</strong>
        (dimensions) as long as you can define a distance / similarity measure and do neighborhood queries
        (‚Äúfind all points within <code>eps</code> of this point‚Äù). <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
      </p>
      <p>
        However, <strong>choosing <code>eps</code> becomes harder in high-dimensional data</strong>
        because distances can lose contrast (many points start to look similarly far apart),
        and that makes parameterization tricky. <sup><a href="#ref-schubert2017">[2]</a></sup>
      </p>

      <h3>Key concepts (the vocabulary you'll see everywhere)</h3>
      <ul>
        <li>
          <strong><code>eps</code>-neighborhood:</strong> all points within distance <code>eps</code> of a point.
          <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
        <li>
          <strong>Core point:</strong> has at least <code>minPts</code> points in its <code>eps</code>-neighborhood (most implementations, including this one, count the point itself).          <sup><a href="#ref-ester1996">[1]</a></sup><sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
        <li>
          <strong>Border point:</strong> is within <code>eps</code> of a core point, but does not itself have enough neighbors to be core.
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          <strong>Noise point:</strong> not density-reachable from any core region (doesn't belong to any cluster).
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          <strong>Density-reachable / density-connected:</strong> formal definitions that explain how clusters
          are ‚Äúgrown‚Äù through chains of core points (and attached border points).
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
      </ul>
    </div>
  </details>

  <!-- ===== Section 2 ===== -->
  <details>
    <summary>
      <span>How DBSCAN works + picking good parameters (k-distance ‚Äúelbow‚Äù for eps)</span>
      <svg class="chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
        <path d="M6 9l6 6 6-6"></path>
      </svg>
    </summary>

    <div class="content">
      <h3>Short walkthrough of the algorithm</h3>
      <p>
        DBSCAN can be understood as: ‚Äúfind dense seeds, then flood-fill density-connected points.‚Äù
        The original paper describes expanding a cluster starting from a seed point and repeatedly
        querying neighborhoods to grow the cluster. <sup><a href="#ref-ester1996">[1]</a></sup>
      </p>

      <ol>
        <li>
          <strong>Visit an unvisited point</strong> <code>p</code> and compute its neighbors within <code>eps</code>.
          <sup><a href="#ref-ester1996">[1]</a></sup><sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
        <li>
          If <code>p</code> has fewer than <code>minPts</code> neighbors, label it <strong>noise</strong>
          (it may later become a border point if reached by a nearby core).
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          If <code>p</code> is a <strong>core</strong> point, start a new cluster and put its neighbors into a ‚Äúseed list/queue‚Äù.
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          <strong>Expand the cluster:</strong> pop a point from the seed list; if it is core, add its neighbors to the seed list.
          Continue until the seed list is empty (cluster cannot expand further).
          <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
        <li>
          Repeat until all points are visited. <sup><a href="#ref-ester1996">[1]</a></sup>
        </li>
      </ol>

      <div class="callout">
        <strong>Why it finds arbitrary shapes:</strong> the cluster grows through
        <em>chains</em> of density-reachable core points. This is why a ring can be found as one cluster even though
        it is not ‚Äúround‚Äù in the k-means sense. <sup><a href="#ref-ester1996">[1]</a></sup>
      </div>

      <h3>The two parameters that matter: <code>minPts</code> and <code>eps</code></h3>
      <p>
        Most DBSCAN implementations expose:
      </p>
      <ul>
        <li>
          <strong><code>minPts</code> (a.k.a. <code>min_samples</code>):</strong>
          how many points must be inside the <code>eps</code>-neighborhood for a point to count as core.
          Larger values demand denser clusters; smaller values allow sparser clusters.
          <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
        <li>
          <strong><code>eps</code>:</strong>
          the maximum distance at which two points are considered neighbors (used for all neighborhood queries).
          This is the most sensitive parameter; smaller values typically yield more (and smaller) clusters.
          <sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
      </ul>

      <h3>Picking <code>minPts</code> (practical guidance)</h3>
      <ul>
        <li>
          In many datasets, <code>minPts</code> can stay near a small default value (e.g., 4 in 2D is cited as a common default).
          <sup><a href="#ref-schubert2017">[2]</a></sup>
        </li>
        <li>
          A commonly suggested heuristic is <code>minPts = 2 * dim</code> (twice the dataset dimensionality).
          If you have more noise, huge datasets, high dimensions, or duplicates, increasing <code>minPts</code> can help.
          <sup><a href="#ref-schubert2017">[2]</a></sup>
        </li>
      </ul>

      <h3>Picking <code>eps</code> using a k-distance plot (the ‚Äúelbow‚Äù idea)</h3>
      <p>
        A standard heuristic is to compute a <strong>k-distance plot</strong>:
        for each point, compute the distance to its k-th nearest neighbor, then sort these distances and plot them.
        The original DBSCAN paper discusses choosing <code>eps</code> using k-nearest-neighbor distances
        (for 2D, it describes using the distance to the 4th nearest neighbor as a heuristic). <sup><a href="#ref-schubert2017">[2]</a></sup>
      </p>

      <p>
        In DBSCAN ‚Äúparameter heuristics‚Äù discussions, a common mapping is:
        <code>k</code> corresponds to <code>minPts = k + 1</code> (because range queries include the point itself),
        so if you pick <code>minPts</code>, you often use <code>k = minPts - 1</code> in the k-distance plot.
        <sup><a href="#ref-schubert2017">[2]</a></sup>
      </p>

      <pre><code>k-distance plot recipe (high level)

1) Choose minPts (or try a few values)
2) For each point i:
     di = distance_to_kth_nearest_neighbor(i, k=minPts-1)
3) Sort {di} from largest to smallest (or smallest to largest - just be consistent)
4) Look for the ‚Äúknee/elbow‚Äù:
     - left side: steep region (very isolated points / noise)
     - right side: flatter region (dense interiors)
5) Pick eps near the knee (often slightly below it)
</code></pre>

      <div class="callout warn">
        <strong>Reality check:</strong> sometimes there is no clear ‚Äúvalley / knee / elbow.‚Äù
        In that case, you're effectively choosing a trade-off.
        Experience often favors the lower end of the plausible range (smaller <code>eps</code>) to avoid merging clusters.
        <sup><a href="#ref-schubert2017">[2]</a></sup>
      </div>

      <h3>When DBSCAN becomes annoying</h3>
      <ul>
        <li>
          <strong>High-dimensional data:</strong> selecting <code>eps</code> becomes difficult as distance contrast degrades.
          Alternatives like OPTICS / HDBSCAN* remove the need to choose a single global <code>eps</code>
          (though high dimensionality is still hard in general). <sup><a href="#ref-schubert2017">[2]</a></sup>
        </li>
        <li>
          <strong>Mixed densities:</strong> one global <code>eps</code> can cause sparse clusters to disappear or dense clusters to merge.
          <sup><a href="#ref-ester1996">[1]</a></sup><sup><a href="#ref-sklearn-dbscan">[3]</a></sup>
        </li>
      </ul>

      <!-- ===== References ===== -->
      <div class="refs">
        <h3>References</h3>
        <ol>
          <li id="ref-ester1996">
            Ester, M., Kriegel, H.-P., Sander, J., &amp; Xu, X. (1996).
            <em>A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</em>.
            KDD '96. (DBSCAN original paper)
            -
            <a href="https://file.biolab.si/papers/1996-DBSCAN-KDD.pdf" target="_blank" rel="noopener noreferrer">PDF</a>
          </li>
          <li id="ref-schubert2017">
            Schubert, E., Sander, J., Ester, M., Kriegel, H.-P., &amp; Xu, X. (2017).
            <em>DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN</em>.
            ACM TODS, 42(3).
            (Parameter heuristics + k-distance plots + high-dimensional caveats)
            -
            <a href="https://doi.org/10.1145/3068335" target="_blank" rel="noopener noreferrer">DOI</a>
            -
            <a href="https://www.khoury.northeastern.edu/home/vip/teach/DMcourse/2_cluster_EM_mixt/notes_slides/revisitofrevisitDBSCAN.pdf" target="_blank" rel="noopener noreferrer">PDF</a>
          </li>
          <li id="ref-sklearn-dbscan">
            scikit-learn documentation:
            <em>sklearn.cluster.DBSCAN</em> (eps/min_samples definitions, behavior notes, references).
            -
            <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" target="_blank" rel="noopener noreferrer">Docs</a>
          </li>
        </ol>
      </div>
    </div>
  </details>

  <!-- ===== Section 3: Use Cases ===== -->
  <details>
    <summary>
      <span>Real-world applications: medicine, imaging, engineering, and science</span>
      <svg class="chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
        <path d="M6 9l6 6 6-6"></path>
      </svg>
    </summary>

    <div class="content">
      <p>
        DBSCAN's ability to find arbitrarily shaped clusters and explicitly identify outliers makes it valuable
        across many domains. Below are representative applications organized by field.
      </p>

      <h3>Medicine &amp; Healthcare</h3>
      <ul>
        <li>
          <strong>Disease outbreak detection:</strong> Identifying spatial clusters of disease cases
          (e.g., COVID-19 hotspots, cancer clusters) where the shape of the outbreak region is unknown
          and isolated cases should be flagged as noise.
        </li>
        <li>
          <strong>Patient stratification:</strong> Grouping patients by clinical biomarkers (lab values, vitals)
          to discover phenotypes or subtypes of a disease without assuming how many groups exist.
        </li>
        <li>
          <strong>Anomaly detection in ECG/EEG signals:</strong> After feature extraction, DBSCAN can identify
          abnormal heartbeat or brainwave patterns as noise points distinct from normal clusters.
        </li>
        <li>
          <strong>Genomics:</strong> Clustering gene expression profiles or single-cell RNA-seq data to identify
          cell types or states, where cluster shapes in high-dimensional space are non-spherical.
        </li>
      </ul>

      <h3>Image Processing &amp; Computer Vision</h3>
      <ul>
        <li>
          <strong>Image segmentation:</strong> Grouping pixels by color/texture similarity in LAB or RGB space
          to segment objects without predefined region shapes.
        </li>
        <li>
          <strong>Object detection preprocessing:</strong> Clustering keypoints or feature descriptors
          (e.g., SIFT, ORB) to identify distinct objects in a scene.
        </li>
        <li>
          <strong>LiDAR point cloud processing:</strong> Segmenting 3D point clouds from autonomous vehicles
          or drones to identify objects (cars, pedestrians, buildings) with irregular shapes.
        </li>
        <li>
          <strong>Medical imaging:</strong> Detecting tumors or lesions in CT/MRI scans by clustering
          voxel intensities, where tumor boundaries are irregular.
        </li>
        <li>
          <strong>Satellite imagery:</strong> Identifying land-use regions, urban sprawl patterns,
          or deforestation areas from multispectral image features.
        </li>
      </ul>

      <h3>Engineering &amp; Manufacturing</h3>
      <ul>
        <li>
          <strong>Predictive maintenance:</strong> Clustering sensor readings (vibration, temperature, pressure)
          from industrial equipment to detect anomalous operating states before failure.
        </li>
        <li>
          <strong>Quality control:</strong> Identifying defective products on an assembly line by clustering
          measurement data; outliers represent manufacturing defects.
        </li>
        <li>
          <strong>Network intrusion detection:</strong> Clustering network traffic patterns to identify
          normal behavior clusters and flag anomalous (potentially malicious) traffic as noise.
        </li>
        <li>
          <strong>Structural health monitoring:</strong> Analyzing strain gauge or accelerometer data
          from bridges, buildings, or aircraft to detect damage patterns.
        </li>
        <li>
          <strong>Semiconductor manufacturing:</strong> Clustering wafer test data to identify
          process drifts or equipment issues affecting chip yield.
        </li>
      </ul>

      <h3>Scientific Research</h3>
      <ul>
        <li>
          <strong>Astronomy:</strong> Identifying galaxy clusters, star clusters, or cosmic structures
          from survey data where cluster shapes are highly irregular.
        </li>
        <li>
          <strong>Particle physics:</strong> Clustering particle tracks or energy deposits in detectors
          to reconstruct collision events and identify anomalous signatures.
        </li>
        <li>
          <strong>Climate science:</strong> Grouping weather stations or grid cells by climate patterns
          to identify climate zones or detect unusual weather events.
        </li>
        <li>
          <strong>Ecology:</strong> Clustering animal GPS tracks to identify home ranges, migration corridors,
          or unusual movement patterns indicating distress.
        </li>
        <li>
          <strong>Chemistry/Materials science:</strong> Clustering molecular simulations or spectroscopy data
          to identify distinct molecular conformations or material phases.
        </li>
      </ul>

      <h3>Business &amp; Social Science</h3>
      <ul>
        <li>
          <strong>Customer segmentation:</strong> Grouping customers by purchasing behavior or demographics
          without assuming the number of segments.
        </li>
        <li>
          <strong>Fraud detection:</strong> Identifying unusual transaction patterns in banking or insurance
          as outliers from normal behavior clusters.
        </li>
        <li>
          <strong>Social network analysis:</strong> Detecting communities in social graphs or identifying
          bot accounts as anomalies in user behavior feature space.
        </li>
        <li>
          <strong>Urban planning:</strong> Clustering GPS or mobile phone data to identify activity centers,
          commuting patterns, or underserved areas.
        </li>
      </ul>

      <div class="callout">
        <strong>Why DBSCAN for these applications?</strong>
        <ul style="margin-top: 8px;">
          <li>No need to specify the number of clusters in advance</li>
          <li>Can find clusters of arbitrary shape (not just spherical)</li>
          <li>Built-in outlier detection (noise points)</li>
          <li>Robust to outliers-they don't distort cluster centers</li>
          <li>Deterministic results (unlike k-means with random initialization)</li>
        </ul>
      </div>

      <div class="callout warn">
        <strong>When to consider alternatives:</strong>
        <ul style="margin-top: 8px;">
          <li><strong>Varying density clusters:</strong> Use HDBSCAN or OPTICS instead</li>
          <li><strong>Very high dimensions:</strong> Consider dimensionality reduction first (PCA, UMAP)</li>
          <li><strong>Massive datasets:</strong> Use approximate methods or spatial indexing (this tool uses a KD-tree)</li>
          <li><strong>Streaming data:</strong> Consider incremental variants like DenStream</li>
        </ul>
      </div>
    </div>
  </details>

  <!-- ===== Section 4: Technical Design Overview ===== -->
  <details>
    <summary>
      <span>Technical Design Overview: Architecture &amp; Implementation</span>
      <svg class="chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
        <path d="M6 9l6 6 6-6"></path>
      </svg>
    </summary>

    <div class="content">
      <p>
        This visualizer combines <strong>Rust/WebAssembly</strong> for high-performance clustering with 
        <strong>JavaScript</strong> for UI orchestration and <strong>HTML5 Canvas</strong> for rendering.
        Clustering results are validated against <code>sklearn.cluster.DBSCAN</code> via Python backchecks.
      </p>

      <h3>Architecture</h3>
      <p>
        The application runs entirely in the browser across three layers: the <strong>UI layer</strong> 
        (HTML/CSS) handles user input, visualization, and theming. The <strong>JavaScript orchestrator</strong> 
        manages CSV parsing, data preparation, animation state, and coordinates calls to WebAssembly. 
        The <strong>Rust/WASM compute core</strong> performs all the heavy lifting including KD-tree construction, 
        DBSCAN clustering, core/border classification, and all metric calculations. Data passes between 
        JavaScript and WASM via shared <code>Float32Array</code> buffers.
      </p>
      <p>
        Separately, a Python validation script using scikit-learn verifies that WASM outputs match 
        sklearn's DBSCAN exactly.
      </p>

      <h3>Technology Stack</h3>
      <table style="width:100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
        <thead>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Layer</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Technology</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">UI</td>
            <td style="padding: 8px;">HTML5, CSS3, Canvas API</td>
            <td style="padding: 8px;">User input, visualization, theming</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">Orchestrator</td>
            <td style="padding: 8px;">JavaScript (ES6+)</td>
            <td style="padding: 8px;">Data parsing, state management, WASM calls</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">Compute Core</td>
            <td style="padding: 8px;">Rust -> WebAssembly</td>
            <td style="padding: 8px;">Clustering, metrics, spatial indexing (KD-tree)</td>
          </tr>
          <tr>
            <td style="padding: 8px;">Validation</td>
            <td style="padding: 8px;">Python + scikit-learn</td>
            <td style="padding: 8px;">Correctness verification against sklearn</td>
          </tr>
        </tbody>
      </table>

      <h3>Performance</h3>
      <p>
        Rust/WASM provides roughly <strong>10√ó speedup</strong> over pure JavaScript for clustering operations. 
        On a 30,000-point dataset, JavaScript takes ~6,200ms while Rust/WASM completes in ~600ms. This is arbitrary
        since I put a lot more effort into the Rust code compared to the JS code. 
      </p>

      <h3>Data Flow</h3>
      <p>
        CSV files are parsed in JavaScript, where users select numeric columns for clustering. 
        The selected features are flattened into a row-major <code>Float32Array</code> and passed 
        across the WASM boundary. The Rust core handles missing values (drop, impute, or fail), 
        optionally standardizes features via z-score normalization, builds a KD-tree for efficient 
        neighbor queries, runs DBSCAN, and returns cluster labels plus quality metrics back to JavaScript 
        for rendering on the canvas.
      </p>

      <h3>Key Implementation Details</h3>
      <ul>
        <li>
          <strong>KD-Tree spatial index:</strong> O(n log n) average-case neighbor queries vs O(n^2) brute force.
        </li>
        <li>
          <strong>f64 distance calculations:</strong> 64-bit float precision internally achieves 100% cluster 
          assignment match with sklearn.
        </li>
        <li>
          <strong>Missing value policies:</strong> Drop rows, impute with column mean, or fail on NaN.
        </li>
        <li>
          <strong>Standardization:</strong> Optional z-score normalization computed on used rows only.
        </li>
      </ul>

      <h3>Clustering Quality Metrics</h3>
      <p>Computed in the WASM core:</p>
      <ul>
        <li><strong>Silhouette Score:</strong> Cluster cohesion and separation (-1 to +1)</li>
        <li><strong>Davies-Bouldin Index:</strong> Average cluster similarity (lower = better)</li>
        <li><strong>Calinski-Harabasz Index:</strong> Between/within cluster dispersion ratio (higher = better)</li>
        <li><strong>DBCV:</strong> Density-Based Clustering Validation, designed for DBSCAN</li>
        <li><strong>Noise Ratio &amp; Cluster Size CV:</strong> Distribution diagnostics</li>
      </ul>

      <div class="callout">
        <strong>Validation:</strong> Outputs are verified against <code>sklearn.cluster.DBSCAN</code> 
        using permutation-invariant comparison. Expected: ARI &gt;0.99, AMI &gt;0.96, exact match rate &gt;0.98.
      </div>

      <h3>Tradeoffs</h3>
      <table style="width:100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
        <thead>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Decision</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Benefit</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Cost</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">f32 storage, f64 compute</td>
            <td style="padding: 8px;">Memory efficiency</td>
            <td style="padding: 8px;">Cast overhead (~negligible)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">Sampled Silhouette</td>
            <td style="padding: 8px;">Fast for large datasets</td>
            <td style="padding: 8px;">Slight variance</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">Single-threaded WASM</td>
            <td style="padding: 8px;">Wider browser support</td>
            <td style="padding: 8px;">No parallelism</td>
          </tr>
          <tr>
            <td style="padding: 8px;">KD-tree (not ball-tree)</td>
            <td style="padding: 8px;">Simpler implementation</td>
            <td style="padding: 8px;">Less optimal for high dims</td>
          </tr>
        </tbody>
      </table>

      <h3>Scalability</h3>
      <table style="width:100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
        <thead>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Points</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Time</th>
            <th style="text-align: left; padding: 8px; color: var(--accent-primary);">Recommendation</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">&lt;10K</td>
            <td style="padding: 8px;">&lt;100ms</td>
            <td style="padding: 8px;">Full metrics</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">10K-50K</td>
            <td style="padding: 8px;">100ms-1s</td>
            <td style="padding: 8px;">Full metrics</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border-color);">
            <td style="padding: 8px;">50K-100K</td>
            <td style="padding: 8px;">1-5s</td>
            <td style="padding: 8px;">Consider disabling DBCV</td>
          </tr>
          <tr>
            <td style="padding: 8px;">&gt;100K</td>
            <td style="padding: 8px;">&gt;5s</td>
            <td style="padding: 8px;">Consider chunking</td>
          </tr>
        </tbody>
      </table>

      <div class="callout warn">
        <strong>Browser Compatibility:</strong> Requires WebAssembly (Chrome 57+, Firefox 52+, Safari 11+, Edge 16+).
      </div>

      <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 20px;">
        <em>Version 2.1.1 - Feel free to find me on LinkedIn or email me at jesse@jesse-anderson.net if you'd like to discuss further.</em>
      </p>
    </div>
  </details>


</section>

    </div>
  </main>

  <footer data-footer></footer>
</div>

<script src="../js/shared.js"></script>
<script src="../js/footer.js"></script>
<script src="../js/DBSCAN/cluster_metrics_ui.js"></script>
<script type="module">
//I can't wait to botch the cloudflare upload to make this work.

const VERSION = "2.0.0";
// Polyfill for CanvasRenderingContext2D.roundRect (older browsers)
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
    else r = { tl: r[0] || 0, tr: r[1] || r[0] || 0, br: r[2] || r[0] || 0, bl: r[3] || r[1] || r[0] || 0 };
    this.moveTo(x + r.tl, y);
    this.lineTo(x + w - r.tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    this.lineTo(x + w, y + h - r.br);
    this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    this.lineTo(x + r.bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    this.lineTo(x, y + r.tl);
    this.quadraticCurveTo(x, y, x + r.tl, y);
    this.closePath();
    return this;
  };
}
// DOM Elements
const el = id => document.getElementById(id);

// State
const STATE = {
  filename: null,
  header: [],
  rows: [],
  numericIdx: [],
  selectedFeatures: [],
  lastResult: null,
  plotData: null, // For plotting without clustering
  classification: null, // Core/border/noise classification
  hasAnimationData: false, // Whether animation trace data exists
  kDistData: null, // For redrawing k-distance plot on theme change
  renderQuality: 'high', // 'high', 'medium', 'low'
  lastInteraction: 0,
  depthCache: null, // For 3D rendering optimization

  // Animation state
  anim: {
    running: false,
    paused: false,
    events: [],
    currentStep: 0,
    labels: null,
    points2d: null,
    points3d: null,
    corePoints: new Set(),
    borderPoints: new Set(),
    neighborSet: new Set(),
    currentPoint: -1,
    raf: null,
    speed: 1.0,
    eps: 0.5,
    means: null,
    stds: null,
    // Dimension mismatch tracking
    clusteringDims: 0,        // Number of features used for clustering
    plottedFeatures: [],      // Which features are being plotted [colX, colY, colZ?]
    clusteringFeatures: [],   // Which features were used for clustering
    dimensionMismatch: false  // True if plot axes don't match clustering features
  },
  
  // 2D view state (pan/zoom)
  view2d: {
    panX: 0,
    panY: 0,
    dragging: false,
    lastX: 0,
    lastY: 0
  },
  
  // 3D view state
  view3d: {
    yaw: 0.5,
    pitch: 0.3,
    zoom: 1.0,
    panX: 0,
    panY: 0,
    dragging: false,
    panning: false,
    lastX: 0,
    lastY: 0
  }
};

// WASM API placeholder
let wasmApi = null;
let engineMode = "unknown"; // "wasm" or "js-fallback"

// ============================================
// Cluster Quality Metrics Module
// ============================================

const CLUSTER_METRICS = (function() {
  // Metric flags (must match Rust constants)
  const METRIC_FLAGS = {
    SILHOUETTE: 1,
    DAVIES_BOULDIN: 2,
    CALINSKI_HARABASZ: 4,
    DBCV: 8,
    NOISE_RATIO: 16,
    SIZE_CV: 32,
    PER_CLUSTER: 64,
    ALL: 127
  };

  // Metric configuration with thresholds and display info
  const METRIC_CONFIG = {
    silhouette: {
      name: "Silhouette Score",
      flag: METRIC_FLAGS.SILHOUETTE,
      description: "How well points fit their cluster vs. neighboring clusters",
      range: [-1, 1],
      thresholds: [
        { max: -0.25, label: "Poor", class: "poor" },
        { max: 0.25, label: "Weak", class: "weak" },
        { max: 0.5, label: "Fair", class: "fair" },
        { max: 0.7, label: "Good", class: "good" },
        { max: 1.01, label: "Strong", class: "strong" }
      ],
      perfect: 1.0,
      format: v => v.toFixed(3),
      higherIsBetter: true,
      defaultEnabled: false
    },
    davies_bouldin: {
      name: "Davies-Bouldin",
      flag: METRIC_FLAGS.DAVIES_BOULDIN,
      description: "Ratio of within-cluster scatter to between-cluster separation",
      range: [0, 3],
      thresholds: [
        { max: 0.4, label: "Excellent", class: "strong" },
        { max: 0.7, label: "Good", class: "good" },
        { max: 1.0, label: "Fair", class: "fair" },
        { max: 1.5, label: "Weak", class: "weak" },
        { max: Infinity, label: "Poor", class: "poor" }
      ],
      perfect: 0.0,
      format: v => v.toFixed(3),
      higherIsBetter: false,
      defaultEnabled: true
    },
    calinski_harabasz: {
      name: "Calinski-Harabasz",
      flag: METRIC_FLAGS.CALINSKI_HARABASZ,
      description: "Ratio of between-cluster to within-cluster variance",
      range: [0, null],
      thresholds: null,
      perfect: Infinity,
      format: v => v >= 10000 ? v.toExponential(2) : v.toFixed(1),
      higherIsBetter: true,
      relativeNote: "Compare across different parameters",
      defaultEnabled: true
    },
    dbcv: {
      name: "DBCV",
      flag: METRIC_FLAGS.DBCV,
      description: "Density-based clustering validation (designed for DBSCAN)",
      range: [-1, 1],
      thresholds: [
        { max: -0.25, label: "Poor", class: "poor" },
        { max: 0.0, label: "Weak", class: "weak" },
        { max: 0.25, label: "Fair", class: "fair" },
        { max: 0.5, label: "Good", class: "good" },
        { max: 1.01, label: "Strong", class: "strong" }
      ],
      perfect: 1.0,
      format: v => v.toFixed(3),
      higherIsBetter: true,
      defaultEnabled: false
    },
    noise_ratio: {
      name: "Noise Ratio",
      flag: METRIC_FLAGS.NOISE_RATIO,
      description: "Fraction of points classified as noise",
      range: [0, 1],
      thresholds: [
        { max: 0.01, label: "Very Low", class: "weak" },
        { max: 0.05, label: "Low", class: "good" },
        { max: 0.15, label: "Normal", class: "fair" },
        { max: 0.30, label: "High", class: "weak" },
        { max: 1.01, label: "Very High", class: "poor" }
      ],
      perfect: null,
      format: v => (v * 100).toFixed(1) + "%",
      higherIsBetter: null,
      defaultEnabled: true
    },
    size_cv: {
      name: "Size CV",
      flag: METRIC_FLAGS.SIZE_CV,
      description: "Coefficient of variation in cluster sizes",
      range: [0, 2],
      thresholds: [
        { max: 0.3, label: "Balanced", class: "strong" },
        { max: 0.6, label: "Moderate", class: "good" },
        { max: 1.0, label: "Varied", class: "fair" },
        { max: 1.5, label: "Imbalanced", class: "weak" },
        { max: Infinity, label: "Highly Imbalanced", class: "poor" }
      ],
      perfect: 0.0,
      format: v => v.toFixed(3),
      higherIsBetter: false,
      defaultEnabled: true
    }
  };

  // State
  let metricsCollapsed = false;
  let perClusterCollapsed = true;
  let metricsSettingsCollapsed = false;
  let lastMetrics = null;
  let enabledMetrics = {};

  // Initialize enabled metrics from config
  function initEnabledMetrics() {
    for (const [key, config] of Object.entries(METRIC_CONFIG)) {
      enabledMetrics[key] = config.defaultEnabled;
    }
    enabledMetrics.per_cluster = true;
  }
  initEnabledMetrics();

  // Get enabled metric flags
  function getMetricFlags() {
    let flags = 0;
    for (const [key, config] of Object.entries(METRIC_CONFIG)) {
      if (enabledMetrics[key]) {
        flags |= config.flag;
      }
    }
    if (enabledMetrics.per_cluster) {
      flags |= METRIC_FLAGS.PER_CLUSTER;
    }
    return flags;
  }

  // Helper functions
  function getMetricClass(metricKey, value) {
    const config = METRIC_CONFIG[metricKey];
    if (!config || !config.thresholds || !isFinite(value)) {
      return "";
    }
    
    for (const threshold of config.thresholds) {
      if (value <= threshold.max) {
        return threshold.class;
      }
    }
    return "";
  }

  function getMetricLabel(metricKey, value) {
    const config = METRIC_CONFIG[metricKey];
    if (!config || !config.thresholds || !isFinite(value)) {
      return "";
    }
    
    for (const threshold of config.thresholds) {
      if (value <= threshold.max) {
        return threshold.label;
      }
    }
    return "";
  }

  function renderMetricBar(metricKey, value, computed) {
    if (!computed) {
      return '<div class="metric-bar"><div class="metric-bar-fill disabled" style="width: 0%"></div></div>';
    }
    
    const config = METRIC_CONFIG[metricKey];
    if (!config || !isFinite(value)) {
      return '<div class="metric-bar"><div class="metric-bar-fill" style="width: 0%"></div></div>';
    }
    
    const [min, max] = config.range;
    const effectiveMax = max ?? value * 1.5;
    
    let percent;
    if (config.higherIsBetter === false) {
      percent = Math.max(0, Math.min(100, (1 - (value - min) / (effectiveMax - min)) * 100));
    } else {
      percent = Math.max(0, Math.min(100, ((value - min) / (effectiveMax - min)) * 100));
    }
    
    const qualityClass = getMetricClass(metricKey, value);
    
    return `
      <div class="metric-bar">
        <div class="metric-bar-fill ${qualityClass}" style="width: ${percent}%"></div>
      </div>
    `;
  }

  function renderMetricRow(metricKey, value, computed, showTiming = false, timingMs = null) {
    const config = METRIC_CONFIG[metricKey];
    if (!config) return '';
    
    let displayValue;
    let qualityClass = '';
    let label = '';
    
    if (!computed) {
      displayValue = '<span class="metric-na">N/A</span>';
    } else if (!isFinite(value)) {
      displayValue = '‚Äî';
    } else {
      displayValue = config.format(value);
      qualityClass = getMetricClass(metricKey, value);
      label = getMetricLabel(metricKey, value);
    }
    
    const timingHtml = showTiming && timingMs !== null && computed
      ? `<span class="metric-timing">${timingMs.toFixed(1)}ms</span>` 
      : '';
    
    const labelHtml = label 
      ? `<span class="metric-quality ${qualityClass}">${label}</span>` 
      : '';
    
    const perfectHtml = config.perfect !== null && config.perfect !== Infinity && computed
      ? `<span class="metric-perfect" title="Perfect score">‚ü®${config.format(config.perfect)}‚ü©</span>`
      : '';
    
    const enabledClass = computed ? '' : 'disabled';
    
    return `
      <div class="metric-row ${enabledClass}" data-metric="${metricKey}">
        <div class="metric-header">
          <span class="metric-name">${config.name}</span>
          ${timingHtml}
        </div>
        <div class="metric-value-row">
          <span class="metric-value ${qualityClass}">${displayValue}</span>
          ${labelHtml}
          ${perfectHtml}
        </div>
        ${renderMetricBar(metricKey, value, computed)}
      </div>
    `;
  }

  function renderPerClusterTable(perCluster, computed) {
    if (!computed) {
      return '<div class="no-data">Per-cluster metrics disabled</div>';
    }
    
    if (!perCluster || perCluster.length === 0) {
      return '<div class="no-data">No cluster data</div>';
    }
    
    const rows = perCluster.map(cluster => {
      const silhouetteClass = getMetricClass('silhouette', cluster.silhouette);
      const silhouetteValue = isFinite(cluster.silhouette) 
        ? cluster.silhouette.toFixed(3) 
        : '‚Äî';
      
      return `
        <tr>
          <td><span class="cluster-badge" style="background: ${getClusterColorForMetrics(cluster.id)}">${cluster.id}</span></td>
          <td class="num">${cluster.size.toLocaleString()}</td>
          <td class="num ${silhouetteClass}">${silhouetteValue}</td>
          <td class="num">${cluster.avg_dist_to_centroid.toFixed(3)}</td>
          <td class="num">${cluster.max_dist_to_centroid.toFixed(3)}</td>
        </tr>
      `;
    }).join('');
    
    return `
      <table class="per-cluster-table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Size</th>
            <th>Silhouette</th>
            <th>Avg Dist</th>
            <th>Max Dist</th>
          </tr>
        </thead>
        <tbody>
          ${rows}
        </tbody>
      </table>
    `;
  }

  function renderTimingBreakdown(timing, metrics) {
    if (!timing) return '';
    
    const items = [
      { name: 'Silhouette', ms: timing.silhouette_ms, computed: metrics.silhouette_computed },
      { name: 'Davies-Bouldin', ms: timing.davies_bouldin_ms, computed: metrics.davies_bouldin_computed },
      { name: 'Calinski-Harabasz', ms: timing.calinski_harabasz_ms, computed: metrics.calinski_harabasz_computed },
      { name: 'DBCV', ms: timing.dbcv_ms, computed: metrics.dbcv_computed },
      { name: 'Per-cluster', ms: timing.per_cluster_ms, computed: metrics.per_cluster_computed },
    ].filter(item => item.computed && item.ms > 0.1);
    
    const total = timing.total_ms;
    
    if (items.length === 0) {
      return `
        <div class="timing-breakdown">
          <div class="timing-header">
            <span>Compute Time</span>
            <span class="timing-total">${total.toFixed(1)}ms</span>
          </div>
        </div>
      `;
    }
    
    return `
      <div class="timing-breakdown">
        <div class="timing-header">
          <span>Compute Time</span>
          <span class="timing-total">${total.toFixed(1)}ms</span>
        </div>
        <div class="timing-bar">
          ${items.map((item, idx) => {
            const pct = (item.ms / total) * 100;
            return `<div class="timing-segment timing-${idx}" style="width: ${pct}%" title="${item.name}: ${item.ms.toFixed(1)}ms"></div>`;
          }).join('')}
        </div>
      </div>
    `;
  }

  function renderMetricToggles() {
    const toggles = Object.entries(METRIC_CONFIG).map(([key, config]) => {
      const checked = enabledMetrics[key] ? 'checked' : '';
      return `
        <label class="metric-toggle">
          <input type="checkbox" data-metric="${key}" ${checked} onchange="CLUSTER_METRICS.toggleMetric('${key}', this.checked)">
          <span>${config.name}</span>
        </label>
      `;
    }).join('');
    
    const perClusterChecked = enabledMetrics.per_cluster ? 'checked' : '';
    
    return `
      <div class="metric-toggles-grid">
        ${toggles}
        <label class="metric-toggle">
          <input type="checkbox" data-metric="per_cluster" ${perClusterChecked} onchange="CLUSTER_METRICS.toggleMetric('per_cluster', this.checked)">
          <span>Per-Cluster Stats</span>
        </label>
      </div>
      <div class="metric-toggle-actions">
        <button class="mini-btn" onclick="CLUSTER_METRICS.enableAllMetrics()">Enable All</button>
        <button class="mini-btn" onclick="CLUSTER_METRICS.disableExpensiveMetrics()">Fast Only</button>
      </div>
    `;
  }

  // Render initial settings panel (before DBSCAN runs)
  function renderInitialSettingsPanel() {
    const container = document.getElementById('metricsContent');
    if (!container) return;
    
    const html = `
      <!-- Metric Settings - Always visible -->
      <div class="metrics-settings-section" style="border-bottom: none; margin-bottom: 0;">
        <div class="metrics-settings-header" onclick="CLUSTER_METRICS.toggleMetricsSettings()">
          <span class="collapse-icon" id="metricsSettingsIcon">${metricsSettingsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
          <span>Metric Settings</span>
        </div>
        <div class="metrics-settings-content" id="metricsSettingsContent" style="display: ${metricsSettingsCollapsed ? 'none' : 'block'}">
          ${renderMetricToggles()}
        </div>
      </div>
      
      <div class="no-data" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
        Run DBSCAN to see metric results
      </div>
    `;
    
    container.innerHTML = html;
  }

  function renderMetricsPanel(metrics) {
    lastMetrics = metrics;
    
    const container = document.getElementById('metricsContent');
    if (!container) return;
    
    const showTimingEl = document.getElementById('showMetricTiming');
    const showTiming = showTimingEl?.checked ?? false;
    
    const html = `
      <!-- Metric Settings -->
      <div class="metrics-settings-section">
        <div class="metrics-settings-header" onclick="CLUSTER_METRICS.toggleMetricsSettings()">
          <span class="collapse-icon" id="metricsSettingsIcon">${metricsSettingsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
          <span>Metric Settings</span>
        </div>
        <div class="metrics-settings-content" id="metricsSettingsContent" style="display: ${metricsSettingsCollapsed ? 'none' : 'block'}">
          ${renderMetricToggles()}
        </div>
      </div>
      
      <!-- Metrics Grid -->
      <div class="metrics-grid">
        ${renderMetricRow('silhouette', metrics.silhouette, metrics.silhouette_computed, showTiming, metrics.timing?.silhouette_ms)}
        ${renderMetricRow('davies_bouldin', metrics.davies_bouldin, metrics.davies_bouldin_computed, showTiming, metrics.timing?.davies_bouldin_ms)}
        ${renderMetricRow('calinski_harabasz', metrics.calinski_harabasz, metrics.calinski_harabasz_computed, showTiming, metrics.timing?.calinski_harabasz_ms)}
        ${renderMetricRow('dbcv', metrics.dbcv, metrics.dbcv_computed, showTiming, metrics.timing?.dbcv_ms)}
        ${renderMetricRow('noise_ratio', metrics.noise_ratio, metrics.noise_ratio_computed, showTiming, metrics.timing?.noise_ratio_ms)}
        ${renderMetricRow('size_cv', metrics.size_cv, metrics.size_cv_computed, showTiming, metrics.timing?.size_cv_ms)}
      </div>
      
      ${metrics.silhouette_computed && metrics.silhouette_samples && metrics.silhouette_samples <= 5000 ? `
        <div class="metrics-note">
          Silhouette computed on ${metrics.silhouette_samples.toLocaleString()} sampled points
        </div>
      ` : ''}
      
      ${showTiming ? renderTimingBreakdown(metrics.timing, metrics) : ''}
      
      <!-- Per-Cluster Section -->
      <div class="per-cluster-section">
        <div class="per-cluster-header" onclick="CLUSTER_METRICS.togglePerCluster()">
          <span class="collapse-icon">${perClusterCollapsed ? '‚ñ∂' : '‚ñº'}</span>
          <span>Per-Cluster Breakdown (${metrics.cluster_count} clusters)</span>
        </div>
        <div class="per-cluster-content" style="display: ${perClusterCollapsed ? 'none' : 'block'}">
          ${renderPerClusterTable(metrics.per_cluster, metrics.per_cluster_computed)}
        </div>
      </div>
      
      <button class="mini-btn metrics-help-btn" onclick="CLUSTER_METRICS.showMetricsHelp()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"></circle>
          <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
          <line x1="12" y1="17" x2="12.01" y2="17"></line>
        </svg>
        What do these mean?
      </button>
    `;
    
    container.innerHTML = html;
  }

  // Toggle functions
  function toggleMetrics() {
    metricsCollapsed = !metricsCollapsed;
    const content = document.getElementById('metricsContent');
    const icon = document.getElementById('metricsCollapseIcon');
    
    if (content) {
      content.style.display = metricsCollapsed ? 'none' : 'block';
    }
    if (icon) {
      icon.textContent = metricsCollapsed ? '‚ñ∂' : '‚ñº';
    }
  }

  function togglePerCluster() {
    perClusterCollapsed = !perClusterCollapsed;
    
    const content = document.querySelector('.per-cluster-content');
    const icon = document.querySelector('.per-cluster-header .collapse-icon');
    
    if (content) {
      content.style.display = perClusterCollapsed ? 'none' : 'block';
    }
    if (icon) {
      icon.textContent = perClusterCollapsed ? '‚ñ∂' : '‚ñº';
    }
  }

  function toggleMetricsSettings() {
    metricsSettingsCollapsed = !metricsSettingsCollapsed;
    
    const content = document.getElementById('metricsSettingsContent');
    const icon = document.getElementById('metricsSettingsIcon');
    
    if (content) {
      content.style.display = metricsSettingsCollapsed ? 'none' : 'block';
    }
    if (icon) {
      icon.textContent = metricsSettingsCollapsed ? '‚ñ∂' : '‚ñº';
    }
  }

  function toggleMetric(metricKey, enabled) {
    enabledMetrics[metricKey] = enabled;
  }

  function enableAllMetrics() {
    for (const key of Object.keys(METRIC_CONFIG)) {
      enabledMetrics[key] = true;
    }
    enabledMetrics.per_cluster = true;
    
    document.querySelectorAll('.metric-toggle input').forEach(cb => {
      cb.checked = true;
    });
  }

  function disableExpensiveMetrics() {
    enabledMetrics.silhouette = false;
    enabledMetrics.dbcv = false;
    enabledMetrics.davies_bouldin = true;
    enabledMetrics.calinski_harabasz = true;
    enabledMetrics.noise_ratio = true;
    enabledMetrics.size_cv = true;
    enabledMetrics.per_cluster = true;
    
    document.querySelectorAll('.metric-toggle input').forEach(cb => {
      const key = cb.dataset.metric;
      cb.checked = enabledMetrics[key];
    });
  }

  function showMetricsHelp() {
    const modal = document.getElementById('metricsHelpModal');
    if (modal) {
      modal.style.display = 'flex';
    }
  }

  function hideMetricsHelp() {
    const modal = document.getElementById('metricsHelpModal');
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // Cluster color helper (duplicated here to avoid dependency on main getClusterColor)
  function getClusterColorForMetrics(label) {
    if (label < 0) return '#64748b';
    
    const colors = [
      '#22c55e', '#3b82f6', '#f97316', '#a855f7', '#ec4899',
      '#14b8a6', '#eab308', '#ef4444', '#8b5cf6', '#06b6d4',
      '#84cc16', '#f43f5e', '#6366f1', '#10b981', '#f59e0b'
    ];
    
    return colors[label % colors.length];
  }

  // Compute and display metrics
  async function computeAndDisplayMetrics(wasmApiRef, data, nRows, nDims, labels, minPts) {
    if (!wasmApiRef?.compute_cluster_metrics) {
      console.warn('compute_cluster_metrics not available');
      return null;
    }
    // console.log("Points passed to metrics:", nRows);
    // console.log("Noise count:", labels.filter(l => l === -1).length);
    // console.log("Clustered count:", labels.filter(l => l >= 0).length);
    // console.log("Cluster sizes:", [...new Set(labels.filter(l => l >= 0))]
    //     .map(c => labels.filter(l => l === c).length));
    try {
      const flags = getMetricFlags();
      
      // Only sample when we have more than 10k points
      // Below 10k, use all points for accurate metrics
      const SAMPLE_THRESHOLD = 10000;
      const maxSamples = nRows > SAMPLE_THRESHOLD ? 5000 : nRows;
      const sampleFraction = nRows > SAMPLE_THRESHOLD ? 0.10 : 1.0;
      const maxDbcvSamples = 1000;  // Max samples per cluster for DBCV

       // ============ DIAGNOSTIC START ============
      // Ensure we have Int32Array for proper counting
      const labelsInt32 = labels instanceof Int32Array ? labels : new Int32Array(labels);
      
      console.log("=== LABELS INPUT TO WASM ===");
      console.log("labels type:", labels.constructor.name);
      console.log("labels.length:", labelsInt32.length);
      console.log("nRows param:", nRows);
      
      // Count by label value
      const labelCounts = {};
      for (let i = 0; i < labelsInt32.length; i++) {
        const lbl = labelsInt32[i];
        labelCounts[lbl] = (labelCounts[lbl] || 0) + 1;
      }
      console.log("Label distribution:", labelCounts);
      
      // Specific counts
      const noise = labelCounts[-1] || 0;
      const unclassified = labelCounts[-2] || 0;
      const dropped = labelCounts[-2147483648] || 0;
      const clustered = Object.entries(labelCounts)
        .filter(([k, v]) => parseInt(k) >= 0)
        .reduce((sum, [k, v]) => sum + v, 0);
      
      console.log("Noise (-1):", noise);
      console.log("Unclassified (-2):", unclassified);  
      console.log("Dropped (MIN_INT):", dropped);
      console.log("Clustered (>=0):", clustered);
      console.log("Sum check:", noise + unclassified + dropped + clustered, "should equal", nRows);
      
      // Per-cluster breakdown
      const clusterSizes = Object.entries(labelCounts)
        .filter(([k, v]) => parseInt(k) >= 0)
        .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
        .map(([k, v]) => `Cluster ${k}: ${v}`);
      console.log("Per-cluster sizes:", clusterSizes);

      console.log("=== PARAMS TO WASM ===");
      console.log("maxSamples:", maxSamples);
      console.log("sampleFraction:", sampleFraction);
      console.log("maxDbcvSamples:", maxDbcvSamples);
      console.log("flags:", flags);
      // ============ DIAGNOSTIC END ============
      //labelsint32 possible here if we're chasing more precision, but should be fine. Too many damn things to track.
      const metrics = wasmApiRef.compute_cluster_metrics(
        data,
        nRows,
        nDims,
        labels,
        minPts,
        maxSamples,
        sampleFraction,
        maxDbcvSamples,
        flags  // metric flags
      );
      
      // ============ DIAGNOSTIC: WASM OUTPUT ============
      console.log("=== WASM METRICS OUTPUT ===");
      console.log("cluster_count:", metrics.cluster_count);
      console.log("noise_count:", metrics.noise_count);
      console.log("noise_ratio:", metrics.noise_ratio);
      if (metrics.per_cluster) {
        console.log("per_cluster sizes:", metrics.per_cluster.map(c => `Cluster ${c.id}: ${c.size}`));
        const wasmClustered = metrics.per_cluster.reduce((sum, c) => sum + c.size, 0);
        console.log("WASM total clustered:", wasmClustered);
      }
      console.log("=== COMPARISON ===");
      console.log("INPUT clustered:", clustered, "vs WASM clustered:", 
        metrics.per_cluster ? metrics.per_cluster.reduce((sum, c) => sum + c.size, 0) : "N/A");
      console.log("INPUT noise:", noise, "vs WASM noise:", metrics.noise_count);
      // ============ DIAGNOSTIC END ============

      renderMetricsPanel(metrics);
      
      console.log("=== WASM METRIC VALUES ===");
      console.log("silhouette:", metrics.silhouette);
      console.log("davies_bouldin:", metrics.davies_bouldin);
      console.log("calinski_harabasz:", metrics.calinski_harabasz);
      console.log("dbcv:", metrics.dbcv);
      console.log("noise_ratio:", metrics.noise_ratio);
      console.log("size_cv:", metrics.size_cv);
      return metrics;
    } catch (err) {
      console.error('Failed to compute cluster metrics:', err);
      return null;
    }
  }

  // Public API
  return {
    computeAndDisplayMetrics,
    renderMetricsPanel,
    toggleMetrics,
    togglePerCluster,
    toggleMetricsSettings,
    toggleMetric,
    enableAllMetrics,
    disableExpensiveMetrics,
    showMetricsHelp,
    hideMetricsHelp,
    getMetricFlags,
    METRIC_FLAGS,
    METRIC_CONFIG,
    get enabledMetrics() { return enabledMetrics; },
    get lastMetrics() { return lastMetrics; },
    renderInitialSettingsPanel  // Expose for initial render
  };
})();

// Make CLUSTER_METRICS available globally for inline event handlers
window.CLUSTER_METRICS = CLUSTER_METRICS;

// ============================================
// Initialization
// ============================================

document.addEventListener("DOMContentLoaded", async () => {
  el("uiBadge").textContent = `UI: ${VERSION}`;
  
  // Theme toggle
  el("themeLight").addEventListener("click", () => setTheme("light"));
  el("themeDark").addEventListener("click", () => setTheme("dark"));
  
  // File input
  el("fileInput").addEventListener("change", handleFileUpload);
  el("sampleDataSelect").addEventListener("change", loadSampleData);
  el("btnClear").addEventListener("click", clearSession);
  
  // Feature selection
  el("btnFeatAll").addEventListener("click", () => selectFeatures("all"));
  el("btnFeatFirst3").addEventListener("click", () => selectFeatures("first3"));
  el("btnFeatClear").addEventListener("click", () => selectFeatures("none"));
  
  // Run button
  el("btnRun").addEventListener("click", runDbscan);
  el("btnPlotData").addEventListener("click", plotDataOnly);
  el("btnKDistance").addEventListener("click", runKDistanceOnly);
  
  // Export buttons
  el("btnDownloadCsv").addEventListener("click", exportCsv);
  el("btnDownloadPng").addEventListener("click", exportPng);
  
  // Speed slider
  el("speedSlider").addEventListener("input", updateSpeed);
  
  // Playback controls
  el("btnPlay").addEventListener("click", togglePlay);
  el("btnStep").addEventListener("click", () => stepAnimation(1));
  el("btnStepBack").addEventListener("click", () => stepAnimation(-1));
  el("btnSkip10").addEventListener("click", () => stepAnimation(10));
  el("btnSkip100").addEventListener("click", () => stepAnimation(100));
  el("btnReset").addEventListener("click", resetAnimation);
  
  // Plot options
  el("plotMode").addEventListener("change", () => { resetView(); updateDimensionMismatch(); redrawPlot(); });
  el("plotX").addEventListener("change", () => { resetView(); updateDimensionMismatch(); redrawPlot(); });
  el("plotY").addEventListener("change", () => { resetView(); updateDimensionMismatch(); redrawPlot(); });
  el("plotZ").addEventListener("change", () => { updateDimensionMismatch(); redrawPlot(); });
  el("showRadius").addEventListener("change", redrawPlot);
  el("showNeighborLines").addEventListener("change", redrawPlot);
  el("showGridlines").addEventListener("change", redrawPlot);
  el("showDensityGrid").addEventListener("change", redrawPlot);
  el("viewMode").addEventListener("change", () => { updateLegend(); redrawPlot(); });
  el("zoomSlider").addEventListener("input", () => {
    const zoom = parseFloat(el("zoomSlider").value) || 1;
    if (el("plotMode").value === "3d") {
      STATE.view3d.zoom = zoom;
    }
    redrawPlot();
  });
  el("pointSize").addEventListener("change", redrawPlot);
  
  // Animate checkbox - clears animation when toggled
  el("animateCheck").addEventListener("change", () => {
    if (!el("animateCheck").checked) {
      stopAnimation();
      STATE.hasAnimationData = false;
      updateAnimationControls();
    }
  });
  
  // Canvas interactions (pan/zoom for both 2D and 3D)
  const canvas = el("plotCanvas");
  canvas.addEventListener("mousedown", handleCanvasMouseDown);
  window.addEventListener("mousemove", handleCanvasMouseMove);
  window.addEventListener("mouseup", handleCanvasMouseUp);
  canvas.addEventListener("wheel", handleCanvasWheel, { passive: false });
  
  // Resize handler
  window.addEventListener("resize", () => {
    resizeCanvas();
    redrawPlot();
  });
  
  // Initialize WASM
  await initWasm();
  
  resizeCanvas();
  
  // Initialize metrics settings panel (so users can configure before running DBSCAN)
  CLUSTER_METRICS.renderInitialSettingsPanel();
});

function setTheme(theme) {
  document.documentElement.setAttribute("data-theme", theme);
  el("themeLight").classList.toggle("active", theme === "light");
  el("themeDark").classList.toggle("active", theme === "dark");
  redrawPlot();
  redrawKDistPlot();
  updateLegendStyle();
}

// ============================================
// WASM Initialization
// ============================================

async function initWasm() {
  el("engineBadge").textContent = "ENGINE: LOADING";
  el("engineBadge").className = "status-badge warn";
  
  try {
    // Try to load WASM module
    const wrapperUrl = new URL("../js/DBSCAN/WASM/dbscan_wasm.js", import.meta.url);
    const wasmBinUrl = new URL("../js/DBSCAN/WASM/dbscan_wasm_bg.wasm", import.meta.url);
    
    const mod = await import(wrapperUrl.toString());
    const init = mod.default;
    
    const resp = await fetch(wasmBinUrl.toString(), { cache: "no-store" });
    if (!resp.ok) throw new Error(`Failed to fetch WASM: ${resp.status}`);
    
    const bytes = await resp.arrayBuffer();
    // Use new wasm-bindgen init API to avoid deprecation warning
    await init({ module_or_path: bytes });
    
    wasmApi = mod;
    engineMode = "wasm";


    const version = typeof wasmApi.version === "function" ? wasmApi.version() : "unknown";
    el("engineBadge").textContent = `ENGINE: WASM (${version})`;
    el("engineBadge").className = "status-badge ok";
    
    console.log(`%c[DBSCAN] Rust WASM engine loaded (${version})`, 'color: #22c55e; font-weight: bold;');
        console.log(
      "compute_cluster_metrics arity:",
      (typeof wasmApi?.compute_cluster_metrics === "function")
        ? wasmApi.compute_cluster_metrics.length
        : "n/a"
    );
    //uncomment this line below to force JS fallback due to error in WASM
    // console.log("compute_cluster_metrics arity:", wasmApiRef.compute_cluster_metrics.length);

  } catch (err) {
    console.warn("WASM init failed, using JS fallback:", err);
    el("engineBadge").textContent = "ENGINE: JS FALLBACK";
    el("engineBadge").className = "status-badge warn";
    
    engineMode = "js-fallback";
    
    console.log('%c[DBSCAN] JavaScript fallback engine loaded', 'color: #eab308; font-weight: bold;');
    // Initialize JS fallback DBSCAN
    wasmApi = createJsFallback();
  }
}

// ============================================
// JS Fallback DBSCAN Implementation
//It works enough.
// ============================================

function createJsFallback() {
  return {
    version: () => "js-fallback/1.0",
    
    dbscan_fit(data, nRows, nDims, eps, minPts, missingPolicy, standardize, traceEnable, traceMaxEvents, traceMaxNeighbors) {
      // Validate input
      if (nRows === 0 || nDims === 0) {
        throw new Error("n_rows and n_dims must be > 0");
      }
      
      // Copy data and handle missing values
      const work = new Float32Array(data);
      const usedMask = new Uint8Array(nRows).fill(1);
      let droppedRows = 0;
      let imputedValues = 0;
      
      // Handle missing policy
      if (missingPolicy === 2) { // Fail
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            const v = work[r * nDims + d];
            if (!isFinite(v)) {
              throw new Error(`Missing/non-numeric detected under Fail policy at row ${r}, dim ${d}. Value: "${v}". Check your data for empty cells, non-numeric values, or formatting issues.`);
            }
          }
        }
      } else if (missingPolicy === 0) { // Drop
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) {
              usedMask[r] = 0;
              droppedRows++;
              break;
            }
          }
        }
      } else if (missingPolicy === 1) { // Impute
        const means = new Float32Array(nDims);
        const counts = new Uint32Array(nDims);
        
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            const v = work[r * nDims + d];
            if (isFinite(v)) {
              means[d] += v;
              counts[d]++;
            }
          }
        }
        
        for (let d = 0; d < nDims; d++) {
          means[d] = counts[d] > 0 ? means[d] / counts[d] : 0;
        }
        
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) {
              work[r * nDims + d] = means[d];
              imputedValues++;
            }
          }
        }
      }
      
      // Build used points array
      const usedRows = [];
      for (let r = 0; r < nRows; r++) {
        if (usedMask[r] === 1) usedRows.push(r);
      }
      
      const nUsed = usedRows.length;
      const usedPoints = new Float32Array(nUsed * nDims);
      for (let i = 0; i < nUsed; i++) {
        const r = usedRows[i];
        for (let d = 0; d < nDims; d++) {
          usedPoints[i * nDims + d] = work[r * nDims + d];
        }
      }
      
      // Compute means and stds
      const means = new Float32Array(nDims);
      const stds = new Float32Array(nDims);
      
      for (let d = 0; d < nDims; d++) {
        let sum = 0;
        for (let i = 0; i < nUsed; i++) {
          sum += usedPoints[i * nDims + d];
        }
        means[d] = sum / nUsed;
        
        let variance = 0;
        for (let i = 0; i < nUsed; i++) {
          const diff = usedPoints[i * nDims + d] - means[d];
          variance += diff * diff;
        }
        stds[d] = Math.sqrt(variance / nUsed) || 1;
      }
      
      // Standardize if requested
      if (standardize) {
        for (let i = 0; i < nUsed; i++) {
          for (let d = 0; d < nDims; d++) {
            usedPoints[i * nDims + d] = (usedPoints[i * nDims + d] - means[d]) / stds[d];
          }
        }
      }
      
      // Run DBSCAN
      const labels = new Int32Array(nUsed).fill(-2); // -2 = unclassified
      const eps2 = eps * eps;
      let clusterId = 0;
      
      // Trace data
      const traceP = [];
      const traceCluster = [];
      const traceKind = [];
      const traceNeighborOffsets = [0];
      const traceNeighbors = [];
      const traceNeighborCounts = [];
      
      function distance2(i, j) {
        let d2 = 0;
        for (let d = 0; d < nDims; d++) {
          const diff = usedPoints[i * nDims + d] - usedPoints[j * nDims + d];
          d2 += diff * diff;
        }
        return d2;
      }
      
      function regionQuery(i) {
        const neighbors = [];
        for (let j = 0; j < nUsed; j++) {
          if (distance2(i, j) <= eps2) {
            neighbors.push(j);
          }
        }
        return neighbors;
      }
      
      for (let i = 0; i < nUsed; i++) {
        if (labels[i] !== -2) continue;
        
        const neighbors = regionQuery(i);
        
        // Record trace event
        if (traceEnable && traceP.length < traceMaxEvents) {
          traceP.push(i);
          traceKind.push(0);
          traceCluster.push(clusterId);
          traceNeighborCounts.push(neighbors.length);
          const take = Math.min(traceMaxNeighbors, neighbors.length);
          for (let j = 0; j < take; j++) {
            traceNeighbors.push(neighbors[j]);
          }
          traceNeighborOffsets.push(traceNeighbors.length);
        }
        
        if (neighbors.length < minPts) {
          labels[i] = -1; // Noise
          continue;
        }
        
        labels[i] = clusterId;

        // Make sure this stays as [...neighbors] (spread), not [.neighbors]
        const seeds = [...neighbors];

        // track membership so we can do O(1) "already queued?" checks
        const seedSet = new Set(seeds);

        let idx = 0;

        while (idx < seeds.length) {
          const p = seeds[idx++];

          if (labels[p] === -1) {
            labels[p] = clusterId;
          }

          if (labels[p] !== -2) continue;

          labels[p] = clusterId;

          const pNeighbors = regionQuery(p);

          if (pNeighbors.length >= minPts) {
            for (const q of pNeighbors) {
              if (labels[q] === -2 || labels[q] === -1) {
                // if (!seeds.includes(q)) seeds.push(q); //O(n)
                if (!seedSet.has(q)) { // O(1)
                  seedSet.add(q);
                  seeds.push(q);
                }
              }
            }
          }
        }

        
        clusterId++;
      }
      
      // Map labels back to full row space
      const labelsFull = new Int32Array(nRows).fill(-999);
      for (let i = 0; i < nUsed; i++) {
        labelsFull[usedRows[i]] = labels[i];
      }
      
      // Count stats
      let noise = 0;
      for (const lbl of labels) {
        if (lbl === -1) noise++;
      }
      
      return {
        labels_full: labelsFull,
        used_mask: usedMask,
        means: means,
        stds: stds,
        used_rows: nUsed,
        dropped_rows: droppedRows,
        imputed_values: imputedValues,
        clusters: clusterId,
        noise: noise,
        trace_p: new Uint32Array(traceP),
        trace_cluster: new Int32Array(traceCluster),
        trace_kind: new Uint8Array(traceKind),
        trace_neighbor_offsets: new Uint32Array(traceNeighborOffsets),
        trace_neighbors: new Uint32Array(traceNeighbors),
        trace_neighbor_counts: new Uint32Array(traceNeighborCounts)
      };
    },
    
    // Compute k-distance for elbow plot (using KD-tree for better performance)
    compute_kdist(data, nRows, nDims, k, missingPolicy, standardize, maxSample) {
      // Build used points with missing value handling
      const work = new Float32Array(data);
      const usedMask = new Uint8Array(nRows).fill(1);
      
      // Handle missing values
      if (missingPolicy === 2) {
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) {
              throw new Error(`Missing value at row ${r}, dim ${d}`);
            }
          }
        }
      } else if (missingPolicy === 0) {
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) {
              usedMask[r] = 0;
              break;
            }
          }
        }
      } else if (missingPolicy === 1) {
        const means = new Float32Array(nDims);
        const counts = new Uint32Array(nDims);
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            const v = work[r * nDims + d];
            if (isFinite(v)) { means[d] += v; counts[d]++; }
          }
        }
        for (let d = 0; d < nDims; d++) {
          means[d] = counts[d] > 0 ? means[d] / counts[d] : 0;
        }
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) work[r * nDims + d] = means[d];
          }
        }
      }
      
      // Build used points
      const usedRows = [];
      for (let r = 0; r < nRows; r++) {
        if (usedMask[r] === 1) usedRows.push(r);
      }
      const nUsed = usedRows.length;
      
      if (nUsed < 2) return new Float32Array(0);
      
      const usedPoints = new Float32Array(nUsed * nDims);
      for (let i = 0; i < nUsed; i++) {
        const r = usedRows[i];
        for (let d = 0; d < nDims; d++) {
          usedPoints[i * nDims + d] = work[r * nDims + d];
        }
      }
      
      // Standardize if requested
      if (standardize) {
        const means = new Float32Array(nDims);
        const stds = new Float32Array(nDims);
        for (let d = 0; d < nDims; d++) {
          let sum = 0;
          for (let i = 0; i < nUsed; i++) sum += usedPoints[i * nDims + d];
          means[d] = sum / nUsed;
          let variance = 0;
          for (let i = 0; i < nUsed; i++) {
            const diff = usedPoints[i * nDims + d] - means[d];
            variance += diff * diff;
          }
          stds[d] = Math.sqrt(variance / nUsed) || 1;
        }
        for (let i = 0; i < nUsed; i++) {
          for (let d = 0; d < nDims; d++) {
            usedPoints[i * nDims + d] = (usedPoints[i * nDims + d] - means[d]) / stds[d];
          }
        }
      }
      
      // Sample if too many points
      const sampleSize = Math.min(maxSample, nUsed);
      const step = sampleSize >= nUsed ? 1 : Math.floor(nUsed / sampleSize);
      
      const knn = Math.min(k, nUsed - 1);
      const kDistances = [];
      
      // Use brute force for JS fallback (O(n^2) but acceptable for samples I guess)
      for (let si = 0, idx = 0; si < sampleSize && idx < nUsed; si++, idx += step) {
        const distances = [];
        for (let j = 0; j < nUsed; j++) {
          if (idx === j) continue;
          let d2 = 0;
          for (let d = 0; d < nDims; d++) {
            const diff = usedPoints[idx * nDims + d] - usedPoints[j * nDims + d];
            d2 += diff * diff;
          }
          distances.push(Math.sqrt(d2));
        }
        distances.sort((a, b) => a - b);
        if (distances.length >= knn) {
          kDistances.push(distances[knn - 1]);
        }
      }
      
      kDistances.sort((a, b) => a - b);
      return new Float32Array(kDistances);
    },
    
    // Classify points as core, border, or noise
    classify_points(data, nRows, nDims, eps, minPts, missingPolicy, standardize) {
      const work = new Float32Array(data);
      const usedMask = new Uint8Array(nRows).fill(1);
      
      // Handle missing values (same as above)
      if (missingPolicy === 0) {
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) { usedMask[r] = 0; break; }
          }
        }
      } else if (missingPolicy === 1) {
        const means = new Float32Array(nDims);
        const counts = new Uint32Array(nDims);
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            const v = work[r * nDims + d];
            if (isFinite(v)) { means[d] += v; counts[d]++; }
          }
        }
        for (let d = 0; d < nDims; d++) means[d] = counts[d] > 0 ? means[d] / counts[d] : 0;
        for (let r = 0; r < nRows; r++) {
          for (let d = 0; d < nDims; d++) {
            if (!isFinite(work[r * nDims + d])) work[r * nDims + d] = means[d];
          }
        }
      }
      
      const usedRows = [];
      for (let r = 0; r < nRows; r++) if (usedMask[r] === 1) usedRows.push(r);
      const nUsed = usedRows.length;
      
      if (nUsed === 0) return new Uint8Array(nRows);
      
      const usedPoints = new Float32Array(nUsed * nDims);
      for (let i = 0; i < nUsed; i++) {
        const r = usedRows[i];
        for (let d = 0; d < nDims; d++) usedPoints[i * nDims + d] = work[r * nDims + d];
      }
      
      if (standardize) {
        const means = new Float32Array(nDims);
        const stds = new Float32Array(nDims);
        for (let d = 0; d < nDims; d++) {
          let sum = 0;
          for (let i = 0; i < nUsed; i++) sum += usedPoints[i * nDims + d];
          means[d] = sum / nUsed;
          let variance = 0;
          for (let i = 0; i < nUsed; i++) {
            const diff = usedPoints[i * nDims + d] - means[d];
            variance += diff * diff;
          }
          stds[d] = Math.sqrt(variance / nUsed) || 1;
        }
        for (let i = 0; i < nUsed; i++) {
          for (let d = 0; d < nDims; d++) {
            usedPoints[i * nDims + d] = (usedPoints[i * nDims + d] - means[d]) / stds[d];
          }
        }
      }
      
      const eps2 = eps * eps;
      const isCore = new Array(nUsed).fill(false);
      
      // Find core points (O(n^2) in fallback)
      for (let i = 0; i < nUsed; i++) {
        let count = 0;
        for (let j = 0; j < nUsed; j++) {
          let d2 = 0;
          for (let d = 0; d < nDims; d++) {
            const diff = usedPoints[i * nDims + d] - usedPoints[j * nDims + d];
            d2 += diff * diff;
          }
          if (d2 <= eps2) count++;
        }
        if (count >= minPts) isCore[i] = true;
      }
      
      // Find border points
      const isBorder = new Array(nUsed).fill(false);
      for (let i = 0; i < nUsed; i++) {
        if (isCore[i]) continue;
        for (let j = 0; j < nUsed; j++) {
          if (!isCore[j]) continue;
          let d2 = 0;
          for (let d = 0; d < nDims; d++) {
            const diff = usedPoints[i * nDims + d] - usedPoints[j * nDims + d];
            d2 += diff * diff;
          }
          if (d2 <= eps2) { isBorder[i] = true; break; }
        }
      }
      
      // Map back: 0 = noise, 1 = border, 2 = core
      const classification = new Uint8Array(nRows);
      for (let i = 0; i < nUsed; i++) {
        const r = usedRows[i];
        if (isCore[i]) classification[r] = 2;
        else if (isBorder[i]) classification[r] = 1;
      }
      
      return classification;
    }
  };
}

// ============================================
// File Handling
// ============================================

async function handleFileUpload(e) {
  const file = e.target.files?.[0];
  if (!file) return;
  
  if (file.size > 10 * 1024 * 1024) {
    showMessage("File too large (max 10MB)", true);
    return;
  }
  
  try {
    const text = await file.text();
    parseCSV(text, file.name);
  } catch (err) {
    showMessage(`Error reading file: ${err.message}`, true);
  }
}

function parseCSV(text, filename) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  if (lines.length < 2) {
    showMessage("CSV must have at least a header and one data row", true);
    return;
  }
  
  // Detect delimiter
  const firstLine = lines[0];
  const delimiter = firstLine.includes('\t') ? '\t' : ',';
  
  const header = parseCSVLine(firstLine, delimiter);
  const rows = [];
  const errors = [];
  
  for (let i = 1; i < lines.length; i++) {
    try {
      const row = parseCSVLine(lines[i], delimiter);
      if (row.length === header.length) {
        rows.push(row);
      }
    } catch (err) {
      errors.push(`Row ${i + 1}: ${err.message}`);
    }
  }
  
  if (rows.length === 0) {
    showMessage("No valid data rows found", true);
    return;
  }
  
  // Find numeric columns
  const numericIdx = [];
  const sampleSize = Math.min(100, rows.length);
  for (let c = 0; c < header.length; c++) {
    let numericCount = 0;
    for (let i = 0; i < sampleSize; i++) {
      const v = parseFloat(rows[i][c]);
      if (isFinite(v)) numericCount++;
    }
    if (numericCount > sampleSize * 0.5) {
      numericIdx.push(c);
    }
  }
  
  STATE.filename = filename;
  STATE.header = header;
  STATE.rows = rows;
  STATE.numericIdx = numericIdx;
  STATE.selectedFeatures = numericIdx.slice(0, Math.min(3, numericIdx.length));
  STATE.lastResult = null;
  
  updateUI();
  
  let msg = `Loaded ${filename}\n`;
  msg += `‚Ä¢ ${rows.length} rows √ó ${header.length} columns\n`;
  msg += `‚Ä¢ ${numericIdx.length} numeric columns detected\n`;
  
  if (errors.length > 0) {
    msg += `\n‚ö† ${errors.length} rows skipped due to parse errors`;
  }
  
  showMessage(msg);
}

function parseCSVLine(line, delimiter) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === delimiter && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current.trim());
  return result;
}

function loadSampleData() {
  const sampleType = el("sampleDataSelect").value;
  if (!sampleType) return;
  
  function gaussian() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }
  
  let rows = [];
  let filename = "";
  let eps = "0.5";
  let minPts = "5";
  let use3D = false;
  
  switch (sampleType) {
    case "clusters4": {
      rows.push(["x1", "x2", "x3", "x4", "x5", "label"]);
      function addCluster(mu, sig, n, label) {
        for (let i = 0; i < n; i++) {
          rows.push([
            (mu[0] + gaussian() * sig[0]).toFixed(4),
            (mu[1] + gaussian() * sig[1]).toFixed(4),
            (mu[2] + gaussian() * sig[2]).toFixed(4),
            (mu[3] + gaussian() * sig[3]).toFixed(4),
            (mu[4] + gaussian() * sig[4]).toFixed(4),
            label
          ]);
        }
      }
      addCluster([-2.0, -1.5, 0.8, -0.2, 1.4], [0.25, 0.22, 0.30, 0.25, 0.28], 400, "A");
      addCluster([2.2, 1.7, -0.6, 0.9, -1.0], [0.30, 0.26, 0.35, 0.30, 0.33], 400, "B");
      addCluster([-0.2, 2.6, 1.9, -1.2, 0.1], [0.22, 0.28, 0.25, 0.35, 0.25], 400, "C");
      addCluster([1.5, -1.8, -1.5, 1.5, 0.8], [0.28, 0.24, 0.30, 0.28, 0.30], 400, "D");
      for (let i = 0; i < 150; i++) {
        rows.push([
          ((Math.random() * 8) - 4).toFixed(4),
          ((Math.random() * 7) - 3).toFixed(4),
          ((Math.random() * 6) - 3).toFixed(4),
          ((Math.random() * 6) - 3).toFixed(4),
          ((Math.random() * 6) - 3).toFixed(4),
          "noise"
        ]);
      }
      filename = "4_clusters.csv";
      eps = "0.5";
      minPts = "8";
      break;
    }
    
    case "moons": {
      rows.push(["x", "y", "label"]);
      const n = 500;
      // Upper moon
      for (let i = 0; i < n; i++) {
        const t = Math.PI * i / n;
        const x = Math.cos(t) + gaussian() * 0.08;
        const y = Math.sin(t) + gaussian() * 0.08;
        rows.push([x.toFixed(4), y.toFixed(4), "moon1"]);
      }
      // Lower moon (shifted)
      for (let i = 0; i < n; i++) {
        const t = Math.PI + Math.PI * i / n;
        const x = 1 + Math.cos(t) + gaussian() * 0.08;
        const y = 0.5 + Math.sin(t) + gaussian() * 0.08;
        rows.push([x.toFixed(4), y.toFixed(4), "moon2"]);
      }
      // Noise
      for (let i = 0; i < 50; i++) {
        rows.push([
          ((Math.random() * 4) - 1).toFixed(4),
          ((Math.random() * 3) - 1).toFixed(4),
          "noise"
        ]);
      }
      filename = "two_moons.csv";
      eps = "0.15";
      minPts = "5";
      break;
    }
    
    case "circles": {
      rows.push(["x", "y", "label"]);
      // Inner circle
      for (let i = 0; i < 400; i++) {
        const t = 2 * Math.PI * Math.random();
        const r = 0.5 + gaussian() * 0.05;
        rows.push([
          (r * Math.cos(t)).toFixed(4),
          (r * Math.sin(t)).toFixed(4),
          "inner"
        ]);
      }
      // Outer circle
      for (let i = 0; i < 600; i++) {
        const t = 2 * Math.PI * Math.random();
        const r = 1.5 + gaussian() * 0.08;
        rows.push([
          (r * Math.cos(t)).toFixed(4),
          (r * Math.sin(t)).toFixed(4),
          "outer"
        ]);
      }
      // Noise
      for (let i = 0; i < 80; i++) {
        rows.push([
          ((Math.random() * 5) - 2.5).toFixed(4),
          ((Math.random() * 5) - 2.5).toFixed(4),
          "noise"
        ]);
      }
      filename = "concentric_circles.csv";
      eps = "0.2";
      minPts = "8";
      break;
    }
    
    case "spiral": {
      rows.push(["x", "y", "label"]);
      const arms = 3;
      const pointsPerArm = 400;
      for (let a = 0; a < arms; a++) {
        const offset = (1.75 * Math.PI / arms) * a;
        for (let i = 0; i < pointsPerArm; i++) {
          const t = 0.5 + 3 * i / pointsPerArm;
          const angle = t * 1.75 + offset;
          const x = t * Math.cos(angle) + gaussian() * 0.1;
          const y = t * Math.sin(angle) + gaussian() * 0.1;
          rows.push([x.toFixed(4), y.toFixed(4), `arm${a + 1}`]);
        }
      }
      // Noise
      for (let i = 0; i < 80; i++) {
        const r = Math.random() * 4;
        const t = Math.random() * 2 * Math.PI;
        rows.push([
          (r * Math.cos(t)).toFixed(4),
          (r * Math.sin(t)).toFixed(4),
          "noise"
        ]);
      }
      filename = "spiral_arms.csv";
      eps = "0.1725";
      minPts = "9";
      break;
    }
    
    case "density": {
      rows.push(["x", "y", "label"]);
      // Dense cluster
      for (let i = 0; i < 400; i++) {
        rows.push([
          (-2 + gaussian() * 0.2).toFixed(4),
          (0 + gaussian() * 0.2).toFixed(4),
          "dense"
        ]);
      }
      // Medium cluster
      for (let i = 0; i < 300; i++) {
        rows.push([
          (0 + gaussian() * 0.5).toFixed(4),
          (0 + gaussian() * 0.5).toFixed(4),
          "medium"
        ]);
      }
      // Sparse cluster
      for (let i = 0; i < 200; i++) {
        rows.push([
          (2.5 + gaussian() * 1.0).toFixed(4),
          (0 + gaussian() * 1.0).toFixed(4),
          "sparse"
        ]);
      }
      // Noise
      for (let i = 0; i < 100; i++) {
        rows.push([
          ((Math.random() * 10) - 5).toFixed(4),
          ((Math.random() * 6) - 3).toFixed(4),
          "noise"
        ]);
      }
      filename = "varied_density.csv";
      eps = "0.25";
      minPts = "25";
      break;
    }
    
    case "smiley3d": {
      rows.push(["x_label", "y_label", "z_label", "label"]);
      use3D = true;
      
      // Face - circular disc in X-Z plane (Y is forward)
      // Looking at face from +Y direction: X is left-right, Z is up-down
      const faceRadius = 2;
      
      // Face outline (circle)
      for (let i = 0; i < 500; i++) {

        const theta = 2 * Math.PI * Math.random();
        const r = faceRadius * (0.98 + Math.random() * 0.04);
        const x = r * Math.cos(theta) + gaussian() * 0.05;
        const z = r * Math.sin(theta) + gaussian() * 0.05;

        // Make the face disc "thinner" in Y so it doesn't bridge to features.
        const y = gaussian() * 0.03; // Flat face //0.08 prev

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "face"]);

      }
      
      // Face fill (sparse)
      for (let i = 0; i < 150; i++) {

        const theta = 2 * Math.PI * Math.random();
        const r = faceRadius * Math.sqrt(Math.random()) * 0.85;
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);

        const y = 0.04 * (1 - r/faceRadius) + gaussian() * 0.02; // Slight bulge // was 0.1*(...) + 0.03 noise

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "face"]);

      }
      
      // Left eye (from viewer's perspective, so +X side)
      for (let i = 0; i < 80; i++) {

        const x = -0.6 + gaussian() * 0.12;
        const z = 0.5 + gaussian() * 0.12;

        // Push features forward in +Y so they don't DBSCAN-connect to the face disc.
        const y = 0.70 + gaussian() * 0.03; // was 0.25 + 0.05

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "left_eye"]);
      }
      
      // Right eye
      for (let i = 0; i < 80; i++) {

        const x = 0.6 + gaussian() * 0.12;
        const z = 0.5 + gaussian() * 0.12;

        const y = 0.70 + gaussian() * 0.03;// was 0.25 + 0.05

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "right_eye"]);
      }
      
      // Smile - arc curving downward in X-Z plane
      for (let i = 0; i < 180; i++) {

        const t = Math.PI * 0.2 + Math.PI * 0.6 * (i / 180); // Arc from left to right
        const smileRadius = 1.0;
        const x = smileRadius * Math.cos(t) + gaussian() * 0.05;

        const z = -0.4 - 0.3 * Math.sin(t) + gaussian() * 0.05; // Curve down

        const y = 0.2 + gaussian() * 0.03;

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "smile"]);

      }
      
      // Nose - small bump
      for (let i = 0; i < 50; i++) {

        const x = gaussian() * 0.1;
        const z = 0.0 + gaussian() * 0.1;

        const y = 0.85 + Math.abs(gaussian() * 0.04); // was 0.35 + abs(0.08)

        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "nose"]);
      }
      
      filename = "3d_smiley.csv";
      eps = "0.25";
      minPts = "10";
      break;
    }
    
    case "blobs3d": {
      rows.push(["x", "y", "z", "label"]);
      use3D = true;
      
      function addBlob(cx, cy, cz, sx, sy, sz, n, label) {
        for (let i = 0; i < n; i++) {
          rows.push([
            (cx + gaussian() * sx).toFixed(4),
            (cy + gaussian() * sy).toFixed(4),
            (cz + gaussian() * sz).toFixed(4),
            label
          ]);
        }
      }
      
      addBlob(-2, -2, -2, 0.4, 0.4, 0.4, 250, "A");
      addBlob(2, -2, -2, 0.5, 0.5, 0.5, 250, "B");
      addBlob(-2, 2, -2, 0.3, 0.3, 0.3, 250, "C");
      addBlob(2, 2, -2, 0.4, 0.4, 0.4, 250, "D");
      addBlob(-2, -2, 2, 0.5, 0.5, 0.5, 250, "E");
      addBlob(2, -2, 2, 0.3, 0.3, 0.3, 250, "F");
      addBlob(-2, 2, 2, 0.4, 0.4, 0.4, 250, "G");
      addBlob(2, 2, 2, 0.5, 0.5, 0.5, 250, "H");
      
      // Noise
      for (let i = 0; i < 150; i++) {
        rows.push([
          ((Math.random() * 8) - 4).toFixed(4),
          ((Math.random() * 8) - 4).toFixed(4),
          ((Math.random() * 8) - 4).toFixed(4),
          "noise"
        ]);
      }
      
      filename = "3d_blobs.csv";
      eps = "0.3";
      minPts = "8";
      break;
    }
    
    case "pressure10k": {
      rows.push(["x", "y", "z", "label"]);
      use3D = true;

      // Pressure-test dataset (3D + noise):
      // - 30,000 total points
      // - Multiple rings in 3D (mixed planes)
      // - Background noise throughout the volume
      // - "Halo" noise around rings (some attaches, some stays detached)
      // - Special upper-left pair: one ring horizontal (XY) + one ring vertical (YZ)
      //   that visually "passes through the center/hole" without touching or clustering together.
      // - This is cursed and I will wonder how this all came together 6 months from now.

      const PRESSURE_N = 30000;    // total points (adjust later...)
      const RING_COUNT = 10;       // number of rings
      const R = 1.0;               // ring radius

      // --- Point budget (must sum to PRESSURE_N) ---
      const CORE_N = 22500;         // points on the rings (high density, easy core)
      const HALO_N = 4500;         // near-ring noise (tube around rings)
      const BG_N   = 3000;         // uniform background noise (hard mode)

      // --- Layout (3D) ---
      const ROW2_Y = -2.2;

      // Venn-like behavior (same-plane overlap pair)
      const ENABLE_VENN_JOIN = true;
      const VENN_JOIN_D = 1.60; // < 2*R (2.0), so overlap (will merge at reasonable eps)

      // Upper-left "linked" orthogonal pair clearance:
      // vertical (YZ) ring center is shifted in +X by (R + LINK_CLEAR) so it threads the XY ring's center/hole
      // WITHOUT touching. Keep this comfortably > eps and > halo spread to prevent accidental merges.
      const LINK_CLEAR = 0.25;

      // Base spacing for the rest so they stay apart.
      const STEP_X = 3.20;
      const OFFSET_X = 0.90;

      // --- Sampling jitter ---
      // Core jitter (keeps rings clean but not perfectly uniform)
      const CORE_THETA_JITTER = 0.006; // radians
      const CORE_RAD_JITTER   = 0.020; // in-plane thickness
      const CORE_NORM_JITTER  = 0.020; // out-of-plane thickness

      // Halo noise around rings: mix of "attached" (close enough to join the ring cluster)
      // and "detached" (usually becomes noise or small fragments unless eps is increased).
      const HALO_ATTACH_FRACTION = 0.60;

      // Attached halo: mild tube around ring (typically joins cluster)
      const HALO_ATTACH_RAD_SIG  = 0.060;
      const HALO_ATTACH_NORM_SIG = 0.060;

      // Detached halo: wider tube (often outside eps from core)
      const HALO_DETACH_RAD_SIG  = 0.200;
      const HALO_DETACH_NORM_SIG = 0.160;

      function randUniform(a, b) {
        return a + (b - a) * Math.random();
      }

      // Emit points on/around a ring in a chosen plane:
      // plane="xy": ring in XY, thickness along Z
      // plane="xz": ring in XZ, thickness along Y
      // plane="yz": ring in YZ, thickness along X  <-- needed for the upper-left orthogonal pair
      function emitRing(cx, cy, cz, plane, nCore, nHalo, label, phase) {
        // --- Core points (dense ring) ---
        for (let j = 0; j < nCore; j++) {
          const t  = 2 * Math.PI * (j / nCore) + gaussian() * CORE_THETA_JITTER + phase;
          const rr = R + gaussian() * CORE_RAD_JITTER;
          const nn = gaussian() * CORE_NORM_JITTER;

          let x, y, z;
          if (plane === "xy") {
            x = cx + rr * Math.cos(t);
            y = cy + rr * Math.sin(t);
            z = cz + nn;
          } else if (plane === "xz") {
            x = cx + rr * Math.cos(t);
            y = cy + nn;
            z = cz + rr * Math.sin(t);
          } else {
            // "yz"
            x = cx + nn;
            y = cy + rr * Math.cos(t);
            z = cz + rr * Math.sin(t);
          }

          rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), label]);
        }

        // --- Halo points (near-ring noise) ---
        const nAttach = Math.floor(nHalo * HALO_ATTACH_FRACTION);
        const nDetach = nHalo - nAttach;

        // Attached halo
        for (let j = 0; j < nAttach; j++) {
          const t  = randUniform(0, 2 * Math.PI) + phase;
          const rr = R + gaussian() * HALO_ATTACH_RAD_SIG;
          const nn = gaussian() * HALO_ATTACH_NORM_SIG;

          let x, y, z;
          if (plane === "xy") {
            x = cx + rr * Math.cos(t);
            y = cy + rr * Math.sin(t);
            z = cz + nn;
          } else if (plane === "xz") {
            x = cx + rr * Math.cos(t);
            y = cy + nn;
            z = cz + rr * Math.sin(t);
          } else {
            // "yz"
            x = cx + nn;
            y = cy + rr * Math.cos(t);
            z = cz + rr * Math.sin(t);
          }

          rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), label]);
        }

        // Detached halo
        for (let j = 0; j < nDetach; j++) {
          const t  = randUniform(0, 2 * Math.PI) + phase;
          const rr = R + gaussian() * HALO_DETACH_RAD_SIG;
          const nn = gaussian() * HALO_DETACH_NORM_SIG;

          let x, y, z;
          if (plane === "xy") {
            x = cx + rr * Math.cos(t);
            y = cy + rr * Math.sin(t);
            z = cz + nn;
          } else if (plane === "xz") {
            x = cx + rr * Math.cos(t);
            y = cy + nn;
            z = cz + rr * Math.sin(t);
          } else {
            // "yz"
            x = cx + nn;
            y = cy + rr * Math.cos(t);
            z = cz + rr * Math.sin(t);
          }

          rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), label]);
        }
      }

      // --- Build ring layout ---
      // We define centers explicitly so we can control:
      //  - an orthogonal "linked" pair (ring_0 + ring_1) that doesn't touch
      //  - a Venn-join pair (ring_3 + ring_4) that does overlap and merges

      const rings = [];

      // Upper-left special pair:
      // ring_0: horizontal ring in XY (z‚âà0)
      // ring_1: vertical ring in YZ (x‚âà0), shifted in Z so it "passes through" visually
      // without explicitly touching/merging with ring_0.
      const LINK_X = 0.0
      const LINK_Y =1.0 // must be comfortably > eps and > typical halo thickness to avoid accidental merges
      const LINK_Z = 0.0; 


      rings.push({ cx: 0.0, cy: 0.0, cz: 0.0,     plane: "xy" }); // ring_0 (horizontal)
      rings.push({ cx: 0.0, cy: LINK_Y, cz: LINK_Z,  plane: "yz" }); // ring_1 (vertical)


      // Another separate ring in row 1 (keep spacing large to avoid chaining merges)
      rings.push({ cx: STEP_X * 2.0, cy: 0.0, cz: 0.0, plane: "xy" }); // ring_2

      // Venn-like overlap pair in row 1
      const JOIN_BASE_X = STEP_X * 3.0;
      rings.push({ cx: JOIN_BASE_X, cy: 0.0, cz: 0.0, plane: "xy" }); // ring_3
      rings.push({
        cx: JOIN_BASE_X + (ENABLE_VENN_JOIN ? VENN_JOIN_D : STEP_X),
        cy: 0.0,
        cz: 0.0,
        plane: "xy"
      }); // ring_4

      // Row 2 (XZ plane) - offset/staggered under row 1
      rings.push({ cx: OFFSET_X + 0.0,          cy: ROW2_Y, cz:  1.20, plane: "xz" }); // ring_5
      rings.push({ cx: OFFSET_X + STEP_X * 1.0, cy: ROW2_Y, cz: -1.20, plane: "xz" }); // ring_6
      rings.push({ cx: OFFSET_X + STEP_X * 2.0, cy: ROW2_Y, cz:  1.20, plane: "xz" }); // ring_7
      rings.push({ cx: OFFSET_X + STEP_X * 3.0, cy: ROW2_Y, cz: -1.20, plane: "xz" }); // ring_8
      rings.push({ cx: OFFSET_X + STEP_X * 4.0, cy: ROW2_Y, cz:  1.20, plane: "xz" }); // ring_9

      rings.length = Math.min(rings.length, RING_COUNT);

      // --- Allocate points per ring (core + halo) ---
      const coreBase = Math.floor(CORE_N / rings.length);
      const coreRem  = CORE_N - coreBase * rings.length;

      const haloBase = Math.floor(HALO_N / rings.length);
      const haloRem  = HALO_N - haloBase * rings.length;

      for (let c = 0; c < rings.length; c++) {
        const nCore = coreBase + (c < coreRem ? 1 : 0);
        const nHalo = haloBase + (c < haloRem ? 1 : 0);

        // deterministic phase shift so rings don't align perfectly
        const phase = c * 0.37;

        const r = rings[c];
        emitRing(r.cx, r.cy, r.cz, r.plane, nCore, nHalo, `ring_${c}`, phase);
      }

      // --- Background noise (uniform) ---
      // Compute a bounding box around all rings with padding.
      let xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity, zmin = Infinity, zmax = -Infinity;
      for (const r of rings) {
        xmin = Math.min(xmin, r.cx - (R + 0.8));
        xmax = Math.max(xmax, r.cx + (R + 0.8));
        ymin = Math.min(ymin, r.cy - (R + 0.8));
        ymax = Math.max(ymax, r.cy + (R + 0.8));
        zmin = Math.min(zmin, r.cz - (R + 0.8));
        zmax = Math.max(zmax, r.cz + (R + 0.8));
      }

      for (let i = 0; i < BG_N; i++) {
        const x = randUniform(xmin, xmax);
        const y = randUniform(ymin, ymax);
        const z = randUniform(zmin, zmax);
        rows.push([x.toFixed(4), y.toFixed(4), z.toFixed(4), "bg_noise"]);
      }

      filename = "pressure_10k_rings_3d_noise.csv";

      // "Good" starting values (raw units).
      // Rings are dense so they connect at small eps; noise stays mostly noise.
      eps = "0.10";
      minPts = "20";
      break;
    }




    default:
      return;
  }
  
  const csv = rows.map(r => r.join(",")).join("\n");
  parseCSV(csv, filename);
  
  // Set good defaults for sample
  el("epsInput").value = eps;
  el("minPtsInput").value = minPts;
  el("standardize").checked = true;
  
  // Set 3D mode if appropriate
  if (use3D) {
    el("plotMode").value = "3d";
    // Set good viewing angle for 3D smiley
    if (sampleType === "smiley3d") {
      STATE.view3d.yaw = 0;
      STATE.view3d.pitch = -Math.PI / 2;
      // STATE.view3d.pitch = 0;
    }
  } else {
    el("plotMode").value = "2d";
  }
  
  // Reset view (but keep smiley angle if set)
  if (sampleType !== "smiley3d") {
    resetView();
  } else {
    STATE.view2d.panX = 0;
    STATE.view2d.panY = 0;
    STATE.view3d.zoom = 1.0;
    STATE.view3d.panX = 0;
    STATE.view3d.panY = 0;
    el("zoomSlider").value = 1;
  }
  
  // Reset sample select
  el("sampleDataSelect").value = "";
}

function clearSession() {
  STATE.filename = null;
  STATE.header = [];
  STATE.rows = [];
  STATE.numericIdx = [];
  STATE.selectedFeatures = [];
  STATE.lastResult = null;
  STATE.plotData = null;
  STATE.classification = null;
  STATE.hasAnimationData = false;
  STATE.kDistData = null;
  STATE.depthCache = null; // Clear 3D rendering cache

  stopAnimation();
  resetView();
  
  el("legendBox").style.display = "none";
  el("zoomSlider").value = 1;
  
  // Clear k-distance canvas
  const kdistCanvas = el("kdistCanvas");
  const kdistCtx = kdistCanvas.getContext("2d");
  kdistCtx.clearRect(0, 0, kdistCanvas.width, kdistCanvas.height);
  
  // Reset metrics panel
  const metricsContent = el("metricsContent");
  if (metricsContent) {
    metricsContent.innerHTML = '<div class="no-data">Run DBSCAN to see metrics</div>';
  }
  
  updateUI();
  updateAnimationControls();
  clearCanvas();
  showMessage("Session cleared. Load a CSV file or select sample data to begin.");
}

function resetView() {
  STATE.view2d.panX = 0;
  STATE.view2d.panY = 0;
  STATE.view3d.yaw = 0.5;
  STATE.view3d.pitch = 0.3;
  STATE.view3d.zoom = 1.0;
  STATE.view3d.panX = 0;
  STATE.view3d.panY = 0;
  el("zoomSlider").value = 1;
}

function updateAnimationControls() {
  const hasAnimation = STATE.hasAnimationData && el("animateCheck").checked;
  const isRunning = STATE.anim.running;
  
  el("btnPlay").disabled = !hasAnimation;
  el("btnStep").disabled = !hasAnimation;
  el("btnStepBack").disabled = !hasAnimation;
  el("btnSkip10").disabled = !hasAnimation;
  el("btnSkip100").disabled = !hasAnimation;
  el("btnReset").disabled = !hasAnimation;
  
  // Update status text
  if (!hasAnimation) {
    el("animStatus").textContent = el("animateCheck").checked ? "Run DBSCAN first" : "Animation disabled";
  } else if (isRunning) {
    el("animStatus").textContent = STATE.anim.paused ? "Paused" : "Playing";
  } else {
    el("animStatus").textContent = "Ready";
  }
}

// ============================================
// UI Updates
// ============================================

function updateUI() {
  // Dataset stats
  el("statFile").textContent = STATE.filename || "‚Äî";
  el("statRows").textContent = STATE.rows.length || "‚Äî";
  el("statCols").textContent = STATE.header.length || "‚Äî";
  el("statNumeric").textContent = STATE.numericIdx.length || "‚Äî";
  
  // Enable/disable buttons
  const hasData = STATE.rows.length > 0 && STATE.selectedFeatures.length > 0;
  el("btnRun").disabled = !hasData;
  el("btnPlotData").disabled = !hasData;
  el("btnKDistance").disabled = !hasData;
  el("btnDownloadCsv").disabled = !STATE.lastResult;
  el("btnDownloadPng").disabled = !STATE.lastResult && !STATE.plotData;
  
  // Update feature list
  renderFeatureList();
  
  // Update plot axis selectors
  updateAxisSelectors();
}

function renderFeatureList() {
  const container = el("featureList");
  
  if (STATE.numericIdx.length === 0) {
    container.innerHTML = '<div style="padding: 16px; text-align: center; color: var(--text-muted); font-size: 0.8rem;">Load data to select features</div>';
    return;
  }
  
  container.innerHTML = STATE.numericIdx.map(idx => {
    const name = STATE.header[idx] || `Col ${idx}`;
    const checked = STATE.selectedFeatures.includes(idx);
    return `
      <label class="feat-item">
        <input type="checkbox" data-col="${idx}" ${checked ? 'checked' : ''} />
        <span class="feat-name">${name}</span>
      </label>
    `;
  }).join('');
  
  // Add event listeners
  container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.addEventListener("change", (e) => {
      const col = parseInt(e.target.dataset.col);
      if (e.target.checked) {
        if (!STATE.selectedFeatures.includes(col)) {
          STATE.selectedFeatures.push(col);
        }
      } else {
        STATE.selectedFeatures = STATE.selectedFeatures.filter(c => c !== col);
      }
      updateUI();
    });
  });
}

function selectFeatures(mode) {
  if (mode === "all") {
    STATE.selectedFeatures = [...STATE.numericIdx];
  } else if (mode === "first3") {
    STATE.selectedFeatures = STATE.numericIdx.slice(0, 3);
  } else {
    STATE.selectedFeatures = [];
  }
  updateUI();
}

function updateAxisSelectors() {
  const options = STATE.numericIdx.map(idx => {
    const name = STATE.header[idx] || `Col ${idx}`;
    return `<option value="${idx}">${name}</option>`;
  }).join('');
  
  const defaultOption = '<option value="">‚Äî</option>';
  
  el("plotX").innerHTML = defaultOption + options;
  el("plotY").innerHTML = defaultOption + options;
  el("plotZ").innerHTML = defaultOption + options;
  
  // Set defaults
  if (STATE.numericIdx.length >= 1) el("plotX").value = STATE.numericIdx[0];
  if (STATE.numericIdx.length >= 2) el("plotY").value = STATE.numericIdx[1];
  if (STATE.numericIdx.length >= 3) el("plotZ").value = STATE.numericIdx[2];
}

function showMessage(msg, isError = false) {
  const box = el("msgBox");
  box.textContent = msg;
  box.className = isError ? "message-box error" : "message-box";
}

// ============================================
// Canvas Handling
// ============================================

function resizeCanvas() {
  const canvas = el("plotCanvas");
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = 600 * window.devicePixelRatio;
  canvas.style.height = "600px";
}

function clearCanvas() {
  const canvas = el("plotCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.warn("Could not get 2D context for canvas");
    return;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// ============================================
// DBSCAN Execution
// ============================================

async function runDbscan() {
  if (!wasmApi) {
    showMessage("Engine not initialized", true);
    return;
  }
  
  const eps = parseFloat(el("epsInput").value);
  const minPts = parseInt(el("minPtsInput").value);
  const missingKey = el("missingPolicy").value;
  const standardize = el("standardize").checked;
  const animate = el("animateCheck").checked;
  
  const missingPolicy = { drop: 0, impute: 1, fail: 2 }[missingKey];
  
  if (!isFinite(eps) || eps <= 0) {
    showMessage("Epsilon must be a positive number", true);
    return;
  }
  
  if (!isFinite(minPts) || minPts < 1) {
    showMessage("Min Points must be at least 1", true);
    return;
  }
  
  const k = STATE.selectedFeatures.length;
  if (k < 1) {
    showMessage("Select at least one feature", true);
    return;
  }
  
  // Build feature matrix
  const n = STATE.rows.length;
  const mat = new Float32Array(n * k);
  
  for (let r = 0; r < n; r++) {
    for (let d = 0; d < k; d++) {
      const col = STATE.selectedFeatures[d];
      const val = parseFloat(STATE.rows[r][col]);
      mat[r * k + d] = isFinite(val) ? val : NaN;
    }
  }
  
  showMessage("Running DBSCAN...");
  el("btnRun").disabled = true;
  
  const t0 = performance.now();
  
  try {
    const traceEnable = animate;
    const traceMaxEvents = 50000;
    const traceMaxNeighbors = 100;
    
    console.log(`%c[DBSCAN] Running clustering with ${engineMode.toUpperCase()} engine`, 
      engineMode === 'wasm' ? 'color: #22c55e;' : 'color: #eab308;');
    console.log(`[DBSCAN] Parameters: n=${n}, dims=${k}, eps=${eps}, minPts=${minPts}, standardize=${standardize}`);

    const result = wasmApi.dbscan_fit(
      mat,
      n,
      k,
      eps,
      minPts,
      missingPolicy,
      standardize,
      traceEnable,
      traceMaxEvents,
      traceMaxNeighbors
    );
    
    const t1 = performance.now();
    const runtime = t1 - t0;
    
    console.log(`%c[DBSCAN] Complete: ${result.clusters} clusters, ${result.noise} noise points in ${runtime.toFixed(1)}ms`, 
      'color: #f59e0b;');

    // Clear plot-only data since we're clustering now
    STATE.plotData = null;
    
    // Compute classification (core=2, border=1, noise=0)
    let classification = null;
    try {
      if (wasmApi && typeof wasmApi.classify_points === 'function') {
        classification = wasmApi.classify_points(mat, n, k, eps, minPts, missingPolicy, standardize);
      }
    } catch (e) {
      console.warn("classify_points failed, computing manually:", e);
    }
    
    // Fallback: compute from trace data
    const labels = result.labels_full;
    const usedMask = result.used_mask;
    let coreCount = 0, borderCount = 0, noiseCount = 0;
    
    const coreSet = new Set();
    const borderSet = new Set();
    
    if (classification) {
      // Use WASM classification
      for (let r = 0; r < n; r++) {
        if (usedMask[r] !== 1) continue;
        const cls = classification[r];
        if (cls === 2) {
          coreCount++;
          coreSet.add(r);
        } else if (cls === 1) {
          borderCount++;
          borderSet.add(r);
        } else if (labels[r] === -1) {
          noiseCount++;
        }
      }
    } else if (result.trace_p && result.trace_p.length > 0) {
      // Use trace data
      for (let i = 0; i < result.trace_p.length; i++) {
        const p = result.trace_p[i];
        const nc = result.trace_neighbor_counts[i];
        if (nc >= minPts) {
          coreSet.add(p);
        }
      }
      
      for (let r = 0; r < n; r++) {
        if (usedMask[r] !== 1) continue;
        const lbl = labels[r];
        if (lbl === -1) {
          noiseCount++;
        } else if (coreSet.has(r)) {
          coreCount++;
        } else {
          borderCount++;
          borderSet.add(r);
        }
      }
    } else {
      // No classification available, just count noise
      for (let r = 0; r < n; r++) {
        if (usedMask[r] !== 1) continue;
        if (labels[r] === -1) noiseCount++;
        else coreCount++; // Assume all clustered are core (rough estimate)
      }
    }
    
    // Store classification for visualization
    STATE.classification = classification;
    
    STATE.lastResult = {
      ...result,
      coreSet,
      borderSet,
      runtime,
      eps,
      minPts,
      featureCols: STATE.selectedFeatures.slice(),
      standardize
    };
    
    // Update stats
    el("statClusters").textContent = result.clusters;
    el("statNoise").textContent = noiseCount;
    el("statCore").textContent = coreCount;
    el("statBorder").textContent = borderCount;
    el("statUsed").textContent = result.used_rows;
    el("statRuntime").textContent = `${runtime.toFixed(1)} ms`;
    
    updateUI();
    
    // Draw k-distance plot (async - uses WASM)
    await drawKDistancePlot(mat, n, k, minPts, result.means, result.stds, standardize, usedMask);
    
    // // Compute cluster quality metrics
    // try {
    //   await CLUSTER_METRICS.computeAndDisplayMetrics(wasmApi, mat, n, k, labels, minPts);
    // } catch (metricsErr) {
    //   console.warn('Metrics computation failed:', metricsErr);
    // }
    // Compute cluster quality metrics
    try {
      // Use standardized data for metrics if standardization was applied during clustering
      //this is a lot slower than before for accuracy, port over to Rust possibly standardized and non standardized?
      //lost in the sauce rn between rust calc, js parse/viz, and python backcheck. UI/UX/Css is an afterthought.
      let metricsData = mat;
      if (standardize && result.means && result.stds) {
        metricsData = new Float32Array(mat.length);
        for (let i = 0; i < n; i++) {
          for (let d = 0; d < k; d++) {
            const idx = i * k + d;
            const mean = result.means[d];
            const std = result.stds[d];
            metricsData[idx] = std > 0 ? (mat[idx] - mean) / std : 0;
          }
        }
      }
      await CLUSTER_METRICS.computeAndDisplayMetrics(wasmApi, metricsData, n, k, labels, minPts);
    } catch (metricsErr) {
      console.warn('Metrics computation failed:', metricsErr);
    }
    // Show legend
    el("legendBox").style.display = "block";
    updateLegend();
    
    if (animate && result.trace_p && result.trace_p.length > 0) {
      STATE.hasAnimationData = true;
      setupAnimation(result, mat, n, k, eps, minPts, standardize);
      // Paint at least one frame immediately; otherwise the canvas may not update
      // until user interaction (mousemove/drag/wheel).
      requestAnimationFrame(redrawPlot);
    } else {
      // Reset animation state for non-animated result
      STATE.hasAnimationData = false;
      STATE.anim.currentStep = 0;
      STATE.anim.events = [];
      STATE.anim.points2d = null;
      redrawPlot();
    }
    
    updateAnimationControls();
    
    showMessage(
      `DBSCAN complete!\n\n` +
      `‚Ä¢ Clusters: ${result.clusters}\n` +
      `‚Ä¢ Core points: ${coreCount}\n` +
      `‚Ä¢ Border points: ${borderCount}\n` +
      `‚Ä¢ Noise points: ${noiseCount}\n` +
      `‚Ä¢ Runtime: ${runtime.toFixed(1)} ms`
    );
    
  } catch (err) {
    showMessage(`Error: ${err.message || err}`, true);
    console.error(err);
  }
  
  el("btnRun").disabled = false;
}

// ============================================
// Plot Data Only (without clustering)
// ============================================

function plotDataOnly() {
  if (STATE.rows.length === 0 || STATE.selectedFeatures.length === 0) {
    showMessage("Load data and select features first", true);
    return;
  }
  
  const colX = parseInt(el("plotX").value);
  const colY = parseInt(el("plotY").value);
  const colZ = parseInt(el("plotZ").value);
  
  if (!isFinite(colX) || !isFinite(colY)) {
    showMessage("Select Plot X and Y axes first", true);
    return;
  }
  
  // Build data matrix
  const k = STATE.selectedFeatures.length;
  const n = STATE.rows.length;
  const mat = new Float32Array(n * k);
  
  for (let r = 0; r < n; r++) {
    for (let d = 0; d < k; d++) {
      mat[r * k + d] = parseFloat(STATE.rows[r][STATE.selectedFeatures[d]]) || NaN;
    }
  }
  
  // Extract plot coordinates
  const xs = [];
  const ys = [];
  const zs = [];
  
  for (let r = 0; r < n; r++) {
    const vx = parseFloat(STATE.rows[r][colX]);
    const vy = parseFloat(STATE.rows[r][colY]);
    const vz = isFinite(colZ) ? parseFloat(STATE.rows[r][colZ]) : 0;
    
    if (isFinite(vx) && isFinite(vy)) {
      xs.push(vx);
      ys.push(vy);
      zs.push(vz || 0);
    }
  }
  
  STATE.plotData = { xs, ys, zs };
  STATE.lastResult = null;
  STATE.classification = null;
  
  // Show legend
  el("legendBox").style.display = "block";
  updateLegend();
  
  // Render using the active plot mode (2D vs 3D)
  // redrawPlot() will route to renderPlotDataOnly3D() when plotMode === "3d".
  redrawPlot();

  // renderPlotDataOnly();
  showMessage(`Plotted ${xs.length} points. Ready for clustering.`);
  updateUI();
}

function renderPlotDataOnly() {
  if (!STATE.plotData) return;
  
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  const dpr = window.devicePixelRatio || 1;
  const zoom = parseFloat(el("zoomSlider").value) || 1;
  const panX = STATE.view2d.panX;
  const panY = STATE.view2d.panY;
  
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const { xs, ys } = STATE.plotData;
  const n = xs.length;
  if (n === 0) return;
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < n; i++) {
    minX = Math.min(minX, xs[i]);
    maxX = Math.max(maxX, xs[i]);
    minY = Math.min(minY, ys[i]);
    maxY = Math.max(maxY, ys[i]);
  }
  
  const pad = 70 * dpr;
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;
  const scale = Math.min((w - 2 * pad) / rangeX, (h - 2 * pad) / rangeY) * zoom;
  
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const offsetX = w / 2 + panX;
  const offsetY = h / 2 + panY;
  
  function toScreen(x, y) {
    return {
      sx: offsetX + (x - centerX) * scale,
      sy: offsetY - (y - centerY) * scale
    };
  }
  
  // Draw gridlines if enabled
  if (el("showGridlines").checked) {
    drawGridlines(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen, scale);
  }
  
  const pointSize = parseInt(el("pointSize").value) * dpr;
  
  // Draw points
  ctx.fillStyle = '#64748b';
  for (let i = 0; i < n; i++) {
    const { sx, sy } = toScreen(xs[i], ys[i]);
    ctx.beginPath();
    ctx.arc(sx, sy, pointSize, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw axis labels
  drawAxisLabels(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen);
}

// ============================================
// K-Distance Only
// ============================================

async function runKDistanceOnly() {
  if (STATE.rows.length === 0 || STATE.selectedFeatures.length === 0) {
    showMessage("Load data and select features first", true);
    return;
  }
  
  const k = STATE.selectedFeatures.length;
  const n = STATE.rows.length;
  const mat = new Float32Array(n * k);
  
  for (let r = 0; r < n; r++) {
    for (let d = 0; d < k; d++) {
      mat[r * k + d] = parseFloat(STATE.rows[r][STATE.selectedFeatures[d]]) || NaN;
    }
  }
  
  const minPts = parseInt(el("minPtsInput").value) || 5;
  const standardize = el("standardize").checked;
  const missingPolicyStr = el("missingPolicy").value;
  const missingPolicy = missingPolicyStr === "drop" ? 0 : missingPolicyStr === "impute" ? 1 : 2;
  
  // Build used mask for display
  const usedMask = new Uint8Array(n).fill(1);
  
  showMessage("Computing k-distance plot...");
  
  await drawKDistancePlot(mat, n, k, minPts, null, null, standardize, usedMask);
  
  showMessage(`K-distance plot computed for k=${minPts}. Use it to select an appropriate Œµ (look for the "elbow").`);
}

// ============================================
// Legend Management
// ============================================

function updateLegend() {
  const container = el("legendContent");
  const viewMode = el("viewMode").value;
  const animEnabled = el("animateCheck").checked;
  // Animation mode only when animation is enabled, has data, AND is in progress
  const isAnimating = animEnabled && STATE.hasAnimationData && STATE.anim.points2d && 
                      (STATE.anim.running || STATE.anim.currentStep > 0);
  
  // Animation mode shows different legend
  if (isAnimating) {
    container.innerHTML = `
      <div class="legend-item">
        <span class="legend-dot" style="background: #22c55e;"></span>
        Core Point
      </div>
      <div class="legend-item">
        <span class="legend-dot" style="background: #eab308; border: 2px solid white; box-sizing: border-box;"></span>
        Border Point
      </div>
      <div class="legend-item">
        <span class="legend-dot" style="background: #64748b;"></span>
        Noise / Unclassified
      </div>
      <div class="legend-item">
        <span class="legend-ring" style="border-color: #f59e0b;"></span>
        Œµ Radius
      </div>
      <div class="legend-item">
        <span class="legend-ring" style="border-color: #f97316;"></span>
        Current Point
      </div>
    `;
    return;
  }
  
  if (STATE.lastResult) {
    const numClusters = STATE.lastResult.clusters || 0;
    
    if (viewMode === "clusters") {
      let html = '';
      for (let c = 0; c < Math.min(numClusters, 10); c++) {
        html += `<div class="legend-item">
          <span class="legend-dot" style="background: ${getClusterColor(c)};"></span>
          Cluster ${c}
        </div>`;
      }
      if (numClusters > 10) {
        html += `<div class="legend-item" style="font-size: 0.7rem; color: var(--text-muted);">+ ${numClusters - 10} more...</div>`;
      }
      html += `<div class="legend-item">
        <span class="legend-dot" style="background: #64748b;"></span>
        Noise
      </div>`;
      container.innerHTML = html;
    } else {
      container.innerHTML = `
        <div class="legend-item">
          <span class="legend-dot" style="background: #22c55e;"></span>
          Core Point
        </div>
        <div class="legend-item">
          <span class="legend-dot" style="background: #eab308; border: 2px solid white; box-sizing: border-box;"></span>
          Border Point
        </div>
        <div class="legend-item">
          <span class="legend-dot" style="background: #64748b;"></span>
          Noise Point
        </div>
        <div class="legend-item">
          <span class="legend-ring" style="border-color: #f59e0b;"></span>
          Œµ Radius
        </div>
      `;
    }
  } else if (STATE.plotData) {
    container.innerHTML = `
      <div class="legend-item">
        <span class="legend-dot" style="background: #64748b;"></span>
        Data Point
      </div>
    `;
  } else {
    container.innerHTML = '';
  }
}

// ============================================
// Axis Labels
// ============================================

function drawAxisLabels(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen) {
  const colX = el("plotX");
  const colY = el("plotY");
  const xLabel = colX.options[colX.selectedIndex]?.text || "X";
  const yLabel = colY.options[colY.selectedIndex]?.text || "Y";
  
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
  const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');
  
  ctx.font = `600 ${13 * dpr}px 'Space Grotesk', sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // X axis label with background pill
  const xLabelWidth = ctx.measureText(xLabel).width + 16 * dpr;
  const xLabelX = w / 2;
  const xLabelY = h - 18 * dpr;
  
  ctx.fillStyle = bgColor;
  ctx.globalAlpha = 0.85;
  ctx.beginPath();
  ctx.roundRect(xLabelX - xLabelWidth / 2, xLabelY - 10 * dpr, xLabelWidth, 20 * dpr, 4 * dpr);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  ctx.fillStyle = textColor;
  ctx.fillText(xLabel, xLabelX, xLabelY);
  
  // Y axis label (rotated) with background pill
  ctx.save();
  const yLabelWidth = ctx.measureText(yLabel).width + 16 * dpr;
  const yLabelX = 22 * dpr;
  const yLabelY = h / 2;
  
  ctx.translate(yLabelX, yLabelY);
  ctx.rotate(-Math.PI / 2);
  
  ctx.fillStyle = bgColor;
  ctx.globalAlpha = 0.85;
  ctx.beginPath();
  ctx.roundRect(-yLabelWidth / 2, -10 * dpr, yLabelWidth, 20 * dpr, 4 * dpr);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  ctx.fillStyle = textColor;
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();
  
  // Draw tick marks and values
  ctx.font = `${9 * dpr}px 'JetBrains Mono', monospace`;
  ctx.fillStyle = mutedColor;
  ctx.textBaseline = 'top';  

  // X axis ticks
  const xTicks = 5;
  for (let i = 0; i <= xTicks; i++) {
    const val = minX + (maxX - minX) * (i / xTicks);
    const { sx, sy } = toScreen(val, minY);
    ctx.textAlign = 'center';
    ctx.fillText(val.toFixed(1), sx, h - 38 * dpr);
  }
  
  // Y axis ticks
  ctx.textBaseline = 'middle';
  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const val = minY + (maxY - minY) * (i / yTicks);
    const { sx, sy } = toScreen(minX, val);
    ctx.textAlign = 'right';
    ctx.fillText(val.toFixed(1), 48 * dpr, sy);
  }
}

// ============================================
// K-Distance Plot (WASM-accelerated)
// ============================================

async function drawKDistancePlot(mat, n, k, minPts, means, stds, standardize, usedMask) {
  const canvas = el("kdistCanvas");
  const ctx = canvas.getContext("2d");
  
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 120 * dpr;
  ctx.scale(dpr, dpr);
  
  const w = rect.width;
  const h = 120;
  
  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
  ctx.fillRect(0, 0, w, h);
  
  // Show loading indicator
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');
  ctx.font = '12px JetBrains Mono';
  ctx.fillText('Computing k-distances...', 10, h / 2);
  
  // Use WASM for k-distance computation (much faster with KD-tree)
  // const kForDist = Math.max(1, minPts);
  const kForDist = Math.max(1, minPts-1);
  const maxSample = 2000; // WASM can handle more samples efficiently
  
  let kDistances;
  try {
    // Check if WASM has compute_kdist
    if (wasmApi && typeof wasmApi.compute_kdist === 'function') {
      const missingPolicyStr = el("missingPolicy").value;
      const missingPolicy = missingPolicyStr === "drop" ? 0 : missingPolicyStr === "impute" ? 1 : 2;
      kDistances = wasmApi.compute_kdist(mat, n, k, kForDist, missingPolicy, standardize, maxSample);
    } else {
      // Use JS fallback
      console.error("compute_kdist not available on wasmApi");
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-error');
      ctx.fillText('K-distance function not available', 10, h / 2);
      return;
    }
  } catch (err) {
    console.error("K-distance computation failed:", err);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-error');
    ctx.fillText('K-distance computation failed', 10, h / 2);
    return;
  }
  
  if (!kDistances || kDistances.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');
    ctx.fillRect(0, 0, w, h);
    ctx.fillText('Not enough data for k-distance plot', 10, h / 2);
    return;
  }
  
  // Store for theme change redraw
  STATE.kDistData = { distances: Array.from(kDistances), minPts };
  
  // Draw the plot
  renderKDistPlot(kDistances, minPts);
}

function renderKDistPlot(kDistances, minPts) {
  const canvas = el("kdistCanvas");
  const ctx = canvas.getContext("2d");
  
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 120 * dpr;
  ctx.scale(dpr, dpr);
  
  const w = rect.width;
  const h = 120;
  
  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
  ctx.fillRect(0, 0, w, h);
  
  // Draw
  const pad = 20;

  // const maxDist = kDistances[kDistances.length - 1] * 1.1;

  //If all k distances are zero, maxDist = 0 and division = Inf or NaN,
  const maxDist = Math.max(kDistances[kDistances.length - 1] * 1.1, 1e-10);

  ctx.strokeStyle = '#f59e0b';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  
  //edge case wherein we have kDist length ==1
  const len = kDistances.length;
  for (let i = 0; i < len; i++) {
    const xRatio = len > 1 ? (i / (len - 1)) : 0.5;
    const x = pad + xRatio * (w - 2 * pad);
    const yRatio = maxDist > 0 ? (kDistances[i] / maxDist) : 0;
    const y = h - pad - yRatio * (h - 2 * pad);
    
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  
  ctx.stroke();
  
  // Draw current epsilon line
  const currentEps = parseFloat(el("epsInput").value);
  if (isFinite(currentEps) && currentEps <= maxDist) {
    const epsY = h - pad - (currentEps / maxDist) * (h - 2 * pad);
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad, epsY);
    ctx.lineTo(w - pad, epsY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#ef4444';
    ctx.font = '10px JetBrains Mono';
    ctx.fillText(`Œµ = ${currentEps}`, w - pad - 50, epsY - 4);
  }
  
  // Axis labels
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
  ctx.font = '10px Space Grotesk';
  
  // X axis label
  ctx.textAlign = 'center';
  ctx.fillText('Points (sorted)', w / 2, h - 3);
  
  // Y axis label
  ctx.save();
  ctx.translate(8, h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillText(`${minPts}-dist`, 0, 0);
  ctx.restore();
  
  // Show sample count and Y range
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');
  ctx.font = '8px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillText(`n=${kDistances.length}`, pad + 2, 10);
  ctx.textAlign = 'right';
  ctx.fillText(`max=${maxDist.toFixed(2)}`, w - pad, 10);
}

function redrawKDistPlot() {
  if (STATE.kDistData) {
    renderKDistPlot(STATE.kDistData.distances, STATE.kDistData.minPts);
  }
}

function updateLegendStyle() {
  // Force legend re-render with current theme colors
  updateLegend();
}

// ============================================
// Animation
// ============================================

/**
 * Check if the plotted dimensions match the clustering dimensions.
 * Returns an object with mismatch info.
 */
function checkDimensionMismatch(clusteringFeatures, plotX, plotY, plotZ, is3D) {
  const plottedFeatures = is3D && isFinite(plotZ) 
    ? [plotX, plotY, plotZ] 
    : [plotX, plotY];
  
  const clusteringDims = clusteringFeatures.length;
  const plottedDims = plottedFeatures.length;
  
  // Check if all plotted features are part of clustering features
  const allPlottedInClustering = plottedFeatures.every(f => clusteringFeatures.includes(f));
  
  // Check if we're showing all clustering dimensions
  const showingAllDims = clusteringDims <= plottedDims && 
    clusteringFeatures.every(f => plottedFeatures.includes(f));
  
  // There's a mismatch if:
  // 1. Clustering uses more dimensions than we're plotting, OR
  // 2. Plotted axes aren't all part of the clustering features
  const hasMismatch = clusteringDims > plottedDims || !allPlottedInClustering;
  
  let warningText = "";
  if (hasMismatch) {
    if (clusteringDims > plottedDims) {
      const hiddenDims = clusteringDims - plottedDims;
      warningText = `Clustering uses ${clusteringDims}D space but showing ${plottedDims}D. ` +
        `${hiddenDims} dimension${hiddenDims > 1 ? 's' : ''} hidden -- Œµ-radius may appear incorrect.`;
    } else if (!allPlottedInClustering) {
      warningText = `Plot axes include features not used in clustering. ` +
        `Œµ-radius computed in different feature space.`;
    }
  }
  
  return {
    hasMismatch,
    clusteringDims,
    plottedDims,
    plottedFeatures,
    warningText
  };
}

/**
 * Update dimension mismatch state when plot axes or mode changes.
 * Should be called when plotX, plotY, plotZ, or plotMode changes.
 */
function updateDimensionMismatch() {
  // Only relevant if we have animation data with clustering features
  if (!STATE.anim.clusteringFeatures || STATE.anim.clusteringFeatures.length === 0) {
    STATE.anim.dimensionMismatch = false;
    const warningEl = el("dimensionWarning");
    if (warningEl) warningEl.style.display = "none";
    return;
  }
  
  const colX = parseInt(el("plotX").value);
  const colY = parseInt(el("plotY").value);
  const colZ = parseInt(el("plotZ").value);
  const is3D = el("plotMode").value === "3d";
  
  if (!isFinite(colX) || !isFinite(colY)) return;
  
  const mismatchInfo = checkDimensionMismatch(
    STATE.anim.clusteringFeatures,
    colX, colY, colZ,
    is3D
  );
  
  STATE.anim.plottedFeatures = mismatchInfo.plottedFeatures;
  STATE.anim.dimensionMismatch = mismatchInfo.hasMismatch;
  STATE.anim.mismatchWarningText = mismatchInfo.warningText;
  
  // Update warning display
  const warningEl = el("dimensionWarning");
  const warningTextEl = el("dimensionWarningText");
  if (warningEl) {
    if (mismatchInfo.hasMismatch) {
      warningEl.style.display = "block";
      if (warningTextEl) warningTextEl.textContent = mismatchInfo.warningText;
    } else {
      warningEl.style.display = "none";
    }
  }
}

function setupAnimation(result, mat, n, k, eps, minPts, standardize) {
  stopAnimation();
  
  // Auto-switch to 3D mode when clustering uses 3+ features
  // This helps visualize more dimensions and reduces misleading 2D projections
  if (k >= 3 && el("plotMode").value !== "3d") {
    el("plotMode").value = "3d";
    showMessage(`Switched to 3D view (clustering uses ${k} features)`, false);
  }
  
  const colX = parseInt(el("plotX").value);
  const colY = parseInt(el("plotY").value);
  const colZ = parseInt(el("plotZ").value);
  
  if (!isFinite(colX) || !isFinite(colY)) {
    showMessage("Select Plot X and Y axes", true);
    return;
  }
  
  // Check for dimension mismatch
  const is3D = el("plotMode").value === "3d";
  const mismatchInfo = checkDimensionMismatch(
    STATE.selectedFeatures, 
    colX, colY, colZ, 
    is3D
  );
  
  // Store mismatch info in animation state
  STATE.anim.clusteringDims = k;
  STATE.anim.clusteringFeatures = STATE.selectedFeatures.slice();
  STATE.anim.plottedFeatures = mismatchInfo.plottedFeatures;
  STATE.anim.dimensionMismatch = mismatchInfo.hasMismatch;
  STATE.anim.mismatchWarningText = mismatchInfo.warningText;
  
  // Build 2D/3D points from used rows
  const usedMask = result.used_mask;
  const means = result.means;
  const stds = result.stds;
  
  const usedRowMap = [];
  for (let r = 0; r < n; r++) {
    if (usedMask[r] === 1) usedRowMap.push(r);
  }
  
  const points2d = { x: [], y: [] };
  const points3d = { x: [], y: [], z: [] };
  
  for (let i = 0; i < usedRowMap.length; i++) {
    const r = usedRowMap[i];
    
    let vx = parseFloat(STATE.rows[r][colX]);
    let vy = parseFloat(STATE.rows[r][colY]);
    let vz = isFinite(colZ) ? parseFloat(STATE.rows[r][colZ]) : 0;
    
    if (standardize && means && stds) {
      const dx = STATE.selectedFeatures.indexOf(colX);
      const dy = STATE.selectedFeatures.indexOf(colY);
      const dz = STATE.selectedFeatures.indexOf(colZ);
      
      if (dx >= 0) vx = (vx - means[dx]) / stds[dx];
      if (dy >= 0) vy = (vy - means[dy]) / stds[dy];
      if (dz >= 0) vz = (vz - means[dz]) / stds[dz];
    }
    
    points2d.x.push(isFinite(vx) ? vx : 0);
    points2d.y.push(isFinite(vy) ? vy : 0);
    points3d.x.push(isFinite(vx) ? vx : 0);
    points3d.y.push(isFinite(vy) ? vy : 0);
    points3d.z.push(isFinite(vz) ? vz : 0);
  }
  
  // Build events from trace
  const events = [];
  const traceLen = result.trace_p.length;

  const offs = result.trace_neighbor_offsets;
  const flatN = result.trace_neighbors;
  const nCnts = result.trace_neighbor_counts;

  for (let e = 0; e < traceLen; e++) {
    const pUsed = result.trace_p[e];
    const clusterRaw = result.trace_cluster[e];
    const kind = result.trace_kind[e];

    let off0 = 0;
    let off1 = 0;

    if (offs && offs.length === traceLen + 1) {
      off0 = offs[e];
      off1 = offs[e + 1];
    } else if (offs && offs.length === traceLen) {
      off0 = (e === 0) ? 0 : offs[e - 1];
      off1 = offs[e];
    } else {
      off0 = 0;
      off1 = 0;
    }

    const neighbors = [];
    if (flatN && off1 > off0) {
      for (let j = off0; j < off1; j++) neighbors.push(flatN[j]);
    }

    const neighborCount = (nCnts && e < nCnts.length) ? nCnts[e] : neighbors.length;
    const isCore = neighborCount >= minPts;

    let labelAfter = clusterRaw;
    if (kind === 0 && !isCore) labelAfter = -1;

    events.push({
      point: pUsed,
      cluster: labelAfter,
      activeCluster: clusterRaw,
      kind,
      neighbors,
      neighborCount,
      isCore
    });
  }
  
  // Initialize animation state
  STATE.anim.events = events;
  STATE.anim.currentStep = 0;
  STATE.anim.labels = new Int32Array(usedRowMap.length).fill(-2);
  STATE.anim.points2d = points2d;
  STATE.anim.points3d = points3d;
  STATE.anim.corePoints = new Set();
  STATE.anim.borderPoints = new Set();
  STATE.anim.neighborSet = new Set();
  STATE.anim.currentPoint = -1;
  STATE.anim.eps = eps;
  STATE.anim.means = means;
  STATE.anim.stds = stds;
  STATE.anim.usedRowMap = usedRowMap;
  STATE.anim.running = false;
  STATE.anim.paused = true;
  STATE.anim.minPts = minPts;
  
  // Update animation controls
  updateAnimationControls();
  
  el("overlayStats").style.display = "block";
  el("legendBox").style.display = "block";
  updateLegend();
  
  updateAnimProgress();
  renderAnimFrame();
}

function stopAnimation() {
  STATE.anim.running = false;
  STATE.anim.paused = true;
  
  if (STATE.anim.raf) {
    // cancelAnimationFrame(STATE.anim.raf);
    clearTimeout(STATE.anim.raf);
    STATE.anim.raf = null;
  }
  
  // Hide animation overlay but keep legend visible if we have results
  el("overlayStats").style.display = "none";
  // Don't hide legend - it's controlled by render functions
  
  updatePlayButton();
}

function togglePlay() {
  if (STATE.anim.events.length === 0) return;
  
  if (STATE.anim.running) {
    STATE.anim.running = false;
    STATE.anim.paused = true;

    if (STATE.anim.raf) {
      clearTimeout(STATE.anim.raf);   // correct for setTimeout
      STATE.anim.raf = null;
    }
  } else {
    STATE.anim.running = true;
    STATE.anim.paused = false;
    runAnimLoop();
  }
  
  updatePlayButton();
}

function updatePlayButton() {
  const icon = el("playIcon");
  if (STATE.anim.running) {
    icon.innerHTML = '<rect x="6" y="4" width="4" height="16" fill="currentColor"/><rect x="14" y="4" width="4" height="16" fill="currentColor"/>';
  } else {
    icon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>';
  }
}

function stepAnimation(count) {
  if (STATE.anim.events.length === 0) return;
  
  STATE.anim.running = false;
  STATE.anim.paused = true;
  updatePlayButton();
  
  const newStep = Math.max(0, Math.min(STATE.anim.events.length, STATE.anim.currentStep + count));
  
  // If stepping back, we need to rebuild state
  if (count < 0) {
    STATE.anim.currentStep = 0;
    STATE.anim.labels.fill(-2);
    STATE.anim.corePoints.clear();
    STATE.anim.borderPoints.clear();
    
    for (let i = 0; i < newStep; i++) {
      applyEvent(i);
    }
    STATE.anim.currentStep = newStep;
  } else {
    while (STATE.anim.currentStep < newStep) {
      applyEvent(STATE.anim.currentStep);
      STATE.anim.currentStep++;
    }
  }
  
  // Set current point and neighbors for display
  if (newStep > 0 && newStep <= STATE.anim.events.length) {
    const ev = STATE.anim.events[newStep - 1];
    STATE.anim.currentPoint = ev.point;
    STATE.anim.neighborSet = new Set(ev.neighbors);
  }
  
  updateAnimProgress();
  renderAnimFrame();
}

function resetAnimation() {
  STATE.anim.currentStep = 0;
  STATE.anim.labels.fill(-2);
  STATE.anim.corePoints.clear();
  STATE.anim.borderPoints.clear();
  STATE.anim.neighborSet.clear();
  STATE.anim.currentPoint = -1;
  STATE.anim.running = false;
  STATE.anim.paused = true;
  
  updatePlayButton();
  updateAnimProgress();
  renderAnimFrame();
}

function applyEvent(idx) {
  const ev = STATE.anim.events[idx];
  if (!ev) return;

  const p = ev.point;
  const newLabel = ev.cluster;

  // DBSCAN semantics:
  // - Noise marking can happen on a seed eval (kind 0 non-core)
  // - A point labeled noise may later be assigned to a cluster as a border point
  if (newLabel === -1) {
    // Mark noise
    STATE.anim.labels[p] = -1;

    // Ensure we don't still show it as core/border
    STATE.anim.corePoints.delete(p);
    STATE.anim.borderPoints.delete(p);
    return;
  }

  if (newLabel >= 0) {
    // Assign to a cluster (including "rescuing" a previously-noise point), difficult.
    STATE.anim.labels[p] = newLabel;

    if (ev.isCore) {
      STATE.anim.corePoints.add(p);
      STATE.anim.borderPoints.delete(p);
    } else {
      // Only border if it's actually assigned to a cluster
      STATE.anim.borderPoints.add(p);
      // NOTE: if it was core previously and later we see it as non-core, keep core.
      // (core-ness is a property of the point; it doesn't "toggle off" in DBSCAN)
      // So we don't delete corePoints here.
    }
    return;
  }

  // Otherwise (e.g., -2 sentinel), leave state unchanged.
}

function runAnimLoop() {
  if (!STATE.anim.running) return;
  
  const speed = STATE.anim.speed;
  const eventsPerFrame = Math.max(1, Math.round(speed * 5));
  
  for (let i = 0; i < eventsPerFrame && STATE.anim.currentStep < STATE.anim.events.length; i++) {
    applyEvent(STATE.anim.currentStep);
    STATE.anim.currentStep++;
  }
  
  // Update current point and neighbors
  if (STATE.anim.currentStep > 0) {
    const ev = STATE.anim.events[STATE.anim.currentStep - 1];
    STATE.anim.currentPoint = ev.point;
    STATE.anim.neighborSet = new Set(ev.neighbors);
  }
  
  updateAnimProgress();
  renderAnimFrame();
  
  if (STATE.anim.currentStep >= STATE.anim.events.length) {
    STATE.anim.running = false;
    STATE.anim.paused = true;
    updatePlayButton();
    el("animStatus").textContent = "Complete";
    return;
  }
  
  // Schedule next frame based on speed
  const delay = Math.max(16, Math.round(100 / speed));
  STATE.anim.raf = setTimeout(() => {
    if (STATE.anim.running) runAnimLoop();
  }, delay);
}

function updateAnimProgress() {
  const current = STATE.anim.currentStep;
  const total = STATE.anim.events.length;
  const pct = total > 0 ? (current / total * 100) : 0;
  
  el("progressFill").style.width = `${pct}%`;
  el("progressText").textContent = `${current} / ${total} events`;
  el("animStatus").textContent = STATE.anim.running ? "Playing" : (STATE.anim.paused ? "Paused" : "Ready");
}

function updateSpeed() {
  const val = parseFloat(el("speedSlider").value);
  const speed = Math.pow(10, val);
  STATE.anim.speed = speed;
  el("speedValue").textContent = speed < 1 ? `${speed.toFixed(2)}x` : `${speed.toFixed(1)}x`;
}

// ============================================
// Rendering
// ============================================

function renderAnimFrame() {
  if (!STATE.anim.points2d) return;
  
  const mode = el("plotMode").value;
  
  if (mode === "3d") {
    render3D();
  } else {
    render2D();
  }
  
  // Update overlay stats
  if (STATE.anim.currentPoint >= 0) {
    const cp = STATE.anim.currentPoint;
    const ev = STATE.anim.events[STATE.anim.currentStep - 1] || null;

    // Show both: used-index and original row index (helps debugging mismatches)
    const origRow = (STATE.anim.usedRowMap && cp < STATE.anim.usedRowMap.length)
      ? STATE.anim.usedRowMap[cp]
      : null;

    el("statCurrent").textContent = (origRow === null) ? `${cp}` : `${cp} (row ${origRow})`;

    const shownNeighbors = STATE.anim.neighborSet.size;
    const totalNeighbors = ev && typeof ev.neighborCount === "number" ? ev.neighborCount : shownNeighbors;

    el("statNeighbors").textContent =
      (totalNeighbors === shownNeighbors)
        ? `${shownNeighbors}`
        : `${shownNeighbors} shown / ${totalNeighbors} total`;

    const label = STATE.anim.labels[cp];
    const isCore = STATE.anim.corePoints.has(cp);
    const isNoise = (label === -1);

    // Important: if label is still -2, it's not "border" yet.
    let type = "Unclassified";
    if (isNoise) type = "Noise";
    else if (isCore) type = "Core";
    else if (label >= 0) type = "Border";

    el("statType").textContent = type;
    el("statType").className = `stat-value ${type.toLowerCase()}`;

    // Cluster should reflect the current label, not whatever ev.cluster was
    el("statCluster").textContent = (label >= 0) ? `${label}` : (label === -1 ? "noise" : "‚Äî");
  }
    
  // Show/hide dimension mismatch warning
  const warningEl = el("dimensionWarning");
  const warningTextEl = el("dimensionWarningText");
  if (warningEl && STATE.anim.dimensionMismatch) {
    warningEl.style.display = "block";
    if (warningTextEl && STATE.anim.mismatchWarningText) {
      warningTextEl.textContent = STATE.anim.mismatchWarningText;
    }
  } else if (warningEl) {
    warningEl.style.display = "none";
  }
}

function redrawPlot() {
  const is3D = el("plotMode").value === "3d";
  const animEnabled = el("animateCheck").checked;
  
  // If animation is enabled, in progress, and we have animation data
  if (animEnabled && STATE.hasAnimationData && STATE.anim.points2d && 
      (STATE.anim.running || STATE.anim.currentStep > 0)) {
    renderAnimFrame();
    return;
  }
  
  // If we have clustering results, render them
  if (STATE.lastResult) {
    if (is3D) {
      renderFinalResult3D();
    } else {
      renderFinalResult();
    }
    return;
  }
  
  // If we have plot-only data, render it
  if (STATE.plotData) {
    if (is3D) {
      renderPlotDataOnly3D();
    } else {
      renderPlotDataOnly();
    }
    return;
  }
  
  clearCanvas();
}

function render2D() {
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  
  const dpr = window.devicePixelRatio || 1;
  const zoom = parseFloat(el("zoomSlider").value) || 1;
  const panX = STATE.view2d.panX;
  const panY = STATE.view2d.panY;
  
  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const pts = STATE.anim.points2d;
  const labels = STATE.anim.labels;
  const n = pts.x.length;
  
  // Compute bounds
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < n; i++) {
    if (!isFinite(pts.x[i]) || !isFinite(pts.y[i])) continue;
    minX = Math.min(minX, pts.x[i]);
    maxX = Math.max(maxX, pts.x[i]);
    minY = Math.min(minY, pts.y[i]);
    maxY = Math.max(maxY, pts.y[i]);
  }
  
  const pad = 70 * dpr;
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;
  const scale = Math.min((w - 2 * pad) / rangeX, (h - 2 * pad) / rangeY) * zoom;
  
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const offsetX = w / 2 + panX;
  const offsetY = h / 2 + panY;
  
  function toScreen(x, y) {
    return {
      sx: offsetX + (x - centerX) * scale,
      sy: offsetY - (y - centerY) * scale
    };
  }
  
  const pointSize = parseInt(el("pointSize").value) * dpr;
  const showRadius = el("showRadius").checked;
  const showDensity = el("showDensityGrid").checked;
  const eps = STATE.anim.eps;
  
  // Draw gridlines if enabled
  if (el("showGridlines").checked) {
    drawGridlines(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen, scale);
  }
  
  // Draw density grid if enabled
  if (showDensity) {
    drawDensityGrid(ctx, pts, labels, toScreen, minX, maxX, minY, maxY, scale, eps, dpr);
  }
  
  // Draw epsilon radius around current point
  if (showRadius && STATE.anim.currentPoint >= 0) {
    const cp = STATE.anim.currentPoint;
    const { sx, sy } = toScreen(pts.x[cp], pts.y[cp]);
    const epsPixels = eps * scale;
    
    ctx.beginPath();
    ctx.arc(sx, sy, epsPixels, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)';
    ctx.lineWidth = 2 * dpr;
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(34, 211, 238, 0.08)';
    ctx.fill();
  }
  
  // Draw neighbor lines
  if (el("showNeighborLines").checked && STATE.anim.currentPoint >= 0 && STATE.anim.neighborSet.size > 0) {
    const cp = STATE.anim.currentPoint;
    const { sx: cx, sy: cy } = toScreen(pts.x[cp], pts.y[cp]);
    
    ctx.strokeStyle = 'rgba(249, 115, 22, 0.5)';
    ctx.lineWidth = 1.5 * dpr;
    
    for (const ni of STATE.anim.neighborSet) {
      const { sx, sy } = toScreen(pts.x[ni], pts.y[ni]);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(sx, sy);
      ctx.stroke();
    }
  }
  
  // Draw points
  for (let i = 0; i < n; i++) {
    if (!isFinite(pts.x[i]) || !isFinite(pts.y[i])) continue;
    
    const { sx, sy } = toScreen(pts.x[i], pts.y[i]);
    const label = labels[i];
    
    let color;
    if (label === -2) {
      color = 'rgba(100, 116, 139, 0.5)'; // Unclassified
    } else if (label === -1) {
      color = '#64748b'; // Noise
    } else {
      color = getClusterColor(label);
    }
    
    ctx.beginPath();
    ctx.arc(sx, sy, pointSize, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Draw core/border indicator
    if (STATE.anim.corePoints.has(i)) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2 * dpr;
      ctx.stroke();
    } else if (STATE.anim.borderPoints.has(i)) {
      ctx.strokeStyle = '#eab308';
      ctx.lineWidth = 1.5 * dpr;
      ctx.stroke();
    }
  }
  
  // Highlight current point
  if (STATE.anim.currentPoint >= 0) {
    const cp = STATE.anim.currentPoint;
    const { sx, sy } = toScreen(pts.x[cp], pts.y[cp]);
    
    ctx.beginPath();
    ctx.arc(sx, sy, pointSize + 6 * dpr, 0, Math.PI * 2);
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3 * dpr;
    ctx.stroke();
  }
  
  // Highlight neighbors
  for (const ni of STATE.anim.neighborSet) {
    if (ni === STATE.anim.currentPoint) continue;
    const { sx, sy } = toScreen(pts.x[ni], pts.y[ni]);
    
    ctx.beginPath();
    ctx.arc(sx, sy, pointSize + 3 * dpr, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(249, 115, 22, 0.8)';
    ctx.lineWidth = 2 * dpr;
    ctx.stroke();
  }
}

function render3D() {
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  const dpr = window.devicePixelRatio || 1;
  
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const pts = STATE.anim.points3d || STATE.anim.points2d;
  const labels = STATE.anim.labels;
  const n = pts.x.length;
  
  const view = STATE.view3d;
  const panX = view.panX || 0;
  const panY = view.panY || 0;
  
  // 3D projection
  const cosY = Math.cos(view.yaw);
  const sinY = Math.sin(view.yaw);
  const cosP = Math.cos(view.pitch);
  const sinP = Math.sin(view.pitch);
  
  // Compute bounds
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  let minZ = Infinity, maxZ = -Infinity;
  
  for (let i = 0; i < n; i++) {
    minX = Math.min(minX, pts.x[i]);
    maxX = Math.max(maxX, pts.x[i]);
    minY = Math.min(minY, pts.y[i]);
    maxY = Math.max(maxY, pts.y[i]);
    if (pts.z) {
      minZ = Math.min(minZ, pts.z[i]);
      maxZ = Math.max(maxZ, pts.z[i]);
    }
  }
  
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const cz = pts.z ? (minZ + maxZ) / 2 : 0;
  
  const range = Math.max(maxX - minX, maxY - minY, (maxZ - minZ) || 1);
  const scale = (Math.min(w, h) * 0.35) / range * view.zoom;
  
  function project(x, y, z) {
    // Guard against NaN inputs
    if (!isFinite(x) || !isFinite(y) || !isFinite(z)) {
      return { sx: w / 2, sy: h / 2, depth: 0 };
    }
    const px = (x - cx);
    const py = (y - cy);
    const pz = (z - cz);
    
    const rx = px * cosY - pz * sinY;
    const rz = px * sinY + pz * cosY;
    const ry = py * cosP - rz * sinP;
    const rz2 = py * sinP + rz * cosP;
    
    return {
      sx: w / 2 + rx * scale + panX,
      sy: h / 2 - ry * scale + panY,
      depth: rz2
    };
  }
  
  const pointSize = parseInt(el("pointSize").value) * dpr;
  const showRadius = el("showRadius").checked;
  const eps = STATE.anim.eps;
  
  // Sort by depth for proper rendering
  const sortedIndices = Array.from({ length: n }, (_, i) => i);
  sortedIndices.sort((a, b) => {
    const pa = project(pts.x[a], pts.y[a], pts.z ? pts.z[a] : 0);
    const pb = project(pts.x[b], pts.y[b], pts.z ? pts.z[b] : 0);
    return pa.depth - pb.depth;
  });
  
  // Draw epsilon sphere around current point (as wireframe circle)
  if (showRadius && STATE.anim.currentPoint >= 0) {
    const cp = STATE.anim.currentPoint;
    const cpProj = project(pts.x[cp], pts.y[cp], pts.z ? pts.z[cp] : 0);
    
    // Draw sphere outline (approximate with circles)
    ctx.strokeStyle = 'rgba(34, 211, 238, 0.3)';
    ctx.lineWidth = 1.5 * dpr;
    
    const epsScaled = eps * scale;
    
    // Main circle
    ctx.beginPath();
    ctx.arc(cpProj.sx, cpProj.sy, epsScaled, 0, Math.PI * 2);
    ctx.stroke();
    
    // Horizontal ellipse
    ctx.beginPath();
    ctx.ellipse(cpProj.sx, cpProj.sy, epsScaled, epsScaled * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
    
    // Vertical ellipse
    ctx.beginPath();
    ctx.ellipse(cpProj.sx, cpProj.sy, epsScaled * 0.3, epsScaled, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Draw neighbor lines in 3D
  if (el("showNeighborLines").checked && STATE.anim.currentPoint >= 0 && STATE.anim.neighborSet.size > 0) {
    const cp = STATE.anim.currentPoint;
    const cpProj = project(pts.x[cp], pts.y[cp], pts.z ? pts.z[cp] : 0);
    
    ctx.strokeStyle = 'rgba(249, 115, 22, 0.6)';
    ctx.lineWidth = 2 * dpr;
    
    for (const ni of STATE.anim.neighborSet) {
      if (ni === cp || ni < 0 || ni >= n) continue;
      if (!isFinite(pts.x[ni]) || !isFinite(pts.y[ni])) continue;
      
      const niProj = project(pts.x[ni], pts.y[ni], pts.z ? pts.z[ni] : 0);
      
      ctx.beginPath();
      ctx.moveTo(cpProj.sx, cpProj.sy);
      ctx.lineTo(niProj.sx, niProj.sy);
      ctx.stroke();
    }
  }
  
  // Draw points
  for (const i of sortedIndices) {
    const z = pts.z ? pts.z[i] : 0;
    const { sx, sy, depth } = project(pts.x[i], pts.y[i], z);
    
    const label = labels[i];
    let color;
    
    if (label === -2) {
      color = 'rgba(100, 116, 139, 0.5)';
    } else if (label === -1) {
      color = '#64748b';
    } else {
      color = getClusterColor(label);
    }
    
    // Depth-based size adjustment
    const depthFactor = 0.7 + 0.3 * (depth / (range / 2) + 1);
    const size = pointSize * depthFactor;
    
    ctx.beginPath();
    ctx.arc(sx, sy, size, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    if (STATE.anim.corePoints.has(i)) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2 * dpr;
      ctx.stroke();
    }
  }
  
  // Highlight current point
  if (STATE.anim.currentPoint >= 0) {
    const cp = STATE.anim.currentPoint;
    const z = pts.z ? pts.z[cp] : 0;
    const { sx, sy } = project(pts.x[cp], pts.y[cp], z);
    
    ctx.beginPath();
    ctx.arc(sx, sy, pointSize + 6 * dpr, 0, Math.PI * 2);
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3 * dpr;
    ctx.stroke();
  }
  
  // Draw 3D axes
  draw3DAxes(ctx, w, h, dpr, project, range, minX, maxX, minY, maxY, minZ, maxZ);
}

function draw3DAxes(ctx, w, h, dpr, project, range, minX, maxX, minY, maxY, minZ, maxZ) {
  const axisLen = range * 0.5;
  const origin = project(0, 0, 0);
  
  // Get axis labels
  const colX = el("plotX");
  const colY = el("plotY");
  const colZ = el("plotZ");
  const xLabel = colX.options[colX.selectedIndex]?.text || "X";
  const yLabel = colY.options[colY.selectedIndex]?.text || "Y";
  const zLabel = colZ.options[colZ.selectedIndex]?.text || "Z";
  
  ctx.lineWidth = 2 * dpr;
  ctx.font = `bold ${12 * dpr}px 'Space Grotesk', sans-serif`;
  
  // X axis (red)
  const xEnd = project(axisLen, 0, 0);
  ctx.strokeStyle = '#ef4444';
  ctx.beginPath();
  ctx.moveTo(origin.sx, origin.sy);
  ctx.lineTo(xEnd.sx, xEnd.sy);
  ctx.stroke();

  // Draw arrowhead for X
  drawArrowhead(ctx, origin.sx, origin.sy, xEnd.sx, xEnd.sy, 8 * dpr, '#ef4444');

  ctx.fillStyle = '#ef4444';
  ctx.textAlign = 'left';
  ctx.fillText(xLabel, xEnd.sx + 8 * dpr, xEnd.sy + 4 * dpr);
  
  // Y axis (green)
  const yEnd = project(0, axisLen, 0);
  ctx.strokeStyle = '#22c55e';
  ctx.beginPath();
  ctx.moveTo(origin.sx, origin.sy);
  ctx.lineTo(yEnd.sx, yEnd.sy);
  ctx.stroke();

  // Draw arrowhead for Y
  drawArrowhead(ctx, origin.sx, origin.sy, yEnd.sx, yEnd.sy, 8 * dpr, '#22c55e');

  ctx.fillStyle = '#22c55e';
  ctx.fillText(yLabel, yEnd.sx + 8 * dpr, yEnd.sy + 4 * dpr);
  
  // Z axis (blue)
  const zEnd = project(0, 0, axisLen);
  ctx.strokeStyle = '#3b82f6';
  ctx.beginPath();
  ctx.moveTo(origin.sx, origin.sy);
  ctx.lineTo(zEnd.sx, zEnd.sy);
  ctx.stroke();

  // Draw arrowhead for Z
  drawArrowhead(ctx, origin.sx, origin.sy, zEnd.sx, zEnd.sy, 8 * dpr, '#3b82f6');

  ctx.fillStyle = '#3b82f6';
  ctx.fillText(zLabel, zEnd.sx + 8 * dpr, zEnd.sy + 4 * dpr);
  
  // Draw corner legend box
  draw3DAxisLegend(ctx, w, h, dpr, xLabel, yLabel, zLabel);
}

function drawArrowhead(ctx, fromX, fromY, toX, toY, size, color) {
  const angle = Math.atan2(toY - fromY, toX - fromX);
  
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(
    toX - size * Math.cos(angle - Math.PI / 6),
    toY - size * Math.sin(angle - Math.PI / 6)
  );
  ctx.lineTo(
    toX - size * Math.cos(angle + Math.PI / 6),
    toY - size * Math.sin(angle + Math.PI / 6)
  );
  ctx.closePath();
  ctx.fill();
}

function draw3DAxisLegend(ctx, w, h, dpr, xLabel, yLabel, zLabel) {
  const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
  const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');
  
  // Legend box dimensions
  const padding = 10 * dpr;
  const lineHeight = 18 * dpr;
  const dotSize = 8 * dpr;
  const boxWidth = 140 * dpr;
  const boxHeight = padding * 2 + lineHeight * 3.5;
  const boxX = w - boxWidth - 12 * dpr;
  const boxY = 12 * dpr;
  
  // Draw background
  ctx.fillStyle = bgColor;
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 8 * dpr);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Draw border
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1 * dpr;
  ctx.stroke();
  
  // Header
  ctx.fillStyle = mutedColor;
  ctx.font = `${10 * dpr}px 'JetBrains Mono', monospace`;
  ctx.textAlign = 'left';
  ctx.fillText('AXES', boxX + padding, boxY + padding + 8 * dpr);
  
  // Axis entries
  ctx.font = `500 ${11 * dpr}px 'Space Grotesk', sans-serif`;
  const startY = boxY + padding + lineHeight + 4 * dpr;
  
  const axes = [
    { color: '#ef4444', label: xLabel, axis: 'X' },
    { color: '#22c55e', label: yLabel, axis: 'Y' },
    { color: '#3b82f6', label: zLabel, axis: 'Z' }
  ];
  
  axes.forEach((item, i) => {
    const y = startY + i * lineHeight;
    
    // Color dot
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(boxX + padding + dotSize / 2, y, dotSize / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Axis letter
    ctx.fillStyle = item.color;
    ctx.fillText(item.axis + ':', boxX + padding + dotSize + 6 * dpr, y + 4 * dpr);
    
    // Column name (truncate if needed)
    ctx.fillStyle = textColor;
    let displayLabel = item.label;
    const maxLabelWidth = boxWidth - padding * 2 - dotSize - 30 * dpr;
    while (ctx.measureText(displayLabel).width > maxLabelWidth && displayLabel.length > 3) {
      displayLabel = displayLabel.slice(0, -1);
    }
    if (displayLabel !== item.label) displayLabel += '‚Ä¶';
    ctx.fillText(displayLabel, boxX + padding + dotSize + 28 * dpr, y + 4 * dpr);
  });
}

function renderFinalResult() {
  if (!STATE.lastResult) return;
  
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  const dpr = window.devicePixelRatio || 1;
  const zoom = parseFloat(el("zoomSlider").value) || 1;
  const viewMode = el("viewMode").value;
  const panX = STATE.view2d.panX;
  const panY = STATE.view2d.panY;
  
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const colX = parseInt(el("plotX").value);
  const colY = parseInt(el("plotY").value);
  
  if (!isFinite(colX) || !isFinite(colY)) return;
  
  const labels = STATE.lastResult.labels_full;
  const usedMask = STATE.lastResult.used_mask;
  const means = STATE.lastResult.means;
  const stds = STATE.lastResult.stds;
  const standardize = STATE.lastResult.standardize;
  const classification = STATE.classification;
  
  const xs = [];
  const ys = [];
  const lbls = [];
  const rowIndices = [];
  
  for (let r = 0; r < STATE.rows.length; r++) {
    if (usedMask[r] !== 1) continue;
    
    let vx = parseFloat(STATE.rows[r][colX]);
    let vy = parseFloat(STATE.rows[r][colY]);
    
    if (standardize && means && stds) {
      const dx = STATE.selectedFeatures.indexOf(colX);
      const dy = STATE.selectedFeatures.indexOf(colY);
      if (dx >= 0) vx = (vx - means[dx]) / stds[dx];
      if (dy >= 0) vy = (vy - means[dy]) / stds[dy];
    }
    
    if (isFinite(vx) && isFinite(vy)) {
      xs.push(vx);
      ys.push(vy);
      lbls.push(labels[r]);
      rowIndices.push(r);
    }
  }
  
  if (xs.length === 0) return;
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < xs.length; i++) {
    minX = Math.min(minX, xs[i]);
    maxX = Math.max(maxX, xs[i]);
    minY = Math.min(minY, ys[i]);
    maxY = Math.max(maxY, ys[i]);
  }
  
  const pad = 70 * dpr;
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;
  const scale = Math.min((w - 2 * pad) / rangeX, (h - 2 * pad) / rangeY) * zoom;
  
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const offsetX = w / 2 + panX;
  const offsetY = h / 2 + panY;
  
  function toScreen(x, y) {
    return {
      sx: offsetX + (x - centerX) * scale,
      sy: offsetY - (y - centerY) * scale
    };
  }
  
  // Draw gridlines if enabled
  // crap implementation, need to improve at some point.
  if (el("showGridlines").checked) {
    drawGridlines(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen, scale);
  }
  
  // Draw density grid if enabled
  // crap implementation, need to improve at some point.
  if (el("showDensityGrid").checked) {
    const eps = parseFloat(el("epsInput").value) || 0.5;
    const pts = { x: xs, y: ys };
    drawDensityGrid(ctx, pts, lbls, toScreen, minX, maxX, minY, maxY, scale, eps, dpr);
  }
  
  const pointSize = parseInt(el("pointSize").value) * dpr;
  
  // Draw points based on view mode
  for (let i = 0; i < xs.length; i++) {
    const { sx, sy } = toScreen(xs[i], ys[i]);
    const label = lbls[i];
    const rowIdx = rowIndices[i];
    
    if (viewMode === "clusters") {
      // Cluster-based coloring
      const color = label === -1 ? '#64748b' : getClusterColor(label);
      
      ctx.beginPath();
      ctx.arc(sx, sy, pointSize, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      
      // Border points get a white outline to distinguish them
      if (classification && classification[rowIdx] === 1) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2 * dpr;
        ctx.stroke();
      }
    } else {
      // Classification-based coloring (Core/Border/Noise)
      let color = '#64748b'; // Default noise
      let isCore = false;
      let isBorder = false;
      
      if (classification) {
        if (classification[rowIdx] === 2) {
          color = '#22c55e'; // Core - green
          isCore = true;
        } else if (classification[rowIdx] === 1) {
          // Border - use cluster color with yellow outline
          color = label >= 0 ? getClusterColor(label) : '#eab308';
          isBorder = true;
        }
      } else if (label >= 0) {
        color = getClusterColor(label);
      }
      
      ctx.beginPath();
      ctx.arc(sx, sy, pointSize, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      
      // Border points get a yellow/white ring
      if (isBorder) {
        ctx.strokeStyle = '#eab308';
        ctx.lineWidth = 2 * dpr;
        ctx.stroke();
      } else if (isCore) {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1 * dpr;
        ctx.stroke();
      }
    }
  }
  
  // Draw axis labels
  drawAxisLabels(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen);
  
  // Show legend
  el("legendBox").style.display = "block";
  updateLegend();
}

function renderFinalResult3D() {
  if (!STATE.lastResult) return;
  
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  const dpr = window.devicePixelRatio || 1;
  const viewMode = el("viewMode").value;
  
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const colX = parseInt(el("plotX").value);
  const colY = parseInt(el("plotY").value);
  const colZ = parseInt(el("plotZ").value);
  
  if (!isFinite(colX) || !isFinite(colY)) return;
  
  const labels = STATE.lastResult.labels_full;
  const usedMask = STATE.lastResult.used_mask;
  const means = STATE.lastResult.means;
  const stds = STATE.lastResult.stds;
  const standardize = STATE.lastResult.standardize;
  const classification = STATE.classification;
  
  const xs = [], ys = [], zs = [], lbls = [], rowIndices = [];
  
  for (let r = 0; r < STATE.rows.length; r++) {
    if (usedMask[r] !== 1) continue;
    
    let vx = parseFloat(STATE.rows[r][colX]);
    let vy = parseFloat(STATE.rows[r][colY]);
    let vz = isFinite(colZ) ? parseFloat(STATE.rows[r][colZ]) : 0;
    
    if (standardize && means && stds) {
      const dx = STATE.selectedFeatures.indexOf(colX);
      const dy = STATE.selectedFeatures.indexOf(colY);
      const dz = STATE.selectedFeatures.indexOf(colZ);
      if (dx >= 0) vx = (vx - means[dx]) / stds[dx];
      if (dy >= 0) vy = (vy - means[dy]) / stds[dy];
      if (dz >= 0) vz = (vz - means[dz]) / stds[dz];
    }
    
    if (isFinite(vx) && isFinite(vy)) {
      xs.push(vx);
      ys.push(vy);
      zs.push(isFinite(vz) ? vz : 0);
      lbls.push(labels[r]);
      rowIndices.push(r);
    }
  }
  
  if (xs.length === 0) return;
  
  // Compute bounds
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  let minZ = Infinity, maxZ = -Infinity;
  
  for (let i = 0; i < xs.length; i++) {
    minX = Math.min(minX, xs[i]); maxX = Math.max(maxX, xs[i]);
    minY = Math.min(minY, ys[i]); maxY = Math.max(maxY, ys[i]);
    minZ = Math.min(minZ, zs[i]); maxZ = Math.max(maxZ, zs[i]);
  }
  
  const view = STATE.view3d;
  const panX = view.panX || 0;
  const panY = view.panY || 0;
  
  const cosY = Math.cos(view.yaw);
  const sinY = Math.sin(view.yaw);
  const cosP = Math.cos(view.pitch);
  const sinP = Math.sin(view.pitch);
  
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const cz = (minZ + maxZ) / 2;
  
  const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ) || 1;
  const scale = (Math.min(w, h) * 0.35) / range * view.zoom;
  
  function project(x, y, z) {
    const px = x - cx, py = y - cy, pz = z - cz;
    const rx = px * cosY - pz * sinY;
    const rz = px * sinY + pz * cosY;
    const ry = py * cosP - rz * sinP;
    const rz2 = py * sinP + rz * cosP;
    return { sx: w / 2 + rx * scale + panX, sy: h / 2 - ry * scale + panY, depth: rz2 };
  }
  
  // const pointSize = parseInt(el("pointSize").value) * dpr;
  
  // // Sort by depth
  // const sortedIndices = xs.map((_, i) => i).sort((a, b) => {
  //   return project(xs[a], ys[a], zs[a]).depth - project(xs[b], ys[b], zs[b]).depth;
  // });
  
  // // Draw points
  // for (const i of sortedIndices) {
  //   const { sx, sy, depth } = project(xs[i], ys[i], zs[i]);
  //   const label = lbls[i];
  //   const rowIdx = rowIndices[i];
    
  //   // Depth-based sizing
  //   const depthFactor = 0.7 + 0.3 * (depth - minZ) / (maxZ - minZ || 1);
  //   const size = pointSize * depthFactor;
    
  //   let color;
  //   if (viewMode === "clusters") {
  //     color = label === -1 ? '#64748b' : getClusterColor(label);
  //   } else {
  //     if (classification && classification[rowIdx] === 2) {
  //       color = '#22c55e';
  //     } else if (classification && classification[rowIdx] === 1) {
  //       color = label >= 0 ? getClusterColor(label) : '#eab308';
  //     } else {
  //       color = '#64748b';
  //     }
  //   }
    
  //   ctx.beginPath();
  //   ctx.arc(sx, sy, size, 0, Math.PI * 2);
  //   ctx.fillStyle = color;
  //   ctx.fill();
    
  //   // Border indicators
  //   if (classification && classification[rowIdx] === 1) {
  //     ctx.strokeStyle = viewMode === "clusters" ? '#ffffff' : '#eab308';
  //     ctx.lineWidth = 1.5 * dpr;
  //     ctx.stroke();
  //   }
  // }

  const pointSize = parseInt(el("pointSize").value) * dpr;
  
  // Use LOD during interaction for smoother rotation
  const isInteracting = STATE.renderQuality === 'low';
  const stride = isInteracting ? (xs.length > 20000 ? 4 : xs.length > 10000 ? 2 : 1) : 1;
  
  // Cache key includes viewMode since colors depend on it
  const cacheKey = `clustered_${view.yaw.toFixed(3)}_${view.pitch.toFixed(3)}_${viewMode}`;
  
  // Project all points and sort by depth (cached)
  if (STATE.depthCache?.key !== cacheKey || STATE.depthCache?.n !== xs.length) {
    const projected = new Float32Array(xs.length * 3);
    for (let i = 0; i < xs.length; i++) {
      const p = project(xs[i], ys[i], zs[i]);
      projected[i * 3] = p.sx;
      projected[i * 3 + 1] = p.sy;
      projected[i * 3 + 2] = p.depth;
    }
    
    const sortedIndices = new Uint32Array(xs.length);
    for (let i = 0; i < xs.length; i++) sortedIndices[i] = i;
    // sortedIndices.sort((a, b) => projected[a * 3 + 2] - projected[b * 3 + 2]);
    sortedIndices.sort((a, b) => {
      const da = projected[a * 3 + 2];
      const db = projected[b * 3 + 2];
      return da < db ? -1 : da > db ? 1 : 0;
    });
    
    STATE.depthCache = { key: cacheKey, n: xs.length, projected, sortedIndices };
  }
  
  const { projected, sortedIndices } = STATE.depthCache;
  const depthRange = maxZ - minZ || 1;
  
  // Batch points by color+size for faster rendering
  const colorBuckets = new Map();
  const sizeQuantization = 4;
  const borderPoints = []; // Track border points for stroke pass
  
  for (let si = 0; si < sortedIndices.length; si += stride) {
    const i = sortedIndices[si];
    const sx = projected[i * 3];
    const sy = projected[i * 3 + 1];
    const depth = projected[i * 3 + 2];
    const label = lbls[i];
    const rowIdx = rowIndices[i];
    
    const depthFactor = 0.7 + 0.3 * (depth - minZ) / depthRange;
    const size = pointSize * depthFactor;
    const quantizedSize = Math.round(size * sizeQuantization) / sizeQuantization;
    
    let color;
    if (viewMode === "clusters") {
      color = label === -1 ? '#64748b' : getClusterColor(label);
    } else {
      if (classification && classification[rowIdx] === 2) {
        color = '#22c55e';
      } else if (classification && classification[rowIdx] === 1) {
        color = label >= 0 ? getClusterColor(label) : '#eab308';
      } else {
        color = '#64748b';
      }
    }
    
    const bucketKey = `${color}_${quantizedSize}`;
    if (!colorBuckets.has(bucketKey)) {
      colorBuckets.set(bucketKey, { color, size: quantizedSize, points: [] });
    }
    colorBuckets.get(bucketKey).points.push({ sx, sy });
    
    // Track border points for second pass
    if (classification && classification[rowIdx] === 1) {
      borderPoints.push({ sx, sy, size: quantizedSize });
    }
  }
  
  // Draw all points batched by color
  for (const [, bucket] of colorBuckets) {
    ctx.fillStyle = bucket.color;
    ctx.beginPath();
    for (const pt of bucket.points) {
      ctx.moveTo(pt.sx + bucket.size, pt.sy);
      ctx.arc(pt.sx, pt.sy, bucket.size, 0, Math.PI * 2);
    }
    ctx.fill();
  }
  
  // Draw border indicators in a second pass (only if not too many)
  if (borderPoints.length < 5000 && !isInteracting) {
    ctx.strokeStyle = viewMode === "clusters" ? '#ffffff' : '#eab308';
    ctx.lineWidth = 1.5 * dpr;
    ctx.beginPath();
    for (const pt of borderPoints) {
      ctx.moveTo(pt.sx + pt.size, pt.sy);
      ctx.arc(pt.sx, pt.sy, pt.size, 0, Math.PI * 2);
    }
    ctx.stroke();
  }
  //end of edits...
  // Draw 3D axes
  draw3DAxes(ctx, w, h, dpr, project, range, minX, maxX, minY, maxY, minZ, maxZ);
  
  el("legendBox").style.display = "block";
  updateLegend();
}

function renderPlotDataOnly3D() {
  if (!STATE.plotData) return;
  
  const canvas = el("plotCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;
  const dpr = window.devicePixelRatio || 1;
  
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-card');
  ctx.fillRect(0, 0, w, h);
  
  const { xs, ys, zs } = STATE.plotData;
  const n = xs.length;
  if (n === 0) return;
  
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  let minZ = Infinity, maxZ = -Infinity;
  
  for (let i = 0; i < n; i++) {
    minX = Math.min(minX, xs[i]); maxX = Math.max(maxX, xs[i]);
    minY = Math.min(minY, ys[i]); maxY = Math.max(maxY, ys[i]);
    minZ = Math.min(minZ, zs[i] || 0); maxZ = Math.max(maxZ, zs[i] || 0);
  }
  
  const view = STATE.view3d;
  const panX = view.panX || 0;
  const panY = view.panY || 0;
  
  const cosY = Math.cos(view.yaw);
  const sinY = Math.sin(view.yaw);
  const cosP = Math.cos(view.pitch);
  const sinP = Math.sin(view.pitch);
  
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const cz = (minZ + maxZ) / 2;
  
  const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ) || 1;
  const scale = (Math.min(w, h) * 0.35) / range * view.zoom;
  
  function project(x, y, z) {
    const px = x - cx, py = y - cy, pz = z - cz;
    const rx = px * cosY - pz * sinY;
    const rz = px * sinY + pz * cosY;
    const ry = py * cosP - rz * sinP;
    const rz2 = py * sinP + rz * cosP;
    return { sx: w / 2 + rx * scale + panX, sy: h / 2 - ry * scale + panY, depth: rz2 };
  }
  
  const pointSize = parseInt(el("pointSize").value) * dpr;
  
  // Sort by depth
  // const sortedIndices = xs.map((_, i) => i).sort((a, b) => {
  //   return project(xs[a], ys[a], zs[a] || 0).depth - project(xs[b], ys[b], zs[b] || 0).depth;
  // });
  // Cache projected points and sort indices
  // Only recalculate when view changes significantly
  const cacheKey = `${view.yaw.toFixed(3)}_${view.pitch.toFixed(3)}`;

  if (STATE.depthCache?.key !== cacheKey || STATE.depthCache?.n !== xs.length) {
    const projected = new Float32Array(xs.length * 3);
    for (let i = 0; i < xs.length; i++) {
      const p = project(xs[i], ys[i], zs[i] || 0);
      projected[i * 3] = p.sx;
      projected[i * 3 + 1] = p.sy;
      projected[i * 3 + 2] = p.depth;
    }
    
    const sortedIndices = new Uint32Array(xs.length);
    for (let i = 0; i < xs.length; i++) sortedIndices[i] = i;
    // sortedIndices.sort((a, b) => projected[a * 3 + 2] - projected[b * 3 + 2]);
    sortedIndices.sort((a, b) => {
      const da = projected[a * 3 + 2];
      const db = projected[b * 3 + 2];
      return da < db ? -1 : da > db ? 1 : 0;
    });
    
    STATE.depthCache = { key: cacheKey, n: xs.length, projected, sortedIndices };
  }

  const { projected, sortedIndices } = STATE.depthCache;
  
  // Draw points
  // ctx.fillStyle = '#64748b';
  // for (const i of sortedIndices) {
  //   const { sx, sy, depth } = project(xs[i], ys[i], zs[i] || 0);
  //   const depthFactor = 0.7 + 0.3 * ((depth - minZ) / (range || 1));
  //   const size = pointSize * Math.max(0.5, depthFactor);
    
  //   ctx.beginPath();
  //   ctx.arc(sx, sy, size, 0, Math.PI * 2);
  //   ctx.fill();
  // }
  // Batch points by color and approximate size for faster rendering

// Batch points by size for faster rendering (single color for unclustered data)
  const sizeBuckets = new Map();
  const sizeQuantization = 4; // Quantize sizes to reduce draw calls
  const defaultColor = '#64748b'; // Gray for unclustered data
  
  for (const i of sortedIndices) {
    const sx = projected[i * 3];
    const sy = projected[i * 3 + 1];
    const depth = projected[i * 3 + 2];
    
    const depthFactor = 0.7 + 0.3 * ((depth - minZ) / (range || 1));
    const size = pointSize * Math.max(0.5, depthFactor);
    const quantizedSize = Math.round(size * sizeQuantization) / sizeQuantization;
    
    if (!sizeBuckets.has(quantizedSize)) {
      sizeBuckets.set(quantizedSize, []);
    }
    sizeBuckets.get(quantizedSize).push({ sx, sy });
  }
  
  // Draw each bucket with a single style change
  ctx.fillStyle = defaultColor;
  for (const [size, points] of sizeBuckets) {
    ctx.beginPath();
    
    for (const pt of points) {
      ctx.moveTo(pt.sx + size, pt.sy);
      ctx.arc(pt.sx, pt.sy, size, 0, Math.PI * 2);
    }
    
    ctx.fill();
  }
//end of edits...

  // Draw 3D axes
  draw3DAxes(ctx, w, h, dpr, project, range, minX, maxX, minY, maxY, minZ, maxZ);
  
  el("legendBox").style.display = "block";
  updateLegend();
}

function drawGridlines(ctx, w, h, dpr, minX, maxX, minY, maxY, toScreen, scale) {
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.3;
  
  // Calculate nice grid spacing
  const rangeX = maxX - minX;
  const rangeY = maxY - minY;
  
  function niceStep(range) {
    const rough = range / 8;
    const exp = Math.floor(Math.log10(rough));
    const frac = rough / Math.pow(10, exp);
    let nice;
    if (frac <= 1) nice = 1;
    else if (frac <= 2) nice = 2;
    else if (frac <= 5) nice = 5;
    else nice = 10;
    return nice * Math.pow(10, exp);
  }
  
  const stepX = niceStep(rangeX);
  const stepY = niceStep(rangeY);
  
  // Vertical gridlines
  const startX = Math.ceil(minX / stepX) * stepX;
  for (let x = startX; x <= maxX; x += stepX) {
    const { sx } = toScreen(x, minY);
    ctx.beginPath();
    ctx.moveTo(sx, 0);
    ctx.lineTo(sx, h);
    ctx.stroke();
  }
  
  // Horizontal gridlines
  const startY = Math.ceil(minY / stepY) * stepY;
  for (let y = startY; y <= maxY; y += stepY) {
    const { sy } = toScreen(minX, y);
    ctx.beginPath();
    ctx.moveTo(0, sy);
    ctx.lineTo(w, sy);
    ctx.stroke();
  }
  
  ctx.globalAlpha = 1;
}

function drawDensityGrid(ctx, pts, labels, toScreen, minX, maxX, minY, maxY, scale, eps, dpr) {
  const gridSize = eps;
  const cols = Math.ceil((maxX - minX) / gridSize);
  const rows = Math.ceil((maxY - minY) / gridSize);
  
  if (cols > 50 || rows > 50) return; // Too fine
  
  const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
  
  for (let i = 0; i < pts.x.length; i++) {
    const c = Math.floor((pts.x[i] - minX) / gridSize);
    const r = Math.floor((pts.y[i] - minY) / gridSize);
    if (c >= 0 && c < cols && r >= 0 && r < rows) {
      counts[r][c]++;
    }
  }
  
  const maxCount = Math.max(...counts.flat());
  if (maxCount === 0) return;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const count = counts[r][c];
      if (count === 0) continue;
      
      const alpha = 0.1 + 0.2 * (count / maxCount);
      const x = minX + c * gridSize;
      const y = minY + r * gridSize;
      
      const { sx: sx1, sy: sy1 } = toScreen(x, y);
      const { sx: sx2, sy: sy2 } = toScreen(x + gridSize, y + gridSize);
      
      ctx.fillStyle = `rgba(34, 211, 238, ${alpha})`;
      ctx.fillRect(sx1, sy2, sx2 - sx1, sy1 - sy2);
    }
  }
}

function getClusterColor(label) {
  if (label < 0) return '#64748b';
  
  const colors = [
    '#22c55e', '#3b82f6', '#f97316', '#a855f7', '#ec4899',
    '#14b8a6', '#eab308', '#ef4444', '#8b5cf6', '#06b6d4',
    '#84cc16', '#f43f5e', '#6366f1', '#10b981', '#f59e0b'
  ];
  
  return colors[label % colors.length];
}

// ============================================
// Canvas Interactions (Pan/Zoom for 2D and 3D)
// ============================================

function handleCanvasMouseDown(e) {
  STATE.renderQuality = 'low';
  STATE.lastInteraction = performance.now();
  const mode = el("plotMode").value;
  
  if (mode === "3d") {
    STATE.view3d.dragging = true;
    STATE.view3d.panning = e.shiftKey; // Shift+drag for pan in 3D
    STATE.view3d.lastX = e.clientX;
    STATE.view3d.lastY = e.clientY;
  } else {
    STATE.view2d.dragging = true;
    STATE.view2d.lastX = e.clientX;
    STATE.view2d.lastY = e.clientY;
  }
}

function handleCanvasMouseMove(e) {
  const mode = el("plotMode").value;
  
  if (mode === "3d" && STATE.view3d.dragging) {
    const dx = e.clientX - STATE.view3d.lastX;
    const dy = e.clientY - STATE.view3d.lastY;
    STATE.view3d.lastX = e.clientX;
    STATE.view3d.lastY = e.clientY;
    
    if (STATE.view3d.panning || e.shiftKey) {
      // Pan in 3D
      STATE.view3d.panX = (STATE.view3d.panX || 0) + dx * 2;
      STATE.view3d.panY = (STATE.view3d.panY || 0) + dy * 2;
      STATE.depthCache = null; // Invalidate cache on pan
    } else {
      // Rotate
      STATE.view3d.yaw += dx * 0.01;
      STATE.view3d.pitch += dy * 0.01;
      STATE.view3d.pitch = Math.max(-1.5, Math.min(1.5, STATE.view3d.pitch));
    }
    
    redrawPlot();
  } else if (mode === "2d" && STATE.view2d.dragging) {
    const dx = e.clientX - STATE.view2d.lastX;
    const dy = e.clientY - STATE.view2d.lastY;
    STATE.view2d.lastX = e.clientX;
    STATE.view2d.lastY = e.clientY;
    
    const dpr = window.devicePixelRatio || 1;
    STATE.view2d.panX += dx * dpr;
    STATE.view2d.panY += dy * dpr;
    
    redrawPlot();
  }
}

function handleCanvasMouseUp() {
  STATE.view2d.dragging = false;
  STATE.view3d.dragging = false;
  STATE.view3d.panning = false;
  setTimeout(() => {
    if (performance.now() - STATE.lastInteraction > 100) {
      STATE.renderQuality = 'high';
      redrawPlot();
    }
  }, 150);
}

function handleCanvasWheel(e) {
  e.preventDefault();
  const mode = el("plotMode").value;
  const delta = Math.sign(e.deltaY);
  
  if (mode === "3d") {
    STATE.view3d.zoom *= delta > 0 ? 0.9 : 1.1;
    STATE.view3d.zoom = Math.max(0.3, Math.min(10, STATE.view3d.zoom));
    STATE.depthCache = null; // Invalidate cache on zoom
    // Sync with slider
    el("zoomSlider").value = STATE.view3d.zoom;
  } else {
    // Zoom centered on mouse position
    const canvas = el("plotCanvas");
    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    const zoomSlider = el("zoomSlider");
    const oldZoom = parseFloat(zoomSlider.value);
    const newZoom = delta > 0 ? oldZoom * 0.9 : oldZoom * 1.1;
    const clampedZoom = Math.max(0.5, Math.min(10, newZoom));
    
    // Adjust pan to zoom toward mouse position
    const zoomRatio = clampedZoom / oldZoom;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    STATE.view2d.panX = mouseX - (mouseX - STATE.view2d.panX - centerX) * zoomRatio - centerX;
    STATE.view2d.panY = mouseY - (mouseY - STATE.view2d.panY - centerY) * zoomRatio - centerY;
    
    zoomSlider.value = clampedZoom;
  }
  
  redrawPlot();
}

// ============================================
// Export Functions
// ============================================

function exportCsv() {
  if (!STATE.lastResult || !STATE.rows.length) return;
  
  const labels = STATE.lastResult.labels_full;
  const usedMask = STATE.lastResult.used_mask;
  
  const headerOut = [...STATE.header, "dbscan_cluster", "dbscan_used"];
  const lines = [headerOut.join(",")];
  
  for (let r = 0; r < STATE.rows.length; r++) {
    const row = [...STATE.rows[r]];
    const used = usedMask[r] === 1;
    const label = labels[r];
    
    row.push(used && label >= -1 ? String(label) : "");
    row.push(used ? "1" : "0");
    
    lines.push(row.map(cell => {
      if (cell.includes(",") || cell.includes('"')) {
        return `"${cell.replace(/"/g, '""')}"`;
      }
      return cell;
    }).join(","));
  }
  
  const blob = new Blob([lines.join("\n")], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (STATE.filename || "data").replace(/\.csv$/i, "") + "_dbscan.csv";
  a.click();
  URL.revokeObjectURL(url);
}

function exportPng() {
  const canvas = el("plotCanvas");
  const url = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = (STATE.filename || "plot").replace(/\.csv$/i, "") + "_dbscan.png";
  a.click();
}

// ============================================
// Initialize
// ============================================

updateSpeed();
</script>
</body>
</html>